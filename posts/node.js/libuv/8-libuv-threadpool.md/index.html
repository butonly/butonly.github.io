<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  <link href="//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">





















  
  
    
  
  <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  

  

  

  

  

  






  

<link href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'FRAAR0AUP0',
      apiKey: '459ace1d7f5aabfa15b4f89baba340b3',
      indexName: 'blog.butonly.com',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="http://docs.libuv.org/en/v1.x/threadpool.html http://docs.libuv.org/en/v1.x/dns.html  线程池在程序设计中是常用的提升并发计算能力、提升吞吐量的常用手段，在 libnv 也不例外，并且结合事件循环，实现了异步支持。 libuv 提供可用于执行用户代码的线程池，并且能够在任务完成时，向事件循环线程发送消息通知主线程">
<meta name="keywords" content="libuv,node.js,eventloop">
<meta property="og:type" content="article">
<meta property="og:title" content="libuv源码分析（八）线程池（Threadpool）">
<meta property="og:url" content="https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/index.html">
<meta property="og:site_name" content="lyj&#39;s blog">
<meta property="og:description" content="http://docs.libuv.org/en/v1.x/threadpool.html http://docs.libuv.org/en/v1.x/dns.html  线程池在程序设计中是常用的提升并发计算能力、提升吞吐量的常用手段，在 libnv 也不例外，并且结合事件循环，实现了异步支持。 libuv 提供可用于执行用户代码的线程池，并且能够在任务完成时，向事件循环线程发送消息通知主线程">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-23T07:01:17.938Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="libuv源码分析（八）线程池（Threadpool）">
<meta name="twitter:description" content="http://docs.libuv.org/en/v1.x/threadpool.html http://docs.libuv.org/en/v1.x/dns.html  线程池在程序设计中是常用的提升并发计算能力、提升吞吐量的常用手段，在 libnv 也不例外，并且结合事件循环，实现了异步支持。 libuv 提供可用于执行用户代码的线程池，并且能够在任务完成时，向事件循环线程发送消息通知主线程">



  <link rel="alternate" href="/atom.xml" title="lyj's blog" type="application/atom+xml">




  <link rel="canonical" href="https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>libuv源码分析（八）线程池（Threadpool） | lyj's blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=014348069229275019795:-z92dm0sjiy"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', '014348069229275019795:-z92dm0sjiy');
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4cd57e104d0d9f5862dd91d0acdb9eee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lyj's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">8</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">1</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">3</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lyj's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">libuv源码分析（八）线程池（Threadpool）

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-23 15:00:08" itemprop="dateCreated datePublished" datetime="2019-04-23T15:00:08+08:00">2019-04-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-23 15:01:17" itemprop="dateModified" datetime="2019-07-23T15:01:17+08:00">2019-07-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/源码分析/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/node.js/libuv/8-libuv-threadpool.md/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/node.js/libuv/8-libuv-threadpool.md/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><span class="exturl" data-url="aHR0cDovL2RvY3MubGlidXYub3JnL2VuL3YxLngvdGhyZWFkcG9vbC5odG1s" title="http://docs.libuv.org/en/v1.x/threadpool.html">http://docs.libuv.org/en/v1.x/threadpool.html<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2RvY3MubGlidXYub3JnL2VuL3YxLngvZG5zLmh0bWw=" title="http://docs.libuv.org/en/v1.x/dns.html">http://docs.libuv.org/en/v1.x/dns.html<i class="fa fa-external-link"></i></span></li>
</ul>
<p>线程池在程序设计中是常用的提升并发计算能力、提升吞吐量的常用手段，在 libnv 也不例外，并且结合事件循环，实现了异步支持。</p>
<p>libuv 提供可用于执行用户代码的线程池，并且能够在任务完成时，向事件循环线程发送消息通知主线程完成收尾工作。</p>
<p>默认情况下，线程池的大小是 <code>4</code>，但是可以在启动阶段通过设置 <code>UV_THREADPOOL_SIZE</code> 环境变量进行修改，最大为 <code>128</code>。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>线程池全局的并且跨所有事件循环共享，当特定的函数使用线程池时（例如，调用 <code>uv_queue_work()</code>），libuv 通过 <code>init_threads</code> 函数预分配和初始化一定数量的线程，初始化函数只会被调用一次，这会带来一定的内存开销，但是可以提升运行时性能。</p>
<h3 id="线程池初始化"><a href="#线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化</h3><p>线程池是由 <code>init_threads</code> 函数初始化的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_threads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* val;</span><br><span class="line">  <span class="keyword">uv_sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">  nthreads = ARRAY_SIZE(default_threads);</span><br><span class="line">  val = getenv(<span class="string">"UV_THREADPOOL_SIZE"</span>);</span><br><span class="line">  <span class="keyword">if</span> (val != <span class="literal">NULL</span>)</span><br><span class="line">    nthreads = atoi(val);</span><br><span class="line">  <span class="keyword">if</span> (nthreads == <span class="number">0</span>)</span><br><span class="line">    nthreads = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (nthreads &gt; MAX_THREADPOOL_SIZE)</span><br><span class="line">    nthreads = MAX_THREADPOOL_SIZE;</span><br><span class="line"></span><br><span class="line">  threads = default_threads;</span><br><span class="line">  <span class="keyword">if</span> (nthreads &gt; ARRAY_SIZE(default_threads)) &#123;</span><br><span class="line">    threads = uv__malloc(nthreads * <span class="keyword">sizeof</span>(threads[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      nthreads = ARRAY_SIZE(default_threads);</span><br><span class="line">      threads = default_threads;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_cond_init(&amp;cond))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_mutex_init(&amp;mutex))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  QUEUE_INIT(&amp;wq);</span><br><span class="line">  QUEUE_INIT(&amp;slow_io_pending_wq);</span><br><span class="line">  QUEUE_INIT(&amp;run_slow_work_message);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化逻辑如下：</p>
<ol>
<li>线程池中线程数量，并分配用于存储线程信息的内存空间；</li>
<li>初始化静态全局的 <code>线程锁</code> 和 <code>线程条件变量</code>；</li>
<li>初始化静态全局 <code>uv__work</code> 队列；<ol>
<li><code>wq</code> 待执行的任务队列，未执行完毕，<code>loop-&gt;wq</code> 同为任务队列，但是保持的是执行完毕的任务；</li>
<li><code>slow_io_pending_wq</code> 慢IO延迟任务队列；</li>
<li><code>run_slow_work_message</code> 慢IO延迟任务队列代表，当存在慢IO延迟任务队列时，<code>run_slow_work_message</code> 被插入到 <code>wq</code> 中代替所有慢IO任务排队；</li>
</ol>
</li>
<li>创建一定数量的线程；</li>
<li>等待所以线程创建完成。</li>
</ol>
<p>在创建线程的时候，线程执行的函数是 <code>worker</code>，该函数负责在线程中处理 <code>wq</code> 上的任务。</p>
<p><code>worker</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To avoid deadlock with uv_cancel() it's crucial that the worker</span></span><br><span class="line"><span class="comment"> * never holds the global mutex and the loop-local mutex at the same time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">int</span> is_slow_work;</span><br><span class="line"></span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁 mutex</span></span><br><span class="line">  <span class="comment">// 因为只有一个线程能抢占锁，所以多个线程也只能一个接一个的进入循环</span></span><br><span class="line">  <span class="comment">// 因为整个线程池中线程创建过程中不会出现其他线程在其他位置抢占并锁定 mutex 的情形出现，</span></span><br><span class="line">  <span class="comment">// 所以只有该位置会抢占加锁，而后很快释放锁，所以线程池中的线程之后短暂的阻塞在这里。</span></span><br><span class="line">  <span class="comment">// 工作线程需要不断的等待处理任务，所以需要进入死循环</span></span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* `mutex` should always be locked at this point. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep waiting while either no work is present or only slow I/O</span></span><br><span class="line"><span class="comment">       and we're at the threshold for that. */</span></span><br><span class="line">    <span class="comment">// 条件满足时，没有任务需要处理，线程进入挂起等待状态，等待被唤醒。</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      <span class="comment">// 任务队列为空</span></span><br><span class="line">      QUEUE_EMPTY(&amp;wq) ||</span><br><span class="line">      <span class="comment">// 任务队列非空，但是</span></span><br><span class="line">           <span class="comment">// 队列头部被标记为慢速IO任务</span></span><br><span class="line">           <span class="comment">// 且该队列中只有run_slow_work_message一个数据节点</span></span><br><span class="line">           <span class="comment">// 且正在处理的慢IO任务超过阈值（默认2）</span></span><br><span class="line">           <span class="comment">//   该一个条件避免太多线程同时都在处理慢IO操作</span></span><br><span class="line">           <span class="comment">//   达到阈值后空闲的线程不再接慢IO任务而是挂起，等待非慢IO操作任务 能有机会尽快得到处理</span></span><br><span class="line">           <span class="comment">//   正在进行的慢IO任务完成后，阈值限制解除，可以接慢IO任务</span></span><br><span class="line">           <span class="comment">//   最终，保证了最多只有 `(nthreads + 1) / 2` 个线程处理慢IO</span></span><br><span class="line">           <span class="comment">//   区分了快车道和慢车道后，能有效避免慢车堵快车，提升性能</span></span><br><span class="line">           (QUEUE_HEAD(&amp;wq) == &amp;run_slow_work_message</span><br><span class="line">           &amp;&amp; QUEUE_NEXT(&amp;run_slow_work_message) == &amp;wq </span><br><span class="line">           &amp;&amp; slow_io_work_running &gt;= slow_work_thread_threshold())) &#123;</span><br><span class="line">      <span class="comment">// 进入休息区，注意某线程在执行 while 循环时该线程一定抢占了 mutex，不论是首次还是后续执行</span></span><br><span class="line">      <span class="comment">// 线程挂起，等待唤醒</span></span><br><span class="line">      <span class="comment">// uv_cond_wait 会使线程挂起等待cond上的信号，为防止多线程同时调用 uv_cond_wait，必须提前加锁</span></span><br><span class="line">      <span class="comment">// uv_cond_wait 在挂起前会释放 mutex，其他阻塞在 mutex 上的线程会在 mutex 释放时被唤醒，并在唤醒时重新抢占 mutex，即只能唤醒一个</span></span><br><span class="line">      <span class="comment">// 所以，阻塞在for循环外的多个线程中的某一个会重新抢占 mutex 执行到达此处挂起，又继续唤醒其他线程</span></span><br><span class="line">      <span class="comment">//   也可能唤醒 阻塞在 uv__work_submit -&gt; post 函数提交任务的抢占锁的位置的线程（通常为主事件循环线程）</span></span><br><span class="line">      <span class="comment">// 挂起的线程都是空闲的线程，被唤醒后为非空闲的线程，所以需要更新空闲线程计数</span></span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);    </span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 挂起的线程在被唤醒后，一定不满足再次进入循环的条件，会继续向下执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入工作区，一共有三个区间，前后两个区间都有锁，中间的区间执行用户代码无锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程被唤醒，开始干活</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下操作因线程被唤醒时会自动对mutex上锁</span></span><br><span class="line">    <span class="comment">// 所以以下解锁前的区域对共享变量的操作都是安全的</span></span><br><span class="line">    <span class="comment">// 锁定区间代码同一时段只能有一个线程在执行</span></span><br><span class="line">    <span class="comment">// 因并无耗时任务，所以不会影响性能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务</span></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    <span class="comment">// 如果收到线程退出消息，跳出循环，线程声明周期结束</span></span><br><span class="line">    <span class="comment">// 在外部发送消息通知线程主动退出，也可在外部kill线程</span></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message) &#123;</span><br><span class="line">      uv_cond_signal(&amp;cond);</span><br><span class="line">      uv_mutex_unlock(&amp;mutex);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务摘出来</span></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);  <span class="comment">/* Signal uv_cancel() that the work req is executing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化慢IO操作标记为0，即非慢IO操作</span></span><br><span class="line">    is_slow_work = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q == &amp;run_slow_work_message) &#123;</span><br><span class="line">      <span class="comment">// 该任务为慢IO任务</span></span><br><span class="line">      <span class="comment">// 通常情况下，while 的第二个条件成立才能进入此段代码</span></span><br><span class="line">      <span class="comment">// 此时 q 只是一个慢IO任务标记，真正的任务在 slow_io_pending_wq 中</span></span><br><span class="line">      <span class="comment">// 所以需要特殊处理，获取真正的任务 q</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we're at the slow I/O threshold, re-schedule until after all</span></span><br><span class="line"><span class="comment">         other work in the queue is done. */</span></span><br><span class="line">      <span class="comment">// 如果当前运行的慢IO操作的线程数达到阈值（2个线程）</span></span><br><span class="line">      <span class="comment">// 则将这些操作插入到 wq 队列末尾，延迟处理</span></span><br><span class="line">      <span class="comment">// 避免多个线程同时处理慢IO</span></span><br><span class="line">      <span class="comment">// 临界状态：已经有达到阈值限制个数的线程进入工作区处理慢IO任务，但是还没执行更新慢IO线程计数器代码，</span></span><br><span class="line">      <span class="comment">//         后续被慢IO任务唤醒的线程线程可能因为慢IO线程计数器未更新而满足进入条件。</span></span><br><span class="line">      <span class="comment">//         但是，因为该区间锁定了 mutex，阻塞在 uv_cond_wait 处的代码无法抢占锁无法执行，也就是无法跳出 while 循环，</span></span><br><span class="line">      <span class="comment">//         到 mutex 释放时，被唤醒的线程能够抢占锁时，计数器已经被更新了，前面所说的进入条件不再满足了。</span></span><br><span class="line">      <span class="comment">//    所以，条件满足时不能动，能动了条件又不满足了，本质上，两次判断在同一段锁定区间，所以以下情形应该难以出现，难道还有其他情况？</span></span><br><span class="line">      <span class="keyword">if</span> (slow_io_work_running &gt;= slow_work_thread_threshold()) &#123;</span><br><span class="line">        QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we encountered a request to run slow I/O work but there is none</span></span><br><span class="line"><span class="comment">         to run, that means it's cancelled =&gt; Start over. */</span></span><br><span class="line">      <span class="comment">// 如果慢IO队列为空，可能任务被取消</span></span><br><span class="line">      <span class="keyword">if</span> (QUEUE_EMPTY(&amp;slow_io_pending_wq))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意以上两处不需要 uv_mutex_unlock(&amp;mutex)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记该线程正在处理慢IO操作，同时增加慢IO线程计数器</span></span><br><span class="line">      is_slow_work = <span class="number">1</span>;</span><br><span class="line">      slow_io_work_running++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从慢IO队列中重新获取任务</span></span><br><span class="line">      q = QUEUE_HEAD(&amp;slow_io_pending_wq);</span><br><span class="line">      QUEUE_REMOVE(q);</span><br><span class="line">      QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If there is more slow I/O work, schedule it to be run as well. */</span></span><br><span class="line">      <span class="comment">// 如果还有更多的慢IO操作，则将这些任务插入到 wq 队列末尾，本次只能处理 q 这一个任务</span></span><br><span class="line">      <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;slow_io_pending_wq)) &#123;</span><br><span class="line">        QUEUE_INSERT_TAIL(&amp;wq, &amp;run_slow_work_message);</span><br><span class="line">        <span class="comment">// 如果有空闲线程，唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">          uv_cond_signal(&amp;cond);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁 mutex</span></span><br><span class="line">    uv_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有以下两行不涉及竞态资源读写，不需要加锁，实际也不能锁</span></span><br><span class="line">    <span class="comment">// 慢IO任务还是非慢IO任务，指的是w-&gt;work</span></span><br><span class="line">    w = QUEUE_DATA(q, struct uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 loop 在多线程中共享，所以访问 loop 需要加锁</span></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  <span class="comment">/* Signal uv_cancel() that the work req is done</span></span><br><span class="line"><span class="comment">                        executing. */</span></span><br><span class="line">    <span class="comment">// 将完成的任务插入到 loop-&gt;wq 队列中，在主事件循环线程中处理</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    <span class="comment">// 发送完成信号，唤醒事件询线程并处理</span></span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lock `mutex` since that is expected at the start of the next</span></span><br><span class="line"><span class="comment">     * iteration. */</span></span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (is_slow_work) &#123;</span><br><span class="line">      <span class="comment">/* `slow_io_work_running` is protected by `mutex`. */</span></span><br><span class="line">      slow_io_work_running--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv_async_send</code> 已经分析过了，它向事件循环线程发送消息唤醒事件循环线程</p>
<h3 id="主线程中的初始化工作"><a href="#主线程中的初始化工作" class="headerlink" title="主线程中的初始化工作"></a>主线程中的初始化工作</h3><p>主线程中的初始化工作是先于线程池初始化的，这部分初始化完成了用于接收 work 线程消息的 AsyncHandle 的初始化工作。</p>
<p><code>uv_async_send</code> 通过 <code>loop-&gt;wq_async</code> Handle 发送了消息，字段定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_PRIVATE_FIELDS                                                \</span></span><br><span class="line">  <span class="keyword">uv_mutex_t</span> wq_mutex;                                                        \</span><br><span class="line">  <span class="keyword">uv_async_t</span> wq_async;                                                        \</span><br></pre></td></tr></table></figure>
<p><code>loop-&gt;wq_async</code> 是在 <code>uv_loop_init</code> 初始化的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_loop_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">  loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loop-&gt;wq_async</code> 被解引用了，所以并不会影响 <code>loop</code> 的活动状态。</p>
<p><code>loop-&gt;wq_async</code> 的事件处理函数是 <code>uv__work_done</code>，该函数在事件循环线程中执行，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_done</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  <span class="keyword">uv_loop_t</span>* loop;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE wq;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出所有已完成的work，因与其他线程共享此变量，所以需要同步，因此此处可能会导致事件循环线程短暂阻塞</span></span><br><span class="line">  loop = container_of(handle, <span class="keyword">uv_loop_t</span>, wq_async);</span><br><span class="line">  uv_mutex_lock(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;wq, &amp;wq);</span><br><span class="line">  uv_mutex_unlock(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有已完成的work，调用 w-&gt;done，done 函数由用户提供</span></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line"></span><br><span class="line">    w = container_of(q, struct uv__work, wq);</span><br><span class="line">    err = (w-&gt;work == uv__cancelled) ? UV_ECANCELED : <span class="number">0</span>;</span><br><span class="line">    w-&gt;done(w, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从线程池初始化到线程处理任务再到线程与事件循环线程通信最后事件循环线程清理已完成的任务的整个流程已经分析完成。</p>
<p>下面，该了解一下，如何向线程池提交任务任务了。</p>
<h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><p>向线程池提交任务的 API 是 <code>uv_queue_work</code>，也实现线程池唯一对外暴露的 API，下面我们看它的具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_queue_work</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">uv_work_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_work_cb work_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_after_work_cb after_work_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  uv__req_init(loop, req, UV_WORK);</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;work_cb = work_cb;</span><br><span class="line">  req-&gt;after_work_cb = after_work_cb;</span><br><span class="line">  uv__work_submit(loop,</span><br><span class="line">                  &amp;req-&gt;work_req,</span><br><span class="line">                  UV__WORK_CPU,</span><br><span class="line">                  uv__queue_work,</span><br><span class="line">                  uv__queue_done);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv_queue_work</code> 初始化了一个 <code>uv_work_t</code> 类型的 <code>request</code>，<code>work_cb</code> 为线程池中线程执行的函数，<code>after_work_cb</code> 为 <code>work_cb</code> 执行完成之后在事件循环线程中执行的函数，<code>req-&gt;work_req</code> 是队列节点。最后通过 <code>uv__work_submit</code> 向线程池中提交任务。</p>
<p>最后通过调用 <code>uv__work_submit</code> 向线程池中提交任务，<code>uv__work_submit</code> 的两个实参 <code>uv__queue_work</code> 和 <code>uv__queue_done</code> 分别对 <code>work_cb</code> 和 <code>after_work_cb</code> 进行简单的封装。实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__queue_work</span><span class="params">(struct uv__work* w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_work_t</span>* req = container_of(w, <span class="keyword">uv_work_t</span>, work_req);</span><br><span class="line"></span><br><span class="line">  req-&gt;work_cb(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__queue_done</span><span class="params">(struct uv__work* w, <span class="keyword">int</span> err)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_work_t</span>* req;</span><br><span class="line"></span><br><span class="line">  req = container_of(w, <span class="keyword">uv_work_t</span>, work_req);</span><br><span class="line">  uv__req_unregister(req-&gt;loop, req);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;after_work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  req-&gt;after_work_cb(req, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv__work_submit</code> 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct uv__work* w,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">enum</span> uv__work_kind kind,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> (*work)(struct uv__work* w),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> (*done)(struct uv__work* w, <span class="keyword">int</span> status))</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq, kind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv__work_submit</code> 通过调用 <code>init_once</code> 初始化线程池，<code>uv_once</code> 确保线程池初始化函数 <code>init_once</code> 只会被调用一次。</p>
<p>然后对 <code>uv__work</code> 进行初始化，<code>w-&gt;work</code> 在工作线程 <code>worker</code> 中调用，<code>w-&gt;done</code> 在事件循环线程 <code>uv__work_done</code> 中调用</p>
<p>最后通过调用 <code>post</code> 提交任务，<code>post</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(QUEUE* q, <span class="keyword">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">if</span> (kind == UV__WORK_SLOW_IO) &#123;</span><br><span class="line">    <span class="comment">/* Insert into a separate queue. */</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;slow_io_pending_wq, q);</span><br><span class="line">    <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;run_slow_work_message)) &#123;</span><br><span class="line">      <span class="comment">/* Running slow I/O tasks is already scheduled =&gt; Nothing to do here.</span></span><br><span class="line"><span class="comment">         The worker that runs said other task will schedule this one as well. */</span></span><br><span class="line">      uv_mutex_unlock(&amp;mutex);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;run_slow_work_message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">  <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">    uv_cond_signal(&amp;cond);</span><br><span class="line">  uv_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为任务队列会被线程池中的多个线程并发访问，所以在操作队列之前需要先加锁，完成之后需要解锁。如果有空闲的线程，则立即唤醒它们进行工作。</p>
<p>在 <code>post</code> 中，慢IO任务被插入到 <code>slow_io_pending_wq</code> 队列中，如果 <code>run_slow_work_message</code> 不在 <code>wq</code> 中，则需要将 <code>run_slow_work_message</code> 插入 <code>wq</code> 队列尾部，标识 <code>slow_io_pending_wq</code> 中存在任务，当 <code>run_slow_work_message</code> 得到被处理机会时，处理慢任务队列中的任务。</p>
<p>在 <code>uv_queue_work</code> 中的 <code>uv__work_submit</code> 调用时，传递的是 <code>UV__WORK_CPU</code> 表示 CPU 密集型任务。</p>
<p>任务可能在任意一个线程中提交，通常是在事件循环线程中提交，但是也有可能在work线程中提交，即，<code>w-&gt;work</code> 和 <code>w-&gt;done</code> 这两个函数中都有可能调用 <code>uv__work_submit</code>，这取决于实现。</p>
<p>将任务提交到工作队列中，这一阶段的工作就已经完成了，线程池中的线程可以开始工作了。</p>
<p>至此，整个线程池的工作原理已经分析完成，整个工作流程大致可分为三个阶段：</p>
<ol>
<li>提交任务；</li>
<li>work线程处理任务，完成后通知事件循环线程；</li>
<li>事件循环线程收到通知后完成收尾工作。</li>
</ol>
<p>在接口使用中，是不需要太关心以上流程和工作原理的，更应该关系 <code>work_cb</code> 和 <code>after_work_cb</code> 以及其他逻辑的实现。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>线程池在 libuv 内部用于完成所有文件系统操作（<code>requests</code>），也用于实现 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 等 DNS 相关的操作（<code>requests</code>）。搜索 <code>uv_queue_work</code> 可找到相关使用位置。可以这些内部实现作为使用示例，在内部，并不通过 <code>uv_queue_work</code> 提交任务，而是直接调用 <code>uv__work_submit</code>，因为它们都有各自不同的 <code>uv__x_work</code> 和 <code>uv__x_done</code> 实现。</p>
<hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXlhbmppZS9rbm93bGVkZ2UvdHJlZS9tYXN0ZXIvbm9kZS5qcy9saWJ1di84LWxpYnV2LXRocmVhZHBvb2wubWQ=" title="https://github.com/liuyanjie/knowledge/tree/master/node.js/libuv/8-libuv-threadpool.md">查看源文件<i class="fa fa-external-link"></i></span>&nbsp;&nbsp;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXlhbmppZS9rbm93bGVkZ2UvZWRpdC9tYXN0ZXIvbm9kZS5qcy9saWJ1di84LWxpYnV2LXRocmVhZHBvb2wubWQ=" title="https://github.com/liuyanjie/knowledge/edit/master/node.js/libuv/8-libuv-threadpool.md">编辑源文件<i class="fa fa-external-link"></i></span></p>

      
    </div>

    
      

  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/node.js/libuv/4-libuv-timer.md/" rel="bookmark">libuv源码分析（四）定时器（Timer）</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/node.js/libuv/2-libuv-event-loop.md/" rel="bookmark">libuv源码分析（二）事件循环（Eventloop）</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/node.js/libuv/3-libuv-handle-and-request.md/" rel="bookmark">libuv源码分析（三）资源抽象：Handle 和 Request</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/node.js/libuv/1-libuv-overview.md/" rel="bookmark">libuv源码分析（一）全局概览（Overview）</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/node.js/libuv/6-libuv-stream.md/" rel="bookmark">libuv源码分析（六）流（Stream）</a></div>
      
    </li>
  
  </ul>


    

    
    
    

    

    
      
    
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>lyj</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/" title="libuv源码分析（八）线程池（Threadpool）">https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/libuv/" rel="tag"># libuv</a>
          
            <a href="/tags/node-js/" rel="tag"># node.js</a>
          
            <a href="/tags/eventloop/" rel="tag"># eventloop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/node.js/libuv/7-libuv-async.md/" rel="next" title="libuv源码分析（七）异步唤醒（Async）">
                <i class="fa fa-chevron-left"></i> libuv源码分析（七）异步唤醒（Async）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/avatar.png" alt="lyj">
            
              <p class="site-author-name" itemprop="name">lyj</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXlhbmppZQ==" title="GitHub &rarr; https://github.com/liuyanjie"><i class="fa fa-fw fa-github"></i></span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="/liuyj619@gmail.com" title="E-Mail &rarr; liuyj619@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
                
              
              
              
              <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池初始化"><span class="nav-number">1.1.</span> <span class="nav-text">线程池初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程中的初始化工作"><span class="nav-number">1.2.</span> <span class="nav-text">主线程中的初始化工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务提交"><span class="nav-number">2.</span> <span class="nav-text">任务提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Example"><span class="nav-number">3.</span> <span class="nav-text">Example</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyj</span>

  

  
</div>


  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> v6.6.0</div>



  <div class="footer-custom">Hosted by <a href="https://github.com/liuyanjie/liuyanjie.github.io" class="theme-link" rel="noopener" target="_blank">GitHub Pages</a></div>


        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  













  



  
  
    <script src="//cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script>
  

  
  
    <script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.min.js"></script>
  

  
  
    <script src="//cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>
  

  
  
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1.1/reading_progress.min.js"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  

  
    <script id="dsq-count-scr" src="https://liuyanjie.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool.md/";
        this.page.identifier = "posts/node.js/libuv/8-libuv-threadpool.md/";
        this.page.title = 'libuv源码分析（八）线程池（Threadpool）';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://liuyanjie.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        $(function () {
          var offsetTop = $('#comments').offset().top - $(window).height();
          if (offsetTop <= 0) {
            // load directly when there's no a scrollbar
            loadComments();
          } else {
            $(window).on('scroll.disqus_scroll', function () {
              // offsetTop may changes because of manually resizing browser window or lazy loading images.
              var offsetTop = $('#comments').offset().top - $(window).height();
              var scrollTop = $(window).scrollTop();

              // pre-load comments a bit? (margin or anything else)
              if (offsetTop - scrollTop < 60) {
                $(window).off('.disqus_scroll');
                loadComments();
              }
            });
          }
        });
      
    </script>
  













  




  
  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.min.css">

  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.6.0"></script>



  

  

  

  

  
  

  
  

  


  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/pangu@3.3.0/dist/browser/pangu.min.js"></script>
  <script>pangu.spacingPage();</script>


  
  <script src="/js/src/js.cookie.js?v=6.6.0"></script>
  <script src="/js/src/scroll-cookie.js?v=6.6.0"></script>


  
  <script src="/js/src/exturl.js?v=6.6.0"></script>


  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1.0.0/bookmark.min.js"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  

  
  

  
  

  


</body>
</html>
