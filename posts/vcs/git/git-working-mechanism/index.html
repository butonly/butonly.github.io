<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/favicon.png" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;blog.butonly.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:true,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;FRAAR0AUP0&quot;,&quot;apiKey&quot;:&quot;459ace1d7f5aabfa15b4f89baba340b3&quot;,&quot;indexName&quot;:&quot;blog.butonly.com&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}</script>
<meta name="description" content="Git 是当前最广泛使用的版本控制系统，具备非常强大的版本控制能力。Git 有非常多的命令，很多人被种类繁多的命令搞的非常头大，也会经常忘记。本文尝试从原理角度来介绍 Git 常用命令，以便于加深对 Git 原理的理解。只有理解了原理，才能知道这些命令到底对仓库做了什么，进而才能更好使用命令，也更加不容易忘记。作为一个版本控制系统，理解其原理也是十分必要的，否则，很多命令根本不敢用，用错了可能会造">
<meta property="og:type" content="article">
<meta property="og:title" content="Git命令工作机制">
<meta property="og:url" content="https://blog.butonly.com/posts/vcs/git/git-working-mechanism/index.html">
<meta property="og:site_name" content="liuyanjie&#39;s blog">
<meta property="og:description" content="Git 是当前最广泛使用的版本控制系统，具备非常强大的版本控制能力。Git 有非常多的命令，很多人被种类繁多的命令搞的非常头大，也会经常忘记。本文尝试从原理角度来介绍 Git 常用命令，以便于加深对 Git 原理的理解。只有理解了原理，才能知道这些命令到底对仓库做了什么，进而才能更好使用命令，也更加不容易忘记。作为一个版本控制系统，理解其原理也是十分必要的，否则，很多命令根本不敢用，用错了可能会造">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-06-24T04:00:00.000Z">
<meta property="article:modified_time" content="2021-05-23T05:15:53.021Z">
<meta property="article:author" content="liuyanjie">
<meta property="article:tag" content="vcs">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.butonly.com/posts/vcs/git/git-working-mechanism/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;blog.butonly.com&#x2F;posts&#x2F;vcs&#x2F;git&#x2F;git-working-mechanism&#x2F;&quot;,&quot;path&quot;:&quot;posts&#x2F;vcs&#x2F;git&#x2F;git-working-mechanism&#x2F;&quot;,&quot;title&quot;:&quot;Git命令工作机制&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Git命令工作机制 | liuyanjie's blog</title><script src="/js/config.js"></script>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=014348069229275019795:-z92dm0sjiy"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;014348069229275019795:-z92dm0sjiy&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?4cd57e104d0d9f5862dd91d0acdb9eee"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="liuyanjie's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liuyanjie's blog</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/logo.png" alt="liuyanjie's blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">5</span></a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%93%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">仓库概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">仓库创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Init"><span class="nav-number">2.1.</span> <span class="nav-text">Init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Clone"><span class="nav-number">2.2.</span> <span class="nav-text">Clone</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">仓库同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-remote"><span class="nav-number">3.1.</span> <span class="nav-text">git remote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-fetch"><span class="nav-number">3.2.</span> <span class="nav-text">git fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-pull"><span class="nav-number">3.3.</span> <span class="nav-text">git pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-push"><span class="nav-number">3.4.</span> <span class="nav-text">git push</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-submodule"><span class="nav-number">3.5.</span> <span class="nav-text">git submodule</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">分支管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-branch"><span class="nav-number">4.1.</span> <span class="nav-text">git-branch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-tag"><span class="nav-number">4.2.</span> <span class="nav-text">git-tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-checkout"><span class="nav-number">4.3.</span> <span class="nav-text">git-checkout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-merge"><span class="nav-number">4.4.</span> <span class="nav-text">git-merge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add"><span class="nav-number">5.1.</span> <span class="nav-text">git add</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rm"><span class="nav-number">5.2.</span> <span class="nav-text">git rm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-mv"><span class="nav-number">5.3.</span> <span class="nav-text">git mv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-diff"><span class="nav-number">5.4.</span> <span class="nav-text">git diff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-commit"><span class="nav-number">5.5.</span> <span class="nav-text">git commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-status"><span class="nav-number">5.6.</span> <span class="nav-text">git status</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-reset"><span class="nav-number">5.7.</span> <span class="nav-text">git reset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-revert"><span class="nav-number">5.8.</span> <span class="nav-text">git revert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rebase"><span class="nav-number">5.9.</span> <span class="nav-text">git rebase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-cherry-pick"><span class="nav-number">5.10.</span> <span class="nav-text">git cherry-pick</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liuyanjie"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">liuyanjie</p>
  <div class="site-description" itemprop="description">KISS DRY</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liuyanjie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuyanjie" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/liuyj619@gmail.com" title="E-Mail → liuyj619@gmail.com"><i class="envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/butonly" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/vcs/git/git-working-mechanism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git命令工作机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-24 12:00:00" itemprop="dateCreated datePublished" datetime="2019-06-24T12:00:00+08:00">2019-06-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-23 13:15:53" itemprop="dateModified" datetime="2021-05-23T13:15:53+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/vcs/git/git-working-mechanism/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/vcs/git/git-working-mechanism/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Git 是当前最广泛使用的版本控制系统，具备非常强大的版本控制能力。Git 有非常多的命令，很多人被种类繁多的命令搞的非常头大，也会经常忘记。本文尝试从原理角度来介绍 Git 常用命令，以便于加深对 Git 原理的理解。只有理解了原理，才能知道这些命令到底对仓库做了什么，进而才能更好使用命令，也更加不容易忘记。作为一个版本控制系统，理解其原理也是十分必要的，否则，很多命令根本不敢用，用错了可能会造成严重后果，搞丢代码的成本是非常大的，谁都不想自己或他人做工作被一键抹除。知道原理后，即使一不小心操作错了，也可以坦然处之，轻松恢复。</p>
<p>相比命令行工具，可视化的 GUI 就要直观和方便很多，但是很多时候一样可能因为对于具体做什么不了解而操作错误，并且，目前常用的 GUI 软件，都未提供全部的命令行操作能力，GUI 很多时候，也没有命令方便快捷。</p>
<h2 id="仓库概述"><a href="#仓库概述" class="headerlink" title="仓库概述"></a>仓库概述</h2><p>Git 是一个分布式的版本控制系统，不同于 <strong>svn</strong> 只有一个<strong>中心仓库</strong>，必须能连接到 svn 服务才能提交，Git 可以随时提交而不依赖于中心仓库，因为本地存在一个独立的仓库，完全支持离线操作。本地仓库和远程仓库是一种比较松散的关系。</p>
<p>Git 中，每个仓库可以存在多个仓库副本，这个仓库暂且称为 “原始仓库”，“原始仓库” 因为需要备份或协作等方面的需要通常存储在托管服务器上。</p>
<p><strong>仓库副本</strong>通常是通过 <code>clone</code> 或 <code>Fork</code>（本质其实也是<code>clone</code>） 创建的，仓库副本和原始仓库是<strong>上下游</strong>关系，这些副本仓库可能在本地，也可能在某台服务器上。</p>
<p><strong>原始仓库</strong>如果托管在托管服务器上，通过 <code>Fork</code> 的方式可以创建很多位于托管服务上的副本，这些副本在不同的账户下，<code>Fork</code> 并不是 Git 提供的，而是托管服务提供的。<code>Fork</code> 出来的仓库副本与原始仓库之间的关系也由托管服务记录和维护的，这些副本仓库都有一个相同的 <code>上游仓库</code>（即原始仓库），同时副本仓库也可以继续被 <code>Fork</code> 产生多个 <code>下游仓库</code>，下游仓库可以通过 <code>PullRequest/MergeRequest</code> 向上游仓库发起跨仓库的 <code>merge</code> 请求，进行仓库间的交互。这些位于托管服务上的仓库，不论是原始仓库还是<code>Fork</code>出来的副本仓库，都可以被 <code>clone</code> 到本地创建本地仓库，本地仓库也是一个副本。</p>
<p><strong>本地仓库</strong>可以是<strong>原始仓库</strong>的副本，也可以是<strong>原始仓库</strong>的某副本的副本，相对于本地仓库，这些仓库称之为<strong>远程仓库</strong>，本地版本库可以同时对应多个远程仓库。本地仓库通过 <code>push</code>、<code>fetch</code> 等命令和远程仓库同步。</p>
<p>通过前面的描述，引申出了几个概念：原始仓库 &lt;-&gt; 副本仓库、上游仓库 &lt;-&gt; 下游仓库、远程仓库 &lt;-&gt; 本地仓库，这些概念都是相对而言的，便于进行角色区分。</p>
<p>仓库间的交互：</p>
<ol>
<li>远程仓库 和 本地仓库 之间，主要进行的是同步，本地修改同步到远程，或远程同步到本地。</li>
<li>远程仓库 和 远程仓库 之间，主要进行的是跨仓库的分支合并，也就是 <code>PullRequest/MergeRequest</code>。</li>
</ol>
<p>在未使用 <code>Fork</code> 的模式中，就没有 <code>2</code> 这种情况了。</p>
<p>本地仓库主要用来完成内容变更，远程仓库主要用来完成多人协作与数据备份。</p>
<p>托管服务上，<code>Fork</code> 创建的仓库副本关系如下：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">base</span>/<span class="built_in">Base</span></span><br><span class="line">├──── user_a1/<span class="built_in">Base</span></span><br><span class="line">├──── user_a2/<span class="built_in">Base</span></span><br><span class="line">├──── user_a3/<span class="built_in">Base</span></span><br><span class="line">├──── user_a4/<span class="built_in">Base</span></span><br><span class="line">│     ├─── user_b1/<span class="built_in">Base</span></span><br><span class="line">│     └─── user_b2/<span class="built_in">Base</span></span><br><span class="line">└──── user_a5/<span class="built_in">Base</span></span><br></pre></td></tr></table></figure>

<p>这些仓库都可被有权限的用户 <code>pull</code> 本地仓库，并正在修改之后 <code>push</code> 远程仓库。</p>
<p>为什么需要 <code>Fork</code>？</p>
<ol>
<li>避免分配原始仓库的访问权限给无关用户，防止仓库被破坏</li>
<li>本地仓库无法直接 Merge 到远程仓库，远程副本仓库能够提供了合并到原始仓库的能力</li>
<li>合并需要发起 <code>PullRequest/MergeRequest</code> 提供了代码审核的窗口</li>
</ol>
<p>Git 的单个仓库的工作原理是比较简单的，但是当多个不同角色的仓库同时存在协同工作的时候，确实非常复杂的，有非常多的玩法。只有真正的理解内部原理，方能运用自如。</p>
<p>Git 的命令是建立在这些底层模型上的，命令也正是为处理并维护这些关系而设计的。所以也只要有理解原理，才能熟练运用这些命令。</p>
<p>下面开始进入正题。</p>
<h2 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h2><p>任何操作开始前，首先要有个一个仓库。</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-init">Init</a></h3><p>核心功能：</p>
<ol>
<li>创建一个新的空 Git 仓库，或者重新初始化一个已经存在的 Git 仓库。</li>
</ol>
<p>常规方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git init workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/workspace/.git/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">└── workspace</span><br><span class="line">    └── .git</span><br><span class="line">        ├── refs</span><br><span class="line">        │   ├── tags</span><br><span class="line">        │   └── heads</span><br><span class="line">        ├── objects</span><br><span class="line">        │   ├── pack</span><br><span class="line">        │   └── info</span><br><span class="line">        ├── info</span><br><span class="line">        │   └── exclude</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── update.sample</span><br><span class="line">        │   ├── prepare-commit-msg.sample</span><br><span class="line">        │   ├── pre-receive.sample</span><br><span class="line">        │   ├── pre-rebase.sample</span><br><span class="line">        │   ├── pre-push.sample</span><br><span class="line">        │   ├── pre-commit.sample</span><br><span class="line">        │   ├── pre-applypatch.sample</span><br><span class="line">        │   ├── post-update.sample</span><br><span class="line">        │   ├── fsmonitor-watchman.sample</span><br><span class="line">        │   ├── commit-msg.sample</span><br><span class="line">        │   └── applypatch-msg.sample</span><br><span class="line">        ├── description</span><br><span class="line">        ├── config</span><br><span class="line">        └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br></pre></td></tr></table></figure>

<p>以上创建的仓库，仓库文件 存放在 工作区目录 <code>workspace</code> 的子目录 <code>.git</code> 下。</p>
<p>分离的方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git init --separate-git-dir=.tig workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/.tig/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">├── workspace</span><br><span class="line">│   └── .git</span><br><span class="line">└── .tig</span><br><span class="line">    ├── refs</span><br><span class="line">    │   ├── tags</span><br><span class="line">    │   └── heads</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── pack</span><br><span class="line">    │   └── info</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── update.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   └── applypatch-msg.sample</span><br><span class="line">    ├── description</span><br><span class="line">    ├── config</span><br><span class="line">    └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 16 files</span><br><span class="line"></span><br><span class="line">$ cat workspace/.git</span><br><span class="line">gitdir: /Users/liuyanjie/git-learn/.tig</span><br></pre></td></tr></table></figure>

<p>从上面的目录结构可以看到，相比常规方式创建仓库，通过分离的方式创建的仓库将 <code>仓库(.git)</code> 从 <code>工作区目录(workspace)</code> 中分离出去。<code>仓库(.git)</code> 不再是一个目录，而是包含指向仓库路径的一个文件，实际上利用这一特性，可以创建多个工作区共享同一仓库，也就可以支持同一个仓库拥有多个工作区。</p>
<p>另外也可以通过环境变量 <code>GIT_DIR=path/to/repo.git</code> 指定 <code>仓库(.git)</code> 的路径，下面这种方式和上面的方式是等价的（注意：相对路径不同）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_DIR=../.tig git init workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/.tig/</span><br></pre></td></tr></table></figure>

<p>不仅如此，Git 还支持将 Objects 从 <code>仓库(.git)</code> 中移出，通过 <code>GIT_OBJECT_DIRECTORY=$GIT_DIR/objects</code> Git 对象存储路径，不过这种用法在本地很少见。</p>
<p>有兴趣可以用以下命令做实验：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_OBJECT_DIRECTORY=../objects GIT_DIR=../.tig git init workspace</span><br></pre></td></tr></table></figure>

<p>默认情况下，仓库在创建的过程中，拷贝了一些的模版文件到 <code>仓库(.git)</code> 目录下，默认的模版路径和文件示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree /usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">└── info</span><br><span class="line">    └── exclude</span><br><span class="line"></span><br><span class="line">2 directories, 13 files</span><br></pre></td></tr></table></figure>

<p>可以看到，模版目录里面的内容，和实际仓库的内容相同的，用模版创建仓库时，就是原封不动的将仓库内容拷贝到仓库目录下。<br>基于这一点，我们可以以一个已经存在的仓库作为模版，创建另一个仓库，Git 会把模板路径下的文件的拷贝到新的仓库下。</p>
<p>可以在运行的时候通过 <code>--template=</code> 或 <code>GIT_TEMPLATE_DIR</code> 环境变量 或 <code>init.templateDir</code> 配置 指定模版路径位置。</p>
<p>还可以通过 <code>git init --bare</code> 参数创建一个裸仓库，裸仓库的指没有工作区的仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git init --bare          </span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/</span><br><span class="line"></span><br><span class="line"><span class="comment"># liuyanjie @ bogon in /Users/liuyanjie/git-learn on git:master o [16:48:01] </span></span><br><span class="line">$ ls</span><br><span class="line">HEAD        config      description hooks       info        objects     refs</span><br></pre></td></tr></table></figure>

<p>因为无工作区，仓库文件直接放在当前目录下了，可以手动创建工作区并链接到仓库目录。</p>
<p>在一个已经存在的仓库目录中运行 <code>init</code> 命令是安全的，它不会覆盖原来已经存在的文件（包括仓库和工作区）。<br>重新运行 <code>init</code> 的可以用来安装新添加的模版，或者用来将仓库分离到其他的位置。</p>
<p>新创建的仓库的仓库配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">	<span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line">	<span class="attr">filemode</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">ignorecase</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">precomposeunicode</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>只有 <code>core</code> 相关的几个配置项。</p>
<p>通过以上对命令及参数的效果的参考，可以了解到 Git 文档中不为人知的一些内容。</p>
<p>初始化仓库是 Git 工作流中的第一步，通常发生在本地，在托管服务创建仓库之后，仓库并未初始化，需要在本地创建并初始化仓库后，同步到远程，然后再同步本地。</p>
<p>通常情况下，都是需要两个仓库的，一个本地仓库，一个远程仓库，以支持复杂的开发工作流。</p>
<h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone">Clone</a></h3><p>核心功能：</p>
<ol>
<li>初始化并配置仓库，记录本地仓库和远程仓库的对应关系，包括仓库和分支映射关系<ol>
<li>克隆仓库到一个新的目录，实际上就是 <code>git init</code></li>
<li>为每一个被克隆仓库中的分支创建对应的远程追踪分支</li>
<li>从克隆仓库的当前活动分支创建并检出初始分支到工作区目录</li>
</ol>
</li>
<li>同步仓库<ol>
<li>通过 <code>git fetch</code> 更新所有远程追踪分支</li>
<li>通过 <code>git pull</code> 合并远程 <code>master</code> 分支到本地 <code>master</code> 分支，快速合并</li>
</ol>
</li>
</ol>
<p>类似于如下过程：</p>
<p><code>git init</code> -&gt; <code>git remote set-url origin git://...</code> -&gt; <code>git fetch</code> -&gt; <code>git pull</code> -&gt; <code>git checkout HEAD</code></p>
<p>通过以上核心功能可以看到，<code>Clone</code> 实际上是对多个命令功能的组合，并进行了一些配置工作。这样我们可以猜测，<code>Clone</code> 命令的很多参数应该是从其他命令继承过来的。</p>
<p>克隆一个远程仓库需要存在一个远程仓库，并且有一个可以访问的远程仓库的地址，Git支持多种访问协议，最常见的如 <code>git://</code> 和 <code>https://</code>。<br>详见：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a">GIT-URLS</a></p>
<p>下面是一个常见的 <code>clone</code> 操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/spec.git</span><br><span class="line">Cloning into <span class="string">&#x27;spec&#x27;</span>...</span><br><span class="line">remote: Counting objects: 49, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 49 (delta 0), reused 0 (delta 0), pack-reused 49</span><br><span class="line">Receiving objects: 100% (49/49), 49.83 KiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (15/15), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>通过输出内容可以看到，<code>Clone</code> 主要都做了哪些事情，可以对比上面的过程描述。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat spec/.git/config</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	url = git@github.com:liuyanjie/spec.git</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">&quot;master&quot;</span>]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/master</span><br></pre></td></tr></table></figure>

<p><code>git clone</code> 之后的仓库配置中，可以看到多出了以上内容，配置了对应的远程仓库地址及追踪关系，配置了本地 <code>master</code> 对应的远程分支，该配置为 Git 默认配置，一般不需要修改。</p>
<p>常见用法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆本地仓库 默认是硬链接的，关闭需要加 --no-hardlinks</span></span><br><span class="line">git <span class="built_in">clone</span> path/to/<span class="built_in">local</span>/git/repository</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Counting objects: 495, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (141/141), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库 只克隆最后一个Commit提速</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git --depth=1</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Counting objects: 300, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (247/247), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库 只克隆最后一个Commit提速，并通过另外一个仓库加速</span></span><br><span class="line">$ git <span class="built_in">clone</span> \</span><br><span class="line">  --depth=1 \</span><br><span class="line">  --reference-if-able=/Volumes/Data/Data/ws/knowledge \</span><br><span class="line">  git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>

<p>在 <code>Clone</code> 的过程中，通过一些参数可以有效的减少 <code>Clone</code> 的等待时间，如在 CI 的构建流程中，可以提高构建时间。</p>
<p>了解 <code>git clone</code> 命令的实际工作流程，能够了解 <code>clone</code> 的过程做了什么以及能做到什么，日常使用也用不到很多复杂的操作，关于更多的命令参数，可自行通过文档了解。</p>
<h2 id="仓库同步"><a href="#仓库同步" class="headerlink" title="仓库同步"></a>仓库同步</h2><p>因为 Git 是一个分布式的版本控制系统，同时存在多个仓库副本，仓库副本之间的同步是非常重要的一环。不同于许多分布式系统（例如分布式数据库）能够自动完成节点间的数据同步，Git 无法自动的完成仓库同步，所以仓库同步完全依赖于使用者自行通过各类操作界面完成。</p>
<p>数据同步的内容主要有：分支、标签、数据等内容</p>
<p>数据同步基于 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec">RefSpec</a> ，它描述了本地仓库与远程仓库间分支和标签的映射关系及同步策略。</p>
<p>下面示例中 <code>+refs/heads/*:refs/remotes/origin/*</code> 即为 <code>RefSpec</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p><code>Ref</code></p>
<p>示例中的 <code>RefSpec</code> 表明：远程仓库中所有分支 <code>refs/heads/*</code>，对应到本地仓库下所有分支 <code>refs/remotes/origin/*</code>，分支名称不变。如果需要改变分支名称，则需要配置针对分支特定的 <code>RefSpec</code>。</p>
<p>在了解 <code>RefSpec</code> 之前，需要先了解下 <code>Ref</code>：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-References">Git 内部原理 - Git References</a></p>
<p>如同描述的一样，<code>RefSpec</code> 描述了 <code>remote-refs</code> 和 <code>local-refs</code> 的对应关系。</p>
<p>RefSpec 写法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">+refs/heads/master:master</span><br><span class="line">+master:refs/remotes/origin/master</span><br><span class="line">master:master</span><br><span class="line">:master</span><br><span class="line">master:</span><br></pre></td></tr></table></figure>

<p><code>RefSpec</code> 的格式是一个可选的 <code>+</code> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code> 是远程仓库的引用格式，<code>&lt;dst&gt;</code> 是将要记录在本地仓库的引用格式。可选的 <code>+</code> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它，也就是与远程保持强一致的同步。</p>
<p>从远程仓库获取指定数据到本地仓库，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branch master &lt;==&gt; +refs/heads/master:+refs/remotes/origin/master</span><br><span class="line">branch    A:a &lt;==&gt; +refs/heads/A:+refs/remotes/origin/a</span><br><span class="line">tag     &lt;tag&gt; &lt;==&gt; +refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">$ tree .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">├── heads</span><br><span class="line">│   ├── feature</span><br><span class="line">│   │   └── travis-ci</span><br><span class="line">│   └── master</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       ├── feature</span><br><span class="line">│       │   └── travis-ci</span><br><span class="line">│       └── master</span><br><span class="line">└── tags</span><br><span class="line">    └── v0.0.0</span><br></pre></td></tr></table></figure>

<p>以上对应关系：</p>
<table>
<thead>
<tr>
<th>local-branch@local</th>
<th>remote-branch@local</th>
<th>remote-branch@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p>表格中，只描述了存在一个远程仓库 <code>origin</code> 的情形，实际上是可能存在多个远程仓库的。</p>
<p>注意：<code>RefSpec</code> 描述了 <code>remote-branch@local</code> 和 <code>remote-branch@remote</code> 之间的对应关系，并不是 <code>local-branch@local</code> 和 <code>remote-branch@remote</code> 之间的关系，它们之间的存在的追踪关系在其他配置项中描述。</p>
<p><code>local-branch@local</code> 下的 分支，是在本地存在的分支，可能从远程某个分支 <code>checkout</code>，也可能是本地新建的。</p>
<p><code>RefSpec</code> 可以应用在命令行中，但是一般不会出现在命令行中，而是由某些命令自动写在配置文件中，并在某些命令执行时自动应用配置。</p>
<p>例如：<code>git remote add remote-name</code>，Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/remote-name</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote add liuyanjie git@github.com:liuyanjie/knowledge.git</span><br><span class="line"></span><br><span class="line">$ cat .git/config</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">[remote <span class="string">&quot;liuyanjie&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/liuyanjie/*</span><br></pre></td></tr></table></figure>

<p>以下几种方式是等价的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master</span><br><span class="line">git <span class="built_in">log</span> heads/master</span><br><span class="line">git <span class="built_in">log</span> refs/heads/master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> origin/master</span><br><span class="line">git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>通常都是使用省略 <code>refs/heads/</code> 和 <code>refs/remotes/</code> 的形式。</p>
<p>以上示例中 <code>RefSpec</code> 中包含 <code>*</code> 会使 Git 拉取所有远程分支到本地，如果想让Git只拉取固定的分支，可以将 <code>*</code> 修改为指定的分支名。</p>
<p>也可以在命令行上指定多个 <code>RefSpec</code>，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure>

<p>同样，也可以将以上命令行中的 <code>RefSpec</code> 写入配置中：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">       <span class="attr">url</span> = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/develop:refs/remotes/origin/develop</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/feature/*:refs/remotes/origin/feature/*</span><br></pre></td></tr></table></figure>

<p>以上，<code>feature</code> 可以看做是命名空间，划分不同的分支类型。</p>
<p>上面描述都是拉取时 <code>RefSpec</code> 的作用，同样推送是也需要 <code>RefSpec</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p>推送一个空分支可以删除远程分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p><code>RefSpec</code> 描述了本地仓库分支和远程仓库分支的对应关系。很多时候可以省略，因为 Git 包含了很多默认行为。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 的分支大都是 其他 <code>本地仓库</code> 同步到远程的。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 <code>创建</code> 的新分支，在同步数据的时候默认会被拉到本地，<code>删除</code> 的分支默认不会在本地进行同步删除，<code>修改</code> 的分支会被更新，并与本地追踪的开发分支进行合并。</p>
<p>更多阅读：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec">Git 内部原理 - The Refspec</a></p>
<p>以上，通过 <code>RefSpec</code> 描述的 本地仓库 和 远程仓库 中 分支 是如何对应的，了解了 本地仓库 和 远程仓库 之间的对应关系。</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-remote">git remote</a></h3><blockquote>
<p>管理本地仓库对应的一组远程仓库，包括 查看、更新、添加、删除、重命名、设置 等一系列操作</p>
</blockquote>
<p>该命令的主要工作是在维护配置文件，也就是维护 <code>.git/config</code>，通常当不记得命令的时候，可以直接修改配置文件，因为配置文件格式很简单，很容易记忆。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br><span class="line"></span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote remove   &lt;name&gt;</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line"></span><br><span class="line">git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote set-branches  [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line"></span><br><span class="line">git remote get-url       [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote set-url       [--push] &lt;name&gt; &lt;new-url&gt; [&lt;old-url&gt;]</span><br><span class="line">git remote set-url --add [--push] &lt;name&gt; &lt;new-url&gt;</span><br><span class="line">git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git remote                                                  <span class="comment"># 列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                               <span class="comment"># 查看远程主机的地址</span></span><br><span class="line">git remote show   remote_name                               <span class="comment"># 查看该远程主机的详细信息</span></span><br><span class="line">git remote add    remote_name remote_url                    <span class="comment"># 添加远程主机</span></span><br><span class="line">git remote remove remote_name                               <span class="comment"># 删除远程主机</span></span><br><span class="line">git remote rename remote_name new_remote_name               <span class="comment"># 重命名远程主机</span></span><br><span class="line"></span><br><span class="line">git remote set-head remote_name branch_name --auto          <span class="comment"># 查询远程获得默认分支</span></span><br><span class="line">git remote set-head remote_name branch_name --delete        <span class="comment"># 删除默认分支</span></span><br><span class="line"></span><br><span class="line">git remote set-branches [--add] remote_name branch_name     <span class="comment"># 设置 RefSpec， [remote &quot;remote_name&quot;].fetch</span></span><br><span class="line"></span><br><span class="line">git remote get-url remote_name                              <span class="comment"># 查看远程主机地址 [remote &quot;remote_name&quot;].url</span></span><br><span class="line">git remote set-url remote_name git://new.url.here           <span class="comment"># 设置远程主机地址</span></span><br><span class="line">git remote set-url remote_name --push   git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote set-url remote_name --add    git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote set-url remote_name --delete git://new.url.here  <span class="comment"># 删除远程主机地址</span></span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;remote_name&gt;…​            <span class="comment"># 删除某个远程名下过期（即不存在）的分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see http://stackoverflow.com/questions/1856499/differences-between-git-remote-update-and-fetch</span></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  Push  URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    feature/travis-ci tracked</span><br><span class="line">    master            tracked</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    feature/travis-ci merges with remote feature/travis-ci</span><br><span class="line">    master            merges with remote master</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    feature/travis-ci pushes to feature/travis-ci (up to date)</span><br><span class="line">    master            pushes to master            (up to date)</span><br></pre></td></tr></table></figure>

<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch">git fetch</a></h3><blockquote>
<p>从另外一个仓库下载 <strong>Refs</strong>，以及完成他们的变更历史所需要的 <strong>Objects</strong>，追踪的远程分支将会被更新。</p>
</blockquote>
<p>从一个或多个其他存储库中获取分支，以及完成它们的历史记录所需的对象，追踪的远程分支将会被更新（具体策略取决于 <code>RefSpec</code>）。</p>
<p>默认情况下，还会获取指向要获取分支的历史记录上的标签，效果是获取指向您感兴趣的分支的标签。分支和标签统称为 <code>Refs</code>。也可以改变这种行为。</p>
<p><code>git fetch</code> 的主要工作就是和远程同步 <code>Refs</code>，而 <code>Refs</code> 可以 被 <code>创建、修改、删除</code>，所以 <code>fetch</code> 操作必然应该能够同步这些变化。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_remotes_a_id_remotes_a">REMOTES</a></li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_configured_remote_tracking_branches_a_id_crtb_a">CONFIGURED REMOTE-TRACKING BRANCHES</a></li>
</ul>
<p><code>.git/FETCH_HEAD</code>：是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/FETCH_HEAD                                </span><br><span class="line">25f8a1026c24d8dee71a7ffd43310588d01c246f                        branch <span class="string">&#x27;master&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">0d572bc6b622355f930688af4f44ae8f3416e12b        not-for-merge   branch <span class="string">&#x27;feature/travis-ci&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">58a6618947d44720494860fbb77a6a22c9a30ddb        not-for-merge   branch <span class="string">&#x27;feature/vpn&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">c761eb7a69dc54260b88c271b6271df559e7bce0        not-for-merge   branch <span class="string">&#x27;php-lang&#x27;</span> of github.com:liuyanjie/knowledge</span><br></pre></td></tr></table></figure>

<p>执行过 <code>fetch</code> 操作的项目都会存在一个 <code>FETCH_HEAD</code> 文件，其中每一行对应于远程服务器的一个分支。当前分支指向的 <code>FETCH_HEAD</code>，就是这个文件第一行对应的那个分支。</p>
<p>从本质上来说，唯一能从服务器下拉取数据的只有 <code>fetch</code>，其他命令的下拉数据的操作都是基于 <code>fetch</code> 的，所以 <code>fetch</code> 必然需要能够尽可能处理所有下拉数据时可能出现的情况。</p>
<p>Options:</p>
<ul>
<li><p>[shallow] 限制下拉指定的提交数：</p>
<ul>
<li><code>--depth=&lt;depth&gt;</code></li>
<li><code>--deepen=&lt;depth&gt;</code></li>
</ul>
</li>
<li><p>[shallow]限制下拉指定的提交时间：</p>
<ul>
<li><code>--shallow-since=&lt;date&gt;</code></li>
<li><code>--shallow-exclude=&lt;revision&gt;</code></li>
</ul>
</li>
<li><p>[deep]</p>
<ul>
<li><code>--unshallow</code>，<code>deep clone</code></li>
<li><code>--update-shallow</code></li>
</ul>
</li>
<li><p>[prune] 剪枝操作</p>
<p>远程仓库可能对已有的分支标签进行删除，而本地仓库并未删除，需要同步删除操作</p>
<ul>
<li><code>-p</code> <code>--prune</code></li>
<li><code>-p</code> <code>--prune-tags</code></li>
</ul>
</li>
<li><p>[tags] 默认情况下，<code>git fetch</code> 会下拉 <code>tag</code></p>
<ul>
<li><code>-t</code> <code>--tags</code> 【默认】下拉标签</li>
<li><code>-n</code> <code>--no-tags</code> 不下拉标签</li>
</ul>
</li>
<li><p>子模块</p>
<ul>
<li><code>--recurse-submodules-default=[yes|on-demand]</code></li>
<li><code>--recurse-submodules[=yes|on-demand|no]</code></li>
<li><code>--no-recurse-submodules</code></li>
<li><code>--submodule-prefix=&lt;path&gt;</code></li>
</ul>
</li>
</ul>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>local-branch@local</th>
<th>remote-branch@local</th>
<th>remote-branch@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p><code>git fetch</code> 将 <code>remote-branch@remote</code> fetch <code>remote-branch@local</code>，而 <code>RefSpec（+refs/heads/*:refs/remotes/origin/*）</code> 前面的 <code>+</code> 使 Git 在不能快速前进的情况下也强制更新，所以不会出现 <code>remote-branch@remote --merge--&gt; remote-branch@local</code> 的情况，实际上合并是不合理的行为，因为本地的 <code>refs/remotes/origin/*</code> 就是与远程保持同步的，如果合并了，就不同步了，更重要的是，远程分支可能修改了分支历史，如果合并，修改前的内容又合并进版本库了，有可能还需要解决冲突，而之后的 <code>remote-branch@local --merge--&gt; local-branch@local</code> 又会有可能合并。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git fetch                                         <span class="comment"># 获取 所有远程仓库 上的所有分支，将其记录到 .git/FETCH_HEAD 文件中</span></span><br><span class="line">git fetch -all                                    <span class="comment"># 获取 所有远程仓库 上的所有分支</span></span><br><span class="line">git fetch remote                                  <span class="comment"># 获取 remote 上的所有分支</span></span><br><span class="line">git fetch remote branch-name                      <span class="comment"># 获取 remote 上的分支：branch-name</span></span><br><span class="line">git fetch remote branch-name:local-branch-name    <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支</span></span><br><span class="line">git fetch remote branch-name:local-branch-name -f <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支，[强制]</span></span><br><span class="line">git fetch -f | --force                            <span class="comment"># 当使用 refspec(&lt;branch&gt;:&lt;branch&gt;) 时，跳过亲子关系检查，强制更新本地分支</span></span><br><span class="line">git fetch -p | --prune                            <span class="comment"># 获取所有远程分支并清除服务器上已删掉的分支</span></span><br><span class="line">git fetch -t | --tags                             <span class="comment"># 从远程获取数据时获取tags</span></span><br><span class="line">git fetch -n | --no-tags                          <span class="comment"># 从远程获取数据时去除tags</span></span><br><span class="line">git fetch --progress --verbose                    <span class="comment"># 显示进度及冗长日志</span></span><br><span class="line">git fetch --dry-run                               <span class="comment"># 显示做了什么，但是并不实际修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --depth=3 --no-tags --progress origin +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br><span class="line">git fetch --depth=3 --no-tags --progress git@github.com:liuyanjie/knowledge.git +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --prune --progress --verbose --dry-run</span><br><span class="line">From github.com:remote-name/branch-name</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/abcd</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/efg</span><br><span class="line">remote: Counting objects: 34, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 34 (delta 18), reused 24 (delta 16), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (34/34), <span class="keyword">done</span>.</span><br><span class="line">   f4e75b13a..6a338066c  master              -&gt; origin/master</span><br><span class="line"> + c29324269...641076244 develop             -&gt; origin/develop  (forced update)</span><br><span class="line"> = [up to date]          release/1.0.0       -&gt; origin/release/1.0.0</span><br><span class="line"> * [new branch]          release/1.1.0       -&gt; origin/release/1.1.0</span><br><span class="line"> * [new tag]             v1.1.0              -&gt; v1.1.0</span><br></pre></td></tr></table></figure>

<p><code>--prune</code> 只能清理 <code>.git/refs/remotes/remote-name</code> 目录下的远程追踪分支，而不会删除 <code>.git/refs/heads</code> 下的本地分支，即使这些分支已经合并，这些分支的清理需要特定的命令。</p>
<p>清理本地已合并的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> <span class="comment"># 查看确认</span></span><br><span class="line">git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | xargs git branch -d</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | xargs git branch -d</span><br><span class="line">Deleted branch feature/auto-tag-ci (was 98147f0e3).</span><br><span class="line">Deleted branch feature/build-optimize (was d359f4179).</span><br><span class="line">Deleted branch feature/contract (was c0c4bdaa8).</span><br><span class="line">Deleted branch feature/cross-domain (was 2e9b25c82).</span><br><span class="line">Deleted branch feature/deploy (was 3650db271).</span><br><span class="line">Deleted branch feature/nvmrc (was 1d174fcd8).</span><br><span class="line">Deleted branch feature/winston-logstash (was f13700c66).</span><br></pre></td></tr></table></figure>

<p>清理远程已合并的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> <span class="comment"># 查看确认</span></span><br><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> | xargs -n 1 git push origin</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> | xargs -n 1 git push origin</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line"> - [deleted]             feature/xxxx</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br><span class="line">From git@github.com:schacon/simple</span><br><span class="line"> ! [rejected]        master     -&gt; origin/master  (non fast forward)</span><br><span class="line"> * [new branch]      topic      -&gt; origin/topic</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中， <code>master</code> 分支因为不是一个可以 <code>快速演进</code> 的引用而拉取操作被拒绝。你可以在 <code>RefSpec</code> 之前使用一个 <code>+</code> 号来重载这种行为。</p>
<p>输出格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; [&lt;reason&gt;]</span><br></pre></td></tr></table></figure>

<p>输出格式详细介绍见：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_output">OUTPUT</a></p>
<p><code>fetch</code> 负责将 远程仓库 更新到 远程仓库在本地的对应部分，其他工作又其他 命令 负责。</p>
<p>在实际使用中，大多数时候都是使用 <code>pull</code> 间接的使用 <code>fetch</code>。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-pull">git pull</a></h3><blockquote>
<p>将来自远程存储库的更改合并到当前分支中</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master  <span class="comment"># 获取远程分支 master 并 merge 到当前分支</span></span><br></pre></td></tr></table></figure>

<p>默认模式下，<code>git pull</code> 等价于以下两步:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>特例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout master</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>

<p>更确切的说，<code>git pull</code> 已指定的参数运行 <code>git fetch</code>，然后 调用 <code>git merge</code> 合并 检索到的分支头到当前分支，通过 <code>--rebase</code> 参数，<code>git merge</code> 也可以被替换成 <code>git rebase</code>。</p>
<p>假定有如下的历史，并且当前分支是 <code>master</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>调用 <code>git pull</code> 时，首先需要 <code>fetch</code> 变更从远处分支，下拉之后的仓库状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master in your repository</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<p>因为 远程分支 master (C) 已经和 本地分支 master (G) 已经处于分离状态，此时，<code>git merge</code> 合并 <code>origin/master</code> 到 <code>master</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H ← master</span><br></pre></td></tr></table></figure>

<p>以上过程发生了一次 <code>远程</code> 合并到 <code>本地</code> 的情形，git 会自动生成类似下面的 <code>commit message</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;master&#x27; of github.com:liuyanjie/knowledge into master</span><br></pre></td></tr></table></figure>

<p>出现 <code>远程</code> 合并到 <code>本地</code> 的情形 在 Git 中是一种不良好的实践，应该极力避免甚至是禁止出现，这种情形在多个人同时在同一个分支上开发的时候非常容易出现。</p>
<p>记住一点：一般来书，<code>分支</code>是要合并到远程服务器上的分支，而不是远程服务分支合并到本地分支的。</p>
<p>在实际开发过程中，所有的合并操作都应该发生在远程服务器上，保持所有的分支有清晰的历史。同样，也应该避免不必要的合并，甚至是禁止合并。</p>
<blockquote>
<p>一般情况下，创建了分支必然需要通过合并来将分支上的内容整合到分支的基上，但是也有不合并的其他方法</p>
</blockquote>
<p>合并产生的 <code>Commit</code> 并未给版本库带来新的改变，但是却使版本历史不够清晰了。</p>
<p>合并使分支历史从单向链表变成了有向图，一堆线杂乱无章交错，分支历史难以理解。</p>
<p>合并产生的 <code>Commit</code> 有两个或多个父 <code>Commit</code>， <code>Reset</code> 难以进行。</p>
<p>如何避免 本地合并？</p>
<ol>
<li>在 <code>commit</code> 之前先 <code>pull</code>，避免分叉。</li>
<li>在 <code>commit</code> 之后立即 <code>push</code>，使其他人的本地仓库能及时获取到最新的 <code>commit</code>。</li>
</ol>
<p>知道一定会 发生本地 合并时如何处理？</p>
<ol>
<li><code>git pull --ff-only</code> or <code>git fetch</code></li>
<li><code>git rebase origin/master</code></li>
</ol>
<p>已经出现 本地合并 如何解决？</p>
<ol>
<li><code>git reset C</code> 重置当前分支到 <code>C</code>，<code>F</code> <code>G</code> 会重新回到暂存区。</li>
<li><code>git commit -am &quot;commit message&quot;</code> 重新提交。</li>
<li><code>git push</code></li>
</ol>
<p>解决之后的分支图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">              origin/master</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C---F---G ← master</span><br><span class="line">     /</span><br><span class="line">D---E</span><br></pre></td></tr></table></figure>

<p>假设版本库当前的状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>以上版本库库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← master</span><br><span class="line">     /        ↑</span><br><span class="line">D---E         origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>以上版本库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>快速前进不产生新的 <code>Commit</code>，效果上只移动分支头即可，默认情况下进行就是快速前进</p>
<p>在能够进行快速前进的情况下，也可以强制进行合并，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E-----------H ← master</span><br></pre></td></tr></table></figure>

<p>所以 <code>git pull</code> 的参数主要由 <code>git fetch</code> 和 <code>git merge</code> 的参数组成。</p>
<p><code>git pull</code> 的运行过程：</p>
<ol>
<li>首先，基于本地的 <code>FETCH_HEAD</code> 记录，比对本地的 <code>FETCH_HEAD</code> 记录与远程仓库的版本号</li>
<li>然后通过 <code>git fetch</code> 获得当前指向的远程分支的后续版本的数据</li>
<li>最后通过 <code>git merge</code> 将其与本地的当前分支合并</li>
</ol>
<p>若有多个 remote，git pull remote_name 所做的事情是：</p>
<ul>
<li>获取 <code>[remote_name]</code> 下的所有分支</li>
<li>寻找本地分支有没有 <code>tracking</code> 这些分支的，若有则 <code>merge</code> 这些分支，若没有则 <code>merge</code> 当前分支</li>
</ul>
<p>另外，若只有一个 remote，假设叫 origin，那么 git pull 等价于 git pull origin；平时养成好习惯，没谱的时候都把【来源】带上。</p>
<p>怎么知道 <code>tracking</code> 了没有？</p>
<ul>
<li>如果你曾经这么推过：<code>git push -u origin master</code>，那么你执行这条命令时所在的分支就已经 <code>tracking to origin/master</code> 了</li>
<li>如果你记不清了：<code>cat .git/config</code>，由此可见，<code>tracking</code> 的本质就是指明 <code>pull</code> 的 <code>merge</code> 动作来源</li>
</ul>
<p>总结:</p>
<ul>
<li><code>git pull = git fetch + git merge</code></li>
<li><code>git fetch</code> 拿到了远程所有分支的更新，<code>cat .git/FETCH_HEAD</code> 可以看到其状态，若是 <code>not-for-merge</code> 则不会有接下来的 <code>merge</code> 动作</li>
<li><code>merge</code> 动作的默认目标是当前分支，若要切换目标，可以直接切换分支</li>
<li><code>merge</code> 动作的来源则取决于你是否有 <code>tracking</code>，若有则读取配置自动完成，若无则请指明【来源】</li>
</ul>
<p><code>pull</code> 时还可能存在远程分支不存在的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">test</span></span><br><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">$ git branch --set-upstream-to=origin/<span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line">error: the requested upstream branch <span class="string">&#x27;origin/test&#x27;</span> does not exist</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning on basing your work on an upstream</span><br><span class="line">hint: branch that already exists at the remote, you may need to</span><br><span class="line">hint: run <span class="string">&quot;git fetch&quot;</span> to retrieve it.</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning to push out a new <span class="built_in">local</span> branch that</span><br><span class="line">hint: will track its remote counterpart, you may want to use</span><br><span class="line">hint: <span class="string">&quot;git push -u&quot;</span> to <span class="built_in">set</span> the upstream config as you push.</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 81, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 81 (delta 42), reused 81 (delta 42), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (81/81), <span class="keyword">done</span>.</span><br><span class="line">From github.com:liuyanjie/knowledge</span><br><span class="line">   2f977e2..be00fff  feature/x -&gt; origin/feature/x</span><br><span class="line">Your configuration specifies to merge with the ref <span class="string">&#x27;refs/heads/feature/abc&#x27;</span></span><br><span class="line">from the remote, but no such ref was fetched.</span><br></pre></td></tr></table></figure>

<p>需要提及的一点是：</p>
<p><code>pull</code> 操作，不应该涉及 <code>合并</code> 或 <code>变基</code> 操作，即 <code>pull</code> 应该总是 快速前进 的。</p>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>head@local</th>
<th>remote@local</th>
<th>remote@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p><code>git pull</code> 在 <code>git fetch</code> 的基础之上增加了 <code>git merge</code>，将 <code>远程分支对应的本地分支</code> 合并到 <code>追踪的本地开发分支</code></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-push">git push</a></h3><blockquote>
<p>使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p>
</blockquote>
<p><code>git push</code> 是与 <code>git pull</code> 相对应的推送操作，同样需要能够推送本地的多种情形的变更到远程仓库。git 向远程仓库推送的操作只有 <code>push</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">     [--all | --mirror | --tags]</span><br><span class="line">     [--follow-tags]</span><br><span class="line">     [--atomic]</span><br><span class="line">     [-n | --dry-run]</span><br><span class="line">     [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">     [--repo=&lt;repository&gt;]</span><br><span class="line">     [-f | --force]</span><br><span class="line">     [-d | --delete]</span><br><span class="line">     [--prune]</span><br><span class="line">     [-v | --verbose]</span><br><span class="line">     [-u | --set-upstream]</span><br><span class="line">     [--push-option=&lt;string&gt;]</span><br><span class="line">     [--[no-]signed|--sign=(<span class="literal">true</span>|<span class="literal">false</span>|if-asked)]</span><br><span class="line">     [--force-with-lease[=&lt;ref-name&gt;[:&lt;expect&gt;]]]</span><br><span class="line">     [--no-verify]</span><br><span class="line">     [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git push                                 <span class="comment"># 如果当前分支只有一个追踪分支，那么主机名都可以省略</span></span><br><span class="line">git push origin HEAD                     <span class="comment"># 将 当前 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master                   <span class="comment"># 将 master 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master -u                <span class="comment"># 将 master 分支 推送 到远程 master 分支，并建立追踪关系</span></span><br><span class="line">git push origin master --set-upstream    <span class="comment"># 同上</span></span><br><span class="line">git push origin --all                    <span class="comment"># 将所有本地分支都推送到origin主机</span></span><br><span class="line">git push origin --force                  <span class="comment"># 强制推送更新远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin :hotfix/xxxx              <span class="comment"># 删除远程仓库的 hotfix/xxxx 分支</span></span><br><span class="line">git push origin :master                  <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line">git push origin --delete master          <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line"></span><br><span class="line">git push origin --prune                  <span class="comment"># 删除在本地没有对应分支的远程分支</span></span><br><span class="line"></span><br><span class="line">git push --tags                          <span class="comment"># 把所有tag推送到远程仓库</span></span><br></pre></td></tr></table></figure>

<p>推送模式：</p>
<ul>
<li>simple  模式: 不带任何参数的git push，默认只推送当前分支。2.0以上版本，默认此方式。</li>
<li>matching模式: 会推送所有有对应的远程分支的本地分支。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 1.25 KiB | 1.25 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 2 <span class="built_in">local</span> objects.</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line">   d26f671..e081fb3  master -&gt; master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete ref...</span><br></pre></td></tr></table></figure>

<p>推送代码到服务器与拉取代码到本地其实是相同的，所以服务代码推送到服务全之后，同样有可能出现需要合并的情况，如推送者本地仓库在没有 <code>pull</code> 后进行 <code>commit</code> 后 <code>push</code>，导致本地代码和远程服务器代码分叉，此时服务端也要面临合并问题，合并就有可能产生冲突，但是服务端没有解决冲突的能力，所以实质上服务端是禁止发生合并的，只能进行快速前进。当不能快速前进，服务端会返回错误给客户端，错误会提示先 <code>pull</code> 再 <code>push</code>。此时，<code>pull</code> 操作是一定会进行 <code>merge</code> 的，可能需要处理 <code>merge</code>，此时就需要处理前面提到的处理本地合并的问题了。</p>
<h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-submodule">git submodule</a></h3><blockquote>
<p>初始化、更新或检查子模块</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/docs/gitsubmodules">gitsubmodules</a>  - mounting one repository inside another</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--] &lt;repository&gt; [&lt;path&gt;]</span><br><span class="line">git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] init [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…​)</span><br><span class="line">git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch]</span><br><span class="line">        [--[no-]recommend-shallow] [-f|--force] [--rebase|--merge]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--recursive]</span><br><span class="line">        [--<span class="built_in">jobs</span> &lt;n&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] summary [--cached|--files] [(-n|--summary-limit) &lt;n&gt;]</span><br><span class="line">        [commit] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] foreach [--recursive] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…​]</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -b master --name knowledge --reference=/Volumes/Data/Data/ws/knowledge -- git@github.com:liuyanjie/knowledge.git ./third_parts/knowledge</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   third_parts</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">[master 83506db] ...</span><br><span class="line"> 2 files changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 third_parts</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 7, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 5.31 KiB | 5.31 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">To github.com:liuyanjie/about.git</span><br><span class="line">   53abb09..83506db  master -&gt; master</span><br></pre></td></tr></table></figure>


<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git 是一个分布式的结构，有本地版本库和远程版本库，便有了本地分支和远程分支的区别了。</p>
<p>本地分支和远程分支在 <code>git push</code> 的时候可以随意指定，交错对应，只要不出现版本从图即可。</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git-branch"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-branch">git-branch</a></h3><blockquote>
<p>创建、修改、删除、查看、重命名、复制分支</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch (-t | --[no-]track) (-l | --[no-]create-reflog) [-f | --force] &lt;branch-name&gt; [&lt;start-point&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置/修改上游分支</span></span><br><span class="line">git branch [-u | --set-upstream-to=] &lt;upstream&gt; [&lt;branch-name&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch -a --all</span><br><span class="line">git branch -r</span><br><span class="line">git branch --list &lt;pattern&gt;...</span><br><span class="line">git branch --list --[no-]contains [&lt;commit&gt;]</span><br><span class="line">git branch --list --[no-]merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置分支</span></span><br><span class="line">git branch (-f --force) &lt;branch-name&gt; &lt;start-point&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名分支</span></span><br><span class="line">git branch (-m --move | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-m --move) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -M [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制分支</span></span><br><span class="line">git branch (-c --copy) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-c --copy) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -C [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="comment"># -r 可以同时删除远程追踪分支，但是只有在远程分支删除的情况下才有意义，否则会fetch回来</span></span><br><span class="line">git branch (-d --delete) [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch (-d --delete)  --force [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch -D [-r] &lt;branchname&gt;…​</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑分支描述</span></span><br><span class="line">git branch --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>

<p><code>git branch</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>。</p>
<p><code>remotes/origin/*</code> 下的分支删除：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;branch-name&gt;</span><br><span class="line">git push :&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>以上命令在删除远程仓库的分支的同时，同步删除 <code>remotes/origin/*</code> 下的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;remote-name&gt;/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>以上命令删除 <code>remotes/origin/*</code> 下的分支，但是远程分支并未删除，在 <code>git fetch</code> 后还会拉下来，所以这种删除无意义。</p>
<p>分支类型：</p>
<ul>
<li>远程分支（remote-branch），远程服务器上的分支，<code>refs/heads/*</code>@remote，是<code>远程追踪分支</code>的<code>上游分支</code>。</li>
<li>远程追踪分支（remote-tracking branch），远程服务器对应在本地的分支，与<code>远程分支</code>存在<code>追踪</code>关系，可能是<code>本地分支</code>的<code>上游分支</code>。</li>
<li>本地分支（local branch），<code>refs/heads/*</code>@local，可能与<code>远程追踪分支</code>存在<code>追踪</code>关系。</li>
</ul>
<p>分支关系：</p>
<ul>
<li>追踪分支（tracking branch），能够主动追踪其他分支，自动跟随其他分支变化更新的分支。</li>
<li>上游分支（upstream branch），被追踪的分支。</li>
</ul>
<blockquote>
<p>Checking out a <code>local branch</code> from a <code>remote-tracking branch</code> automatically creates what is called a <code>“tracking branch”</code> (and the branch it tracks is called an <code>“upstream branch”</code>).</p>
</blockquote>
<p>只有把概念定义清楚，才能够进行准确的描述，要不然都可能带来理解上的偏差。</p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git-tag"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-tag">git-tag</a></h3><blockquote>
<p>创建、删除、查看、校验标签</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e] &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br><span class="line">git tag -d &lt;tagname&gt;…​</span><br><span class="line">git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;]</span><br><span class="line">  [--points-at &lt;object&gt;] [--column[=&lt;options&gt;] | --no-column]</span><br><span class="line">  [--create-reflog] [--sort=&lt;key&gt;] [--format=&lt;format&gt;]</span><br><span class="line">  [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…​]</span><br><span class="line">git tag -v [--format=&lt;format&gt;] &lt;tagname&gt;…​</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l --list <span class="string">&quot;v*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;tagging version 1.0.0&quot;</span></span><br><span class="line">git tag -a --force v1.0.0 -m <span class="string">&quot;tagging version 1.0.0&quot;</span></span><br><span class="line">git tag -a v1.0.0 --file=&lt;file&gt;</span><br><span class="line">git tag -a v1.0.0 &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>

<p>与分支不同，<code>git push</code> 默认不推送标签到远程，所以需要主动推送标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<p>同样，<code>git tag</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>，通常也不会直接操作远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;tag-name&gt;</span><br><span class="line">git push --delete v1.0.0</span><br></pre></td></tr></table></figure>

<p>清理 远程不能存在本地存在 的标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l | xargs git tag -d ; git fetch --tags</span><br></pre></td></tr></table></figure>

<p>标签并不像分支那样，存在远程标签/本地标签等区分，所以也不存在本地标签与远程标签之间的对应关系，自然也就不需要维护对应关系。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git-checkout"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout">git-checkout</a></h3><ul>
<li>切换分支并检出内容到工作区，也可创建分支</li>
</ul>
<p>检出已存在的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout    &lt;branch&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>创建并检出分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start-point&gt;]</span><br></pre></td></tr></table></figure>

<p>检出<code>tree-ish</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br></pre></td></tr></table></figure>

<p>检出内容到本地的时候会发生什么？</p>
<ol>
<li>本地是干净的，无任何修改</li>
<li>本地存在新增加的文件</li>
<li>本地存在修改后未提交的文件</li>
</ol>
<p>Ref：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout#_detached_head">DETACHED HEAD</a></p>
<p>HEAD 通常指向某一个分支，这一分支即是当前工作的分支。当 HEAD 不再指向分支的时候，仓库即处于 <code>DETACHED HEAD</code> 状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout ccdd28a</span><br><span class="line">Note: checking out <span class="string">&#x27;ccdd28a&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by using -b with the checkout <span class="built_in">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at ccdd28a git update</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">HEAD detached at ccdd28a</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>处于这种状态下的仓库，如果进行修改并且提交，就会很危险，因为没有任何分支指向新的提交，当 <code>HEAD</code> 切换到其他位置的时候，当前的修改就不容易找不到了。</p>
<p>如果需要基于此节点进行修改，需要先基于此节点创建分支。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git-merge"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-merge">git-merge</a></h3><blockquote>
<p>将两个或多个分支历史合并在一起</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br><span class="line">  [-q --quiet]</span><br><span class="line">  [-v --verbose]</span><br><span class="line">  [--[no-]progress]</span><br><span class="line">  [--commit] [--no-commit]</span><br><span class="line">  [-e | --edit] [--no-edit]</span><br><span class="line">  [-ff] [--no-ff] [--ff-only]</span><br><span class="line">  [--<span class="built_in">log</span>[=&lt;n&gt;]] [--no-log]</span><br><span class="line">  [-n] [--<span class="built_in">stat</span>] [--no-stat]</span><br><span class="line">  [--[no-]squash]</span><br><span class="line">  [--[no-]signoff]</span><br><span class="line">  [-s &lt;strategy&gt;] [--strategy=&lt;strategy&gt;]</span><br><span class="line">  [-X &lt;strategy-option&gt;] [--strategy-option=&lt;option&gt;]</span><br><span class="line">  [-S[&lt;keyid&gt;]] --gpg-sign[=&lt;keyid&gt;]</span><br><span class="line">  [--[no-]verify-signatures]</span><br><span class="line">  [--[no-]summary]</span><br><span class="line">  [--[no-]allow-unrelated-histories]</span><br><span class="line">  [--[no-]rerere-autoupdate]</span><br><span class="line">  [-m &lt;msg&gt;]</span><br><span class="line">  [&lt;commit&gt;…​]</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/11646107/you-have-not-concluded-your-merge-merge-head-exists</span><br><span class="line"></span><br><span class="line"><span class="comment"># git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present.</span></span><br><span class="line"><span class="comment"># 中断 merge，当发生冲突时，可以通过中断合并回到合并前的状态</span></span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续 merge，当发生冲突时，需要解决冲突，解决冲突后，继续执行合并</span></span><br><span class="line">git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>有如下版本库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge topic</span><br></pre></td></tr></table></figure>

<p>合并后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>squash mode</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash topic</span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G---(ABC) master</span><br></pre></td></tr></table></figure>

<p><code>--squash</code> 效果相当于将 topic 分支上的多个 commit A-B-C 合并成一个 ABC，放在当前分支上，原来的 commit 历史则没有拿过来。</p>
<p>判断是否使用 <code>--squash</code> 选项最根本的标准是，待合并分支上的历史是否有意义。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p>
<p>只有在开发分支上每个 commit 都有其独自存在的意义，并且能够编译通过的情况下，才应该选择缺省的合并方式来保留 commit 历史。</p>
<p>fast forward mode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --ff topic</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic master</span><br><span class="line">             /</span><br><span class="line">D---E---F---G</span><br></pre></td></tr></table></figure>

<p>合并的前提是：准备合并的两个 <code>commit</code> 不在一条直线上，在一条直线上可以进行快速前进，也可以使用 <code>--no-ff</code> 强制合并（无意义）。</p>
<p>合并的过程中需要处理可能得冲突，未冲突的文件将会进行自动合并，在新版本的<code>tree</code>中产生一个新版本的<code>blob</code>，所以Git能够完整检出不需要依赖历史中的<code>commit</code>，只需要当前的<code>commit</code>。</p>
<p>合并的结果是：产生一个新的 <code>commit</code>，实际上，<code>squash mode</code> <code>fast forward mode</code> 并不是真正意义上的合并。</p>
<p>冲突：</p>
<p>冲突有两种类型，一种是树冲突，修改/删除同一文件，另一种是文件冲突，修改了同一文件中的相同内容。</p>
<p>冲突是如何判断的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>假如有文件 <code>README.md</code> 在 <code>E</code>，且 <code>topic</code> 和 <code>master</code> 都有修改此文件，合并 <code>topic</code> 到 <code>master</code> 时，冲突检查的依据不是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 是否相同，而是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 相对于 <code>E</code> 的变化。即使是 <code>README.md</code> 文件在被修改后的内容是相同的，也会产生冲突。而冲突产生的文件，就是将 相对于 <code>E</code>，都合并到同一个文件中，并交由用户解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">=======</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt</span><br></pre></td></tr></table></figure>

<p>最佳实践：</p>
<ol>
<li>尽量避免在本地使用 <code>merge</code>，也尽量避免在本地发生 <code>Merge</code>。</li>
<li><code>merge</code> 时，本地不要有未提交的更改，这些修改可能会在中断合并时丢失。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><blockquote>
<p>添加文件到索引中，为下一次提交准备内容。</p>
</blockquote>
<p>将工作区的修改添加到暂存区中，此命令使用在工作树中找到的最新内容更新索引，以准备为下次提交暂存内容。</p>
<p>典型的情况下，将整个文件添加到暂存区中，通过特定的选项，也可以将工作区修改的部分内容加到暂存区中。</p>
<p>暂存区保存工作树内容的快照，并将此快照作为下一次提交的内容。因此，在对工作树进行任何更改之后，在运行commit命令之前，必须使用add命令将任何新的或修改的文件添加到索引中。</p>
<p>默认情况下，<code>git add</code> 不会添加忽略的文件，<code>git add -f</code> 会进行强制添加。</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><blockquote>
<p>从工作区和暂存区移除文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…​</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm *.txt</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm *.txt</span><br><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>

<p>仅从暂存区删除内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached *.txt</span><br></pre></td></tr></table></figure>

<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><blockquote>
<p>重命名或移动文件，同步更新暂存区</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv &lt;options&gt;…​ &lt;args&gt;…​</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; &lt;destination&gt;</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; ... &lt;destination directory&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name new_name            <span class="comment"># 重命名</span></span><br><span class="line">git mv -f old_name new_name         <span class="comment"># 强制重命名，即时目标名称已经存在</span></span><br><span class="line">git mv -k old_name new_name         <span class="comment"># 跳过会导致错误的动作</span></span><br><span class="line">git mv -v old_name new_name         <span class="comment"># 报告被移动文件</span></span><br><span class="line">git mv --dry-run old_name new_name  <span class="comment"># 只显示将会发生什么</span></span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><blockquote>
<p>Show changes between commits, commit and working tree, etc</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment"># 查看尚未暂存的文件更新了哪些部分，不加参数直接输入。</span></span><br><span class="line">git diff --cached       <span class="comment"># 查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异</span></span><br><span class="line">git diff --staged       <span class="comment"># 显示的是下一次 commit 时会提交到HEAD的内容(不带-a情况下)</span></span><br><span class="line">git diff HEAD           <span class="comment"># 显示工作版本(Working tree)和HEAD的差别</span></span><br><span class="line">git diff topic master   <span class="comment"># 直接将两个分支上最新的提交做diff</span></span><br><span class="line">git diff topic...master <span class="comment"># 输出自 topic 和 master 分别开发以来，master 分支上的 changed。</span></span><br><span class="line">git diff --<span class="built_in">stat</span>         <span class="comment"># 查看简单的diff结果，可以加上--stat参数</span></span><br><span class="line">git diff <span class="built_in">test</span>           <span class="comment"># 查看当前目录和另外一个分支的差别 显示当前目录和另一个叫 test 分支的差别</span></span><br><span class="line">git diff HEAD -- ./lib  <span class="comment"># 显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下）</span></span><br><span class="line">git diff HEAD^ HEAD     <span class="comment"># 比较上次提交commit和上上次提交</span></span><br><span class="line">git diff SHA1 SHA2      <span class="comment"># 比较两个历史版本之间的差异</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diff_utility">Diff_utility</a></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><blockquote>
<p>Record changes to the repository</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit                          <span class="comment"># 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</span></span><br><span class="line">git commit -a                       <span class="comment"># 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。</span></span><br><span class="line">git commit -a -m <span class="string">&#x27;commit info&#x27;</span>      <span class="comment"># 注释，如果没有 -m，会默认会使用vi编辑注释。</span></span><br><span class="line">git commit -am <span class="string">&quot;This is a commit&quot;</span>   <span class="comment"># 同上，合并提交，将 add 和 commit 合为一步</span></span><br><span class="line">git commit --amend                  <span class="comment"># 对上一次提交进行修改，合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit --amend -a               <span class="comment"># 提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交</span></span><br><span class="line">git commit --author=&lt;author&gt;        <span class="comment"># 设置作者，与提交者分开</span></span><br><span class="line">git commit --file=&lt;file&gt;            <span class="comment"># 注释从文件中读取</span></span><br></pre></td></tr></table></figure>

<p>对于 commit 来说，最重要的是，每一次 commit 都应该是一个完整的提交，而且应该有个规范清晰的注释。</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><blockquote>
<p>显示工作树状态</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status     <span class="comment"># 显示状态</span></span><br><span class="line">git status -s  <span class="comment"># 显示简短信息</span></span><br><span class="line">git status -b  <span class="comment"># 显示分支状态</span></span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><blockquote>
<p>重置工作区，将当前分支回退到某一节点</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>

<p><code>git reset</code> 会修改当前分支头从某一个 <code>&lt;commit-id&gt;</code> 移动到另外的一个指定的 <code>&lt;commit-id&gt;</code></p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              HEAD</span><br><span class="line">              ↓</span><br><span class="line">              topic</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>当前活跃的分支是 <code>topic</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset A</span><br></pre></td></tr></table></figure>

<p>执行以上操作后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      HEAD</span><br><span class="line">      ↓</span><br><span class="line">      topic</span><br><span class="line">      ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>此时，<code>HEAD -&gt; topic -&gt; A</code>，B、C 此时处于悬挂状态，如同普通的对象一样，没有任何引用后，会被 Git GC 回收。</p>
<p>执行此操作后，B、C 两点虽然依然存在于仓库中，但是它们已经逻辑上脱离了Git。</p>
<p>此时，B、C 两点提交的内容怎么办？是不是就丢失了呢？</p>
<p>Git 给了我们多种选择：</p>
<ul>
<li>–soft，B、C 提交的内容不会回到工作区和暂存区。因为当前工作区内容是基于 C 修改的，所以实际上并无内容丢失。</li>
<li>–mixed，B、C 提交的内容回到暂存区，但是工作区内容不变，也就是某些文件处于 <code>修改未提交状态</code>。同上，也无内容丢失。</li>
<li>–hard，B、C 提交的内容不会回到工作区和暂存区，同时暂存区和工作区回到A点状态，B、C 提交的内容以及工作区后续的修改全部丢失。</li>
</ul>
<p>如果 <code>reset</code> 误操作操作怎么办？</p>
<ol>
<li><p>如果存在上游分支，可以通过上游分支恢复</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset master^2</span><br><span class="line">git reset origin/master</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过 <code>reflog</code> 恢复</p>
<p> <code>reflog</code> 记录 HEAD 的变化，所以可以通过 <code>reflog</code> 找到 <code>reset</code> 之前的 <code>HEAD</code> 的位置，但是前提是后续节点未被垃圾回收。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">58c1d5d (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: update git</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;1&#125;: checkout: moving from <span class="built_in">test</span> to master</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;2&#125;: checkout: moving from master to <span class="built_in">test</span></span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;3&#125;: commit: git update</span><br><span class="line">e081fb3 HEAD@&#123;4&#125;: commit: update python</span><br><span class="line">d26f671 HEAD@&#123;5&#125;: commit: update</span><br><span class="line">33db13f HEAD@&#123;6&#125;: commit (amend): update and format</span><br><span class="line">5c41033 HEAD@&#123;7&#125;: commit: update and format</span><br><span class="line">e56ec4e HEAD@&#123;8&#125;: commit: 移除乱码字符</span><br><span class="line">6595b95 HEAD@&#123;9&#125;: commit: feat(): add hexo.yaml</span><br></pre></td></tr></table></figure></li>
</ol>
<p>未提交的内容是很难就行恢复的，所有在进行 <code>reset</code> 操作时，要将工作区的内容提交。</p>
<p>reset 除了将工作区回退到某个节点之外，常用的应用就是将后续的多个提交合并为一个提交，因为后续提交的内容可以回到暂存区或工作区中。</p>
<p>在某些Git工作流中，要求将多个提交合并成一个之后才能合并到上游分支。</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git revert --<span class="built_in">continue</span></span><br><span class="line">git revert --quit</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~3</span><br><span class="line">git revert -n master~5..master~2</span><br></pre></td></tr></table></figure>

<p><code>git revert</code> 用于撤销一个或多个提交，并建立一个新的提交。<code>commit</code> 中所做的修改都会被移除掉，相当于 <code>commit</code> 反向操作。</p>
<p><code>git revert</code> 通常用户快速回滚。</p>
<p>示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            HEAD</span><br><span class="line">            ↓</span><br><span class="line">            master</span><br><span class="line">            ↓</span><br><span class="line">A---B---C---D</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert C</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                HEAD</span><br><span class="line">                ↓</span><br><span class="line">                master</span><br><span class="line">                ↓</span><br><span class="line">A---B---C---D---C<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>C&#39;</code> 是一个全新的 <code>Commit</code> 与 <code>C</code> 是不同的，但是这种情况下，<code>C&#39;</code> 与 <code>C</code> 中的 <code>tree</code> 是相同的。</p>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><blockquote>
<p>变基操作，基指的是起始提交，即参数中常见的 <start-point></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;]</span><br><span class="line">git rebase --<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突之后继续 rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过</span></span><br><span class="line">git rebase --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断 rebase</span></span><br><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C ← topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A&#x27;--B&#x27;--C&#x27; ← topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<p>以上，通过变基操作，将topic分支的 <start-point> 从 <code>E</code> 调整到了 <code>G</code>。</p>
<p>变基操作的原理：将 A B C 基于 G 重新提交，提交的过程可能与 F G 存在冲突，需要解决冲突。</p>
<p>变基操作的应用：</p>
<ol>
<li>保持与上游分支同步，同步上游分支的最新版本</li>
<li>合并时存在冲突，通过变基操作解决冲突</li>
</ol>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/vcs/git/git-working-mechanism.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/vcs/git/git-working-mechanism.md">编辑源文件</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>liuyanjie
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.butonly.com/posts/vcs/git/git-working-mechanism/" title="Git命令工作机制">https://blog.butonly.com/posts/vcs/git/git-working-mechanism/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/vcs/" rel="tag"># vcs</a>
              <a href="/tags/git/" rel="tag"># git</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/vcs/git/git-object-model/" rel="prev" title="Git对象模型：一步一步分析Git底层对象模型">
                  <i class="fa fa-chevron-left"></i> Git对象模型：一步一步分析Git底层对象模型
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  <script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuyanjie</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">146k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.9.1/dist/algoliasearch-lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.21.0/dist/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>



  <script class="next-config" data-name="pdf" type="application/json">{&quot;object_url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;pdfobject@2.2.5&#x2F;pdfobject.min.js&quot;,&quot;url&quot;:&quot;&#x2F;lib&#x2F;pdf&#x2F;web&#x2F;viewer.html&quot;}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{&quot;enable&quot;:true,&quot;theme&quot;:&quot;forest&quot;,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mermaid@8.9.3&#x2F;dist&#x2F;mermaid.min.js&quot;}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;liuyanjie&quot;,&quot;count&quot;:true,&quot;lazyload&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
