
 <!DOCTYPE HTML>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>Git深入理解-命令工作机制 | lyj&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="lyj">
    

    
    <meta name="description" content="仓库创建Git是一个分布式的版本控制系统，这意味着在Git中版本库有 本地版本库 和 远程版本库 之分。 每个远程仓库可以有多个本地仓库，同时一个本地版本库可以同时对应多个远程版本库，多个远程版本库是从一个最原始的版本库 Fork（实际上也是clone）产生的，Fork 出来的版本库和本地 Clone 的仓库是类似的，他们有一个相同的 上游仓库（即原始仓库），这些版本库直接可以通过 PullReq">
<meta name="keywords" content="GIT,Git命令">
<meta property="og:type" content="article">
<meta property="og:title" content="Git深入理解-命令工作机制">
<meta property="og:url" content="/posts/Git深入理解-命令工作机制/index.html">
<meta property="og:site_name" content="lyj&#39;s blog">
<meta property="og:description" content="仓库创建Git是一个分布式的版本控制系统，这意味着在Git中版本库有 本地版本库 和 远程版本库 之分。 每个远程仓库可以有多个本地仓库，同时一个本地版本库可以同时对应多个远程版本库，多个远程版本库是从一个最原始的版本库 Fork（实际上也是clone）产生的，Fork 出来的版本库和本地 Clone 的仓库是类似的，他们有一个相同的 上游仓库（即原始仓库），这些版本库直接可以通过 PullReq">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2018-12-28T16:24:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git深入理解-命令工作机制">
<meta name="twitter:description" content="仓库创建Git是一个分布式的版本控制系统，这意味着在Git中版本库有 本地版本库 和 远程版本库 之分。 每个远程仓库可以有多个本地仓库，同时一个本地版本库可以同时对应多个远程版本库，多个远程版本库是从一个最原始的版本库 Fork（实际上也是clone）产生的，Fork 出来的版本库和本地 Clone 的仓库是类似的，他们有一个相同的 上游仓库（即原始仓库），这些版本库直接可以通过 PullReq">
<link rel="publisher" href="101963751496807079381">

    
    <link rel="alternative" href="/atom.xml" title="lyj&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/avatar.png">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/jacman.png" alt="lyj&#39;s blog" title="lyj&#39;s blog"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lyj&#39;s blog">lyj&#39;s blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope="" itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/posts/Git深入理解-命令工作机制/" title="Git深入理解-命令工作机制" itemprop="url">Git深入理解-命令工作机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/101963751496807079381?rel=author" title="lyj" target="_blank" itemprop="author">lyj</a>
		
  </p><p class="article-time">
    <time datetime="2018-05-07T00:00:00.000Z" itemprop="datePublished"> Published 2018-05-07</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#仓库创建"><span class="toc-number">1.</span> <span class="toc-text">仓库创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Init"><span class="toc-number">1.1.</span> <span class="toc-text">Init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone"><span class="toc-number">1.2.</span> <span class="toc-text">Clone</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#仓库维护"><span class="toc-number">2.</span> <span class="toc-text">仓库维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RefSpec"><span class="toc-number">2.1.</span> <span class="toc-text">RefSpec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-remote"><span class="toc-number">2.2.</span> <span class="toc-text">git remote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-fetch"><span class="toc-number">2.3.</span> <span class="toc-text">git fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-pull"><span class="toc-number">2.4.</span> <span class="toc-text">git pull</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-push"><span class="toc-number">2.5.</span> <span class="toc-text">git push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-submodule"><span class="toc-number">2.6.</span> <span class="toc-text">git submodule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支管理"><span class="toc-number">3.</span> <span class="toc-text">分支管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-branch"><span class="toc-number">3.1.</span> <span class="toc-text">git-branch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-tag"><span class="toc-number">3.2.</span> <span class="toc-text">git-tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-checkout"><span class="toc-number">3.3.</span> <span class="toc-text">git-checkout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-merge"><span class="toc-number">3.4.</span> <span class="toc-text">git-merge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本操作"><span class="toc-number">4.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-add"><span class="toc-number">4.1.</span> <span class="toc-text">git add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rm"><span class="toc-number">4.2.</span> <span class="toc-text">git rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-mv"><span class="toc-number">4.3.</span> <span class="toc-text">git mv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-diff"><span class="toc-number">4.4.</span> <span class="toc-text">git diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-commit"><span class="toc-number">4.5.</span> <span class="toc-text">git commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-status"><span class="toc-number">4.6.</span> <span class="toc-text">git status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-reset"><span class="toc-number">4.7.</span> <span class="toc-text">git reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-revert"><span class="toc-number">4.8.</span> <span class="toc-text">git revert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rebase"><span class="toc-number">4.9.</span> <span class="toc-text">git rebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-cherry-pick"><span class="toc-number">4.10.</span> <span class="toc-text">git cherry-pick</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h2><p>Git是一个分布式的版本控制系统，这意味着在Git中版本库有 <code>本地版本库</code> 和 <code>远程版本库</code> 之分。</p>
<p>每个远程仓库可以有多个本地仓库，同时一个本地版本库可以同时对应多个远程版本库，多个远程版本库是从一个最原始的版本库 <code>Fork</code>（实际上也是<code>clone</code>）产生的，<code>Fork</code> 出来的版本库和本地 <code>Clone</code> 的仓库是类似的，他们有一个相同的 <code>上游仓库</code>（即原始仓库），这些版本库直接可以通过 <code>PullRequest</code> 或 <code>MergeRequest</code> 操作进行仓库的交互。</p>
<p>本地仓库对应的远程仓库记录在 <code>.git/config</code> 文件中。本地仓库可以与多个的远程仓库 <code>pull/push</code> 代码。</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a><a href="https://git-scm.com/docs/git-init" target="_blank" rel="noopener">Init</a></h3><blockquote>
<p>创建一个空的 Git 仓库，或者重新初始化一个已经存在的 Git 仓库。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">  [-q | --quiet]</span><br><span class="line">  [--bare]</span><br><span class="line">  [--template=&lt;template_directory&gt;]</span><br><span class="line">  [--separate-git-dir &lt;git dir&gt;]</span><br><span class="line">  [--shared[=&lt;permissions&gt;]]</span><br><span class="line">  [directory]</span><br></pre></td></tr></table></figure>
<p>常规方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git init workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/workspace/.git/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">└── workspace</span><br><span class="line">    └── .git</span><br><span class="line">        ├── refs</span><br><span class="line">        │   ├── tags</span><br><span class="line">        │   └── heads</span><br><span class="line">        ├── objects</span><br><span class="line">        │   ├── pack</span><br><span class="line">        │   └── info</span><br><span class="line">        ├── info</span><br><span class="line">        │   └── exclude</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── update.sample</span><br><span class="line">        │   ├── prepare-commit-msg.sample</span><br><span class="line">        │   ├── pre-receive.sample</span><br><span class="line">        │   ├── pre-rebase.sample</span><br><span class="line">        │   ├── pre-push.sample</span><br><span class="line">        │   ├── pre-commit.sample</span><br><span class="line">        │   ├── pre-applypatch.sample</span><br><span class="line">        │   ├── post-update.sample</span><br><span class="line">        │   ├── fsmonitor-watchman.sample</span><br><span class="line">        │   ├── commit-msg.sample</span><br><span class="line">        │   └── applypatch-msg.sample</span><br><span class="line">        ├── description</span><br><span class="line">        ├── config</span><br><span class="line">        └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br></pre></td></tr></table></figure>
<p>以上创建的仓库，仓库文件 存放在 工作区目录 <code>workspace</code> 的子目录 <code>.git</code> 下。</p>
<p>分离的方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git init --separate-git-dir=.tig workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/.tig/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">├── workspace</span><br><span class="line">│   └── .git</span><br><span class="line">└── .tig</span><br><span class="line">    ├── refs</span><br><span class="line">    │   ├── tags</span><br><span class="line">    │   └── heads</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── pack</span><br><span class="line">    │   └── info</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── update.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   └── applypatch-msg.sample</span><br><span class="line">    ├── description</span><br><span class="line">    ├── config</span><br><span class="line">    └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 16 files</span><br><span class="line"></span><br><span class="line">$ cat workspace/.git</span><br><span class="line">gitdir: /Users/liuyanjie/git-learn/.tig</span><br></pre></td></tr></table></figure>
<p>相比常规方式创建仓库，可以看到</p>
<ol>
<li>分离方式创建仓库 可以将 <code>仓库(.git)</code> 和 <code>工作区目录(workspace)</code> 分离，常规方式创建的仓库，<code>仓库(.git)</code> 就在 <code>工作区目录(workspace)</code> 下。</li>
<li>分离方式创建的仓库，在 <code>工作区目录(workspace)</code> 下 <code>.git</code> 文件不再是仓库目录，而是包含指向仓库路径的一个文件。利用这一特性，可以创建多个工作区共享同一仓库。</li>
<li>仓库文件的目录可以是除了 <code>.git</code> 之外的其他的合法的目录名称。</li>
</ol>
<p>参考在创建的过程中，拷贝了一些的模版文件到 <code>仓库(.git)</code> 下，可以在运行的时候通过 <code>--template=</code> 或 <code>GIT_TEMPLATE_DIR</code> 环境变量 指定模版路径位置，模版示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree /usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">└── info</span><br><span class="line">    └── exclude</span><br><span class="line"></span><br><span class="line">2 directories, 13 files</span><br></pre></td></tr></table></figure>
<p>基于这一点，我们可以已一个参考作为模版，创建另一个仓库，Git 会把模板路径下的文件的复制到新的仓库下。</p>
<p>运行命令时，也可通过以下设置以下环境变量：</p>
<ul>
<li><code>GIT_DIR=.git</code> GIT仓库路径</li>
<li><code>GIT_OBJECT_DIRECTORY=$GIT_DIR/objects</code> GIT对象存储路径</li>
<li><code>GIT_TEMPLATE_DIR=path/to/git-core/templates</code> 模版路径，命令行参数：<code>--template</code>，配置：<code>init.templateDir</code></li>
</ul>
<p>在一个已经存在的仓库目录中运行 <code>init</code> 命令是安全的，它不会覆盖原来已经存在的东西。重新运行 <code>init</code> 的主要原因是挑选新添加的模版，或者移动仓库到其他的地方，如果 <code>--separate-git-dir</code> 指定的话。</p>
<p>初始化仓库是Git工作流中的第一步，一般情况下，需要两个仓库，一个本地仓库，一个远程仓库。</p>
<p>Init后的 Git 配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = true</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">	ignorecase = true</span><br><span class="line">	precomposeunicode = true</span><br></pre></td></tr></table></figure>
<p>只有 <code>core</code> 相关的几个配置项</p>
<h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a><a href="https://git-scm.com/docs/git-clone" target="_blank" rel="noopener">Clone</a></h3><blockquote>
<p>克隆仓库到一个新的目录，为每一个被克隆仓库中的分支创建对应的远程追踪分支。然后从克隆仓库的当前活动分支创建并检出初始分支到工作区目录。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span></span><br><span class="line">  [-q] [--quiet]</span><br><span class="line">  [-v] [--verbose]</span><br><span class="line">  [--progress]</span><br><span class="line">  </span><br><span class="line">  [-l] [-s] [--no-hardlinks]</span><br><span class="line">  [-n] [--no-checkout]</span><br><span class="line">  </span><br><span class="line">  [--template=&lt;template_directory&gt;]</span><br><span class="line">  [--separate-git-dir &lt;git-dir&gt;]</span><br><span class="line">  [--bare]</span><br><span class="line">  [--mirror]</span><br><span class="line"></span><br><span class="line">  [-c &lt;key&gt;=&lt;value&gt;] [--config &lt;key&gt;=&lt;value&gt;]</span><br><span class="line"></span><br><span class="line">  [-o &lt;origin-name&gt;] [--origin &lt;origin-name&gt;]</span><br><span class="line">  [-b &lt;branch-name&gt;] [--branch &lt;branch-name&gt;]</span><br><span class="line">  [--no-tags]</span><br><span class="line">  [-u &lt;upload-pack&gt;]</span><br><span class="line"></span><br><span class="line">  [--depth &lt;depth&gt;]</span><br><span class="line">  [--shallow-since=&lt;date&gt;]</span><br><span class="line">  [--shallow-exclude=&lt;revision&gt;]</span><br><span class="line"></span><br><span class="line">  [--[no-]single-branch]</span><br><span class="line"></span><br><span class="line">  [--reference &lt;repository&gt;]</span><br><span class="line">  [--dissociate]</span><br><span class="line">  </span><br><span class="line">  [--recurse-submodules[=&lt;pathspec&gt;]]</span><br><span class="line">  [--[no-]shallow-submodules]</span><br><span class="line">  [-j &lt;n&gt;] [--<span class="built_in">jobs</span> &lt;n&gt;]</span><br><span class="line">  [--] &lt;repository&gt; [&lt;directory&gt;]</span><br></pre></td></tr></table></figure>
<p>克隆一个远程仓库需要存在一个远程仓库，并且有一个可以访问的远程仓库的地址，对应 <code>&lt;repository&gt;</code> 参数，Git支持多种访问协议，最常见的如 <code>git://</code>。详见：<a href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a" target="_blank" rel="noopener">GIT-URLS</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/spec.git</span><br><span class="line">Cloning into <span class="string">'spec'</span>...</span><br><span class="line">remote: Counting objects: 49, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 49 (delta 0), reused 0 (delta 0), pack-reused 49</span><br><span class="line">Receiving objects: 100% (49/49), 49.83 KiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (15/15), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">$ cat spec/.git/config</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">	url = git@github.com:liuyanjie/spec.git</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/master</span><br></pre></td></tr></table></figure>
<p>相比 <code>git init</code>，<code>git clone</code> 之后的仓库配置文件中，增加了以上内容，配置 <code>本地分支</code> 和 <code>远程分支</code> 间的追踪关系，该配置为 Git 默认配置，一般不需要修改。</p>
<p><code>git clone</code> 工作流程（猜测）：</p>
<p><code>INIT</code> -&gt; <code>REMOTE-TRACKING</code> -&gt; <code>FETCH</code> -&gt; <code>CHECKOUT HEAD</code></p>
<p><code>git init</code> -&gt; <code>git remote set-url origin git://...</code> -&gt; <code>git fetch</code> -&gt; [<code>git merge</code>] -&gt; <code>git checkout HEAD</code></p>
<p>Clone过程可以进行哪些控制：</p>
<ol>
<li><code>--bare</code>：同 <code>Init</code> 相同，可以 <code>Clone</code> 一个 <code>Bare</code> 仓库到本地。</li>
<li><code>--mirror</code>：可以进行镜像 <code>Clone</code>，制作镜像仓库。</li>
<li><code>--template=</code>：同 <code>Init</code> 相同，可以指定模版。</li>
<li><code>--separate-git-dir=&lt;git dir&gt;</code>：分离仓库和工作区目录。</li>
<li><code>--reference[-if-able] &lt;repository&gt;</code>：可以通过该参数指定一个已存在的仓库进行加速，通常用在频繁的完整的 <code>Clone</code> 上。</li>
<li><code>--depth</code>：可以指定克隆的 Commit 数量。</li>
</ol>
<p>克隆本地仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> path/to/<span class="built_in">local</span>/git/repository</span><br></pre></td></tr></table></figure>
<p>克隆远程仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git --depth=1</span><br><span class="line">Cloning into <span class="string">'knowledge'</span>...</span><br><span class="line">remote: Counting objects: 300, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (247/247), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">'knowledge'</span>...</span><br><span class="line">remote: Counting objects: 495, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (141/141), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> \</span><br><span class="line">  --depth=1 \</span><br><span class="line">  --reference-if-able=/Volumes/Data/Data/ws/knowledge \</span><br><span class="line">  git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">'knowledge'</span>...</span><br><span class="line">remote: Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>
<p>在 <code>Clone</code> 的过程中，通过一些参数可以有效的减少 <code>Clone</code> 的等待时间，如在 CI 的构建流程中，可以提高构建时间。</p>
<h2 id="仓库维护"><a href="#仓库维护" class="headerlink" title="仓库维护"></a>仓库维护</h2><p>仓库维护包括维护 <code>本地仓库</code> 和 <code>远程仓库</code>，在 Git 中，很多时候，同一个 <code>远程仓库</code> 可以同时存在多个 <code>本地仓库</code>，偶尔，同一个 <code>本地仓库</code> 可以同时对应多个 <code>远程仓库</code>。</p>
<p>一旦 建立了 <code>本地仓库</code> 和 <code>远程仓库</code> 的对应关系，就需要频繁进行 <code>远程仓库</code> 和 <code>本地仓库</code> 之间的分支、标签等数据同步，对应操作有 <code>push、fetch、pull</code> 等。</p>
<p>同步的内容主要有：</p>
<ul>
<li>分支同步：分支的 <code>创建、修改、删除</code>，本地向远程同步，远程向本地同步</li>
<li>标签同步：标签的 <code>创建、修改、删除</code>，本地向远程同步，远程向本地同步</li>
<li>数据同步</li>
</ul>
<p>同步数据的基础在于 <code>本地仓库</code> 和 <code>远程仓库</code> 间存在的对应关系，这一关系 使用 <code>RefSpec</code> 进行描述。</p>
<h3 id="RefSpec"><a href="#RefSpec" class="headerlink" title="RefSpec"></a><a href="https://git-scm.com/book/zh/v1/Git-内部原理-The-Refspec" target="_blank" rel="noopener">RefSpec</a></h3><p><a href="https://git-scm.com/book/zh/v1/Git-内部原理-The-Refspec" target="_blank" rel="noopener">Git 内部原理 - The Refspec</a></p>
<p>下面示例中 <code>+refs/heads/*:refs/remotes/origin/*</code> 即为 <code>RefSpec</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>
<p>RefSpec 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">+refs/heads/master:master</span><br><span class="line">+master:refs/remotes/origin/master</span><br><span class="line">master:master</span><br><span class="line">:master</span><br><span class="line">master:</span><br></pre></td></tr></table></figure>
<p><code>RefSpec</code> 主要用来表示 <code>本地版本库</code> 和 <code>远程版本库</code> 之间的 <code>分支</code>、<code>标签</code> 等数据的对应关系。</p>
<p>指定获取哪些 <code>remote-refs</code> 更新 <code>local-refs</code>，当没有在命令行显示指明 <code>RefSpec</code>，会按照下面的默认策略执行。</p>
<p><code>RefSpec</code> 的格式是一个可选的 <code>+</code> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code> 是远端上的引用格式，<code>&lt;dst&gt;</code> 是将要记录在本地的引用格式。可选的 <code>+</code> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它。</p>
<p>所以上面示例中的 <code>RefSpec</code>，远程仓库中所有分支 <code>refs/heads/*</code>，对应到本地仓库下所有分支 <code>refs/remotes/origin/*</code>，分支名称不变。如果需要改变分支名称，则需要配置特定的 <code>RefSpec</code>。</p>
<p>从远程获取指定数据到本地，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branch master &lt;==&gt; +refs/heads/master:+refs/remotes/origin/master</span><br><span class="line">branch    A:a &lt;==&gt; +refs/heads/A:+refs/remotes/origin/a</span><br><span class="line">tag     &lt;tag&gt; &lt;==&gt; +refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">$ tree .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">├── heads</span><br><span class="line">│   ├── feature</span><br><span class="line">│   │   └── travis-ci</span><br><span class="line">│   └── master</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       ├── feature</span><br><span class="line">│       │   └── travis-ci</span><br><span class="line">│       └── master</span><br><span class="line">└── tags</span><br><span class="line">    └── v0.0.0</span><br></pre></td></tr></table></figure>
<p>以上对应关系：</p>
<table>
<thead>
<tr>
<th>head@local</th>
<th>remote@local</th>
<th>remote@remote</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody>
</table>
<p>注意：<code>RefSpec</code> 描述了 <code>remote@local</code> 和 <code>remote@remote</code> 之间的对应关系，但是不包含 <code>head@local</code> 和 <code>remote@local</code> 之间的关系，它们之间的存在的追踪关系在其他配置项中描述。</p>
<p><code>head@local</code> 下的 分支，是在本地存在的分支，可能从远程某个分支 <code>checkout</code>，也可能是本地新建的。</p>
<p><code>RefSpec</code> 一般不会出现在命令行中，而是由命令自动写在配置文件中，但是可以在命令行中直接使用。</p>
<p>例如：<code>git remote add remote-name</code>，Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/remote-name</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote add liuyanjie git@github.com:liuyanjie/knowledge.git</span><br><span class="line"></span><br><span class="line">$ cat .git/config</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">[remote <span class="string">"liuyanjie"</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/liuyanjie/*</span><br></pre></td></tr></table></figure>
<p>以下几种方式是等价的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master</span><br><span class="line">git <span class="built_in">log</span> heads/master</span><br><span class="line">git <span class="built_in">log</span> refs/heads/master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> origin/master</span><br><span class="line">git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure>
<p>通常都是使用省略 <code>refs/heads/</code> 和 <code>refs/remotes/</code> 的形式。</p>
<p>以上示例中 <code>RefSpec</code> 中包含 <code>*</code> 会使 Git 拉取所有远程分支到本地，如果想让Git只拉取固定的分支，可以将 <code>*</code> 修改为指定的分支名。</p>
<p>也可以在命令行上指定多个 <code>RefSpec</code>，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure>
<p>同样，也可以将以上命令行中的 <code>RefSpec</code> 写入配置中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote "origin"]</span></span><br><span class="line">       url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">       fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">       fetch = +refs/heads/develop:refs/remotes/origin/develop</span><br><span class="line">       fetch = +refs/heads/feature/*:refs/remotes/origin/feature/*</span><br></pre></td></tr></table></figure>
<p>以上，<code>feature</code> 可以看做是命名空间，划分不同的分支类型。</p>
<p>上面描述都是拉取时 <code>RefSpec</code> 的作用，同样推送是也需要 <code>RefSpec</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>
<p>推送一个空分支可以删除远程分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/heads/qa/master</span><br></pre></td></tr></table></figure>
<p><code>RefSpec</code> 描述了本地仓库分支和远程仓库分支的对应关系。很多时候可以省略，因为 Git 包含了很多默认行为。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 的分支大都是 其他 <code>本地仓库</code> 同步到远程的。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 <code>创建</code> 的新分支，在同步数据的时候默认会被拉到本地，<code>删除</code> 的分支默认不会在本地进行同步删除，<code>修改</code> 的分支会被更新，并与本地追踪的开发分支进行合并。</p>
<p>以上，通过 <code>RefSpec</code> 描述的 本地仓库 和 远程仓库 中 分支 是如何对应的，了解了 本地仓库 和 远程仓库 之间的对应关系。</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><a href="https://git-scm.com/docs/git-remote" target="_blank" rel="noopener">git remote</a></h3><blockquote>
<p>管理本地仓库对应的一组远程仓库，包括 查看、更新、添加、删除、重命名、设置 等一系列操作</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br><span class="line"></span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote remove   &lt;name&gt;</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote <span class="built_in">set</span>-branches  [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line"></span><br><span class="line">git remote get-url       [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url       [--push] &lt;name&gt; &lt;new-url&gt; [&lt;old-url&gt;]</span><br><span class="line">git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;new-url&gt;</span><br><span class="line">git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git remote                                                  <span class="comment"># 列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                               <span class="comment"># 查看远程主机的地址</span></span><br><span class="line">git remote show   remote_name                               <span class="comment"># 查看该远程主机的详细信息</span></span><br><span class="line">git remote add    remote_name remote_url                    <span class="comment"># 添加远程主机</span></span><br><span class="line">git remote remove remote_name                               <span class="comment"># 删除远程主机</span></span><br><span class="line">git remote rename remote_name new_remote_name               <span class="comment"># 重命名远程主机</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-head remote_name branch_name --auto          <span class="comment"># 查询远程获得默认分支</span></span><br><span class="line">git remote <span class="built_in">set</span>-head remote_name branch_name --delete        <span class="comment"># 删除默认分支</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-branches [--add] remote_name branch_name     <span class="comment"># 设置 RefSpec， [remote "remote_name"].fetch</span></span><br><span class="line"></span><br><span class="line">git remote get-url remote_name                              <span class="comment"># 查看远程主机地址 [remote "remote_name"].url</span></span><br><span class="line">git remote <span class="built_in">set</span>-url remote_name git://new.url.here           <span class="comment"># 设置远程主机地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url remote_name --push   git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url remote_name --add    git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url remote_name --delete git://new.url.here  <span class="comment"># 删除远程主机地址</span></span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;remote_name&gt;…​            <span class="comment"># 删除某个远程名下过期（即不存在）的分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see http://stackoverflow.com/questions/1856499/differences-between-git-remote-update-and-fetch</span></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  Push  URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    feature/travis-ci tracked</span><br><span class="line">    master            tracked</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    feature/travis-ci merges with remote feature/travis-ci</span><br><span class="line">    master            merges with remote master</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    feature/travis-ci pushes to feature/travis-ci (up to date)</span><br><span class="line">    master            pushes to master            (up to date)</span><br></pre></td></tr></table></figure>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noopener">git fetch</a></h3><blockquote>
<p>下载 Refs 从另外一个仓库，以及完成他们的变更历史所需要的 Objects。追踪的远程分支将会被更新。</p>
</blockquote>
<p><code>git fetch</code> 的主要工作就是和远程同步 <code>Refs</code>，而 <code>Refs</code> 可以 被 <code>创建、修改、删除</code>，所以 <code>fetch</code> 操作必然应该能够同步这些变化。</p>
<ul>
<li><a href="https://git-scm.com/docs/git-fetch#_remotes_a_id_remotes_a" target="_blank" rel="noopener">REMOTES</a></li>
<li><a href="https://git-scm.com/docs/git-fetch#_configured_remote_tracking_branches_a_id_crtb_a" target="_blank" rel="noopener">CONFIGURED REMOTE-TRACKING BRANCHES</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br><span class="line">git fetch [&lt;options&gt;] &lt;group&gt;</span><br><span class="line">git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​]</span><br><span class="line">git fetch --all [&lt;options&gt;]</span><br></pre></td></tr></table></figure>
<p><code>.git/FETCH_HEAD</code>：是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p>
<p>执行过 <code>fetch</code> 操作的项目都会存在一个 <code>FETCH_HEAD</code> 列表，其中每一行对应于远程服务器的一个分支。</p>
<p>当前分支指向的 <code>FETCH_HEAD</code>，就是这个文件第一行对应的那个分支。</p>
<p>从本质上来说，唯一能从服务器下拉取数据的只有 <code>fetch</code>，其他命令的下拉数据的操作都是基于 <code>fetch</code> 的，所以 <code>fetch</code> 必然需要能够尽可能处理所有下拉数据时可能出现的情况。</p>
<p>Options:</p>
<ul>
<li><p>[shallow] 限制下拉指定的提交数：</p>
<ul>
<li><code>--depth=&lt;depth&gt;</code></li>
<li><code>--deepen=&lt;depth&gt;</code></li>
</ul>
</li>
<li><p>[shallow]限制下拉指定的提交时间：</p>
<ul>
<li><code>--shallow-since=&lt;date&gt;</code></li>
<li><code>--shallow-exclude=&lt;revision&gt;</code></li>
</ul>
</li>
<li><p>[deep]</p>
<ul>
<li><code>--unshallow</code>，<code>deep clone</code></li>
<li><code>--update-shallow</code></li>
</ul>
</li>
<li><p>[prune] 剪枝操作</p>
<p>远程仓库可能对已有的分支标签进行删除，而本地仓库并未删除，需要同步删除操作</p>
<ul>
<li><code>-p</code> <code>--prune</code></li>
<li><code>-p</code> <code>--prune-tags</code></li>
</ul>
</li>
<li><p>[tags] 默认情况下，<code>git fetch</code> 会下拉 <code>tag</code></p>
<ul>
<li><code>-t</code> <code>--tags</code> 【默认】下拉标签</li>
<li><code>-n</code> <code>--no-tags</code> 不下拉标签</li>
</ul>
</li>
<li><p>子模块</p>
<ul>
<li><code>--recurse-submodules-default=[yes|on-demand]</code></li>
<li><code>--recurse-submodules[=yes|on-demand|no]</code></li>
<li><code>--no-recurse-submodules</code></li>
<li><code>--submodule-prefix=&lt;path&gt;</code></li>
</ul>
</li>
</ul>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>head@local</th>
<th>remote@local</th>
<th>remote@remote</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody>
</table>
<p><code>git fetch</code> 将 <code>remote@remote</code> fetch <code>remote@local</code>，而 <code>RefSpec（+refs/heads/*:refs/remotes/origin/*）</code> 前面的 <code>+</code> 使 Git 在不能快速前进的情况下也强制更新，所以不会出现 <code>remote@remote --merge--&gt; remote@local</code> 的情况，实际上合并是不合理的行为，因为本地的 <code>refs/remotes/origin/*</code> 就是与远程保持同步的，如果合并了，就不同步了，更重要的是，远程分支可能修改了分支历史，如果合并，修改前的内容又合并进版本库了，有可能还需要解决冲突，而之后的 <code>remote@local --merge--&gt; head@local</code> 又会有可能合并。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git fetch                                         <span class="comment"># 获取 所有远程仓库 上的所有分支，将其记录到 .git/FETCH_HEAD 文件中</span></span><br><span class="line">git fetch -all                                    <span class="comment"># 获取 所有远程仓库 上的所有分支</span></span><br><span class="line">git fetch remote                                  <span class="comment"># 获取 remote 上的所有分支</span></span><br><span class="line">git fetch remote branch-name                      <span class="comment"># 获取 remote 上的分支：branch-name</span></span><br><span class="line">git fetch remote branch-name:<span class="built_in">local</span>-branch-name    <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支</span></span><br><span class="line">git fetch remote branch-name:<span class="built_in">local</span>-branch-name -f <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支，[强制]</span></span><br><span class="line">git fetch -f | --force                            <span class="comment"># 当使用 refspec(&lt;branch&gt;:&lt;branch&gt;) 时，跳过亲子关系检查，强制更新本地分支</span></span><br><span class="line">git fetch -p | --prune                            <span class="comment"># 获取所有远程分支并清除服务器上已删掉的分支</span></span><br><span class="line">git fetch -t | --tags                             <span class="comment"># 从远程获取数据时获取tags</span></span><br><span class="line">git fetch -n | --no-tags                          <span class="comment"># 从远程获取数据时去除tags</span></span><br><span class="line">git fetch --progress --verbose                    <span class="comment"># 显示进度及冗长日志</span></span><br><span class="line">git fetch --dry-run                               <span class="comment"># 显示做了什么，但是并不实际修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --depth=3 --no-tags --progress origin +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br><span class="line">git fetch --depth=3 --no-tags --progress git@github.com:liuyanjie/knowledge.git +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --prune --progress --verbose --dry-run</span><br><span class="line">From github.com:remote-name/branch-name</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/abcd</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/efg</span><br><span class="line">remote: Counting objects: 34, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 34 (delta 18), reused 24 (delta 16), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (34/34), <span class="keyword">done</span>.</span><br><span class="line">   f4e75b13a..6a338066c  master              -&gt; origin/master</span><br><span class="line"> + c29324269...641076244 develop             -&gt; origin/develop  (forced update)</span><br><span class="line"> = [up to date]          release/1.0.0       -&gt; origin/release/1.0.0</span><br><span class="line"> * [new branch]          release/1.1.0       -&gt; origin/release/1.1.0</span><br><span class="line"> * [new tag]             v1.1.0              -&gt; v1.1.0</span><br></pre></td></tr></table></figure>
<p><code>--prune</code> 只能清理 <code>.git/refs/remotes/remote-name</code> 目录下的远程追踪分支，而不会删除 <code>.git/refs/heads</code> 下的本地分支，即使这些分支已经合并，这些分支的清理需要特定的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> <span class="comment"># 查看确认</span></span><br><span class="line">git branch --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> | xargs git branch -d</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> | xargs git branch -d</span><br><span class="line">Deleted branch feature/auto-tag-ci (was 98147f0e3).</span><br><span class="line">Deleted branch feature/build-optimize (was d359f4179).</span><br><span class="line">Deleted branch feature/contract (was c0c4bdaa8).</span><br><span class="line">Deleted branch feature/cross-domain (was 2e9b25c82).</span><br><span class="line">Deleted branch feature/deploy (was 3650db271).</span><br><span class="line">Deleted branch feature/nvmrc (was 1d174fcd8).</span><br><span class="line">Deleted branch feature/winston-logstash (was f13700c66).</span><br></pre></td></tr></table></figure>
<p>同样远程仓库也有一些已经合并了，但是未删除的分支需要删除：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> | sed <span class="string">'s/origin\//:/'</span> <span class="comment"># 查看确认</span></span><br><span class="line">git branch -r --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> | sed <span class="string">'s/origin\//:/'</span> | xargs -n 1 git push origin</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --merged | egrep -v <span class="string">"(^\*|master|develop|release)"</span> | sed <span class="string">'s/origin\//:/'</span> | xargs -n 1 git push origin</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line"> - [deleted]             feature/xxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br><span class="line">From git@github.com:schacon/simple</span><br><span class="line"> ! [rejected]        master     -&gt; origin/master  (non fast forward)</span><br><span class="line"> * [new branch]      topic      -&gt; origin/topic</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中， <code>master</code> 分支因为不是一个可以 <code>快速演进</code> 的引用而拉取操作被拒绝。你可以在 <code>RefSpec</code> 之前使用一个 <code>+</code> 号来重载这种行为。</p>
<p>输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; [&lt;reason&gt;]</span><br></pre></td></tr></table></figure>
<p>输出格式详细介绍见：<a href="https://git-scm.com/docs/git-fetch#_output" target="_blank" rel="noopener">OUTPUT</a></p>
<p><code>fetch</code> 负责将 远程仓库 更新到 远程仓库在本地的对应部分，其他工作又其他 命令 负责。</p>
<p>在实际使用中，大多数时候都是使用 <code>pull</code> 间接的使用 <code>fetch</code>。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><a href="https://git-scm.com/docs/git-pull" target="_blank" rel="noopener">git pull</a></h3><blockquote>
<p>将来自远程存储库的更改合并到当前分支中</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master  <span class="comment"># 获取远程分支 master 并 merge 到当前分支</span></span><br></pre></td></tr></table></figure>
<p>默认模式下，<code>git pull</code> 等价于以下两步:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>
<p>特例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout master</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>
<p>更确切的说，<code>git pull</code> 已指定的参数运行 <code>git fetch</code>，然后 调用 <code>git merge</code> 合并 检索到的分支头到当前分支，通过 <code>--rebase</code> 参数，<code>git merge</code> 也可以被替换成 <code>git rebase</code>。</p>
<p>假定有如下的历史，并且当前分支是 <code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>
<p>调用 <code>git pull</code> 时，首先需要 <code>fetch</code> 变更从远处分支，下拉之后的仓库状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master in your repository</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>
<p>因为 远程分支 master (C) 已经和 本地分支 master (G) 已经处于分离状态，此时，<code>git merge</code> 合并 <code>origin/master</code> 到 <code>master</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H ← master</span><br></pre></td></tr></table></figure>
<p>以上过程发生了一次 <code>远程</code> 合并到 <code>本地</code> 的情形，git 会自动生成类似下面的 <code>commit message</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &apos;master&apos; of github.com:liuyanjie/knowledge into master</span><br></pre></td></tr></table></figure>
<p>出现 <code>远程</code> 合并到 <code>本地</code> 的情形 在 Git 中是一种不良好的实践，应该极力避免甚至是禁止出现，这种情形在多个人同时在同一个分支上开发的时候非常容易出现。</p>
<p>记住一点：一般来书，<code>分支</code>是要合并到远程服务器上的分支，而不是远程服务分支合并到本地分支的。</p>
<p>在实际开发过程中，所有的合并操作都应该发生在远程服务器上，保持所有的分支有清晰的历史。同样，也应该避免不必要的合并，甚至是禁止合并。</p>
<blockquote>
<p>一般情况下，创建了分支必然需要通过合并来将分支上的内容整合到分支的基上，但是也有不合并的其他方法</p>
</blockquote>
<p>合并产生的 <code>Commit</code> 并未给版本库带来新的改变，但是却使版本历史不够清晰了。</p>
<p>合并使分支历史从单向链表变成了有向图，一堆线杂乱无章交错，分支历史难以理解。</p>
<p>合并产生的 <code>Commit</code> 有两个或多个父 <code>Commit</code>， <code>Reset</code> 难以进行。</p>
<p>如何避免 本地合并？</p>
<ol>
<li>在 <code>commit</code> 之前先 <code>pull</code>，避免分叉。</li>
<li>在 <code>commit</code> 之后立即 <code>push</code>，使其他人的本地仓库能及时获取到最新的 <code>commit</code>。</li>
</ol>
<p>知道一定会 发生本地 合并时如何处理？</p>
<ol>
<li><code>git pull --ff-only</code> or <code>git fetch</code></li>
<li><code>git rebase origin/master</code></li>
</ol>
<p>已经出现 本地合并 如何解决？</p>
<ol>
<li><code>git reset C</code> 重置当前分支到 <code>C</code>，<code>F</code> <code>G</code> 会重新回到暂存区。</li>
<li><code>git commit -am &quot;commit message&quot;</code> 重新提交。</li>
<li><code>git push</code></li>
</ol>
<p>解决之后的分支图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">              origin/master</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C---F---G ← master</span><br><span class="line">     /</span><br><span class="line">D---E</span><br></pre></td></tr></table></figure>
<p>假设版本库当前的状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>
<p>以上版本库库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← master</span><br><span class="line">     /        ↑</span><br><span class="line">D---E         origin/master in your repository</span><br></pre></td></tr></table></figure>
<p>以上版本库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>
<p>快速前进不产生新的 <code>Commit</code>，效果上只移动分支头即可，默认情况下进行就是快速前进</p>
<p>在能够进行快速前进的情况下，也可以强制进行合并，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E-----------H ← master</span><br></pre></td></tr></table></figure>
<p>所以 <code>git pull</code> 的参数主要由 <code>git fetch</code> 和 <code>git merge</code> 的参数组成。</p>
<p><code>git pull</code> 的运行过程：</p>
<ol>
<li>首先，基于本地的 <code>FETCH_HEAD</code> 记录，比对本地的 <code>FETCH_HEAD</code> 记录与远程仓库的版本号</li>
<li>然后通过 <code>git fetch</code> 获得当前指向的远程分支的后续版本的数据</li>
<li>最后通过 <code>git merge</code> 将其与本地的当前分支合并</li>
</ol>
<p>若有多个 remote，git pull remote_name 所做的事情是：</p>
<ul>
<li>获取 <code>[remote_name]</code> 下的所有分支</li>
<li>寻找本地分支有没有 <code>tracking</code> 这些分支的，若有则 <code>merge</code> 这些分支，若没有则 <code>merge</code> 当前分支</li>
</ul>
<p>另外，若只有一个 remote，假设叫 origin，那么 git pull 等价于 git pull origin；平时养成好习惯，没谱的时候都把【来源】带上。</p>
<p>怎么知道 <code>tracking</code> 了没有？</p>
<ul>
<li>如果你曾经这么推过：<code>git push -u origin master</code>，那么你执行这条命令时所在的分支就已经 <code>tracking to origin/master</code> 了</li>
<li>如果你记不清了：<code>cat .git/config</code>，由此可见，<code>tracking</code> 的本质就是指明 <code>pull</code> 的 <code>merge</code> 动作来源</li>
</ul>
<p>总结:</p>
<ul>
<li><code>git pull = git fetch + git merge</code></li>
<li><code>git fetch</code> 拿到了远程所有分支的更新，<code>cat .git/FETCH_HEAD</code> 可以看到其状态，若是 <code>not-for-merge</code> 则不会有接下来的 <code>merge</code> 动作</li>
<li><code>merge</code> 动作的默认目标是当前分支，若要切换目标，可以直接切换分支</li>
<li><code>merge</code> 动作的来源则取决于你是否有 <code>tracking</code>，若有则读取配置自动完成，若无则请指明【来源】</li>
</ul>
<p><code>pull</code> 时还可能存在远程分支不存在的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">test</span></span><br><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/<span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line">error: the requested upstream branch <span class="string">'origin/test'</span> does not exist</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning on basing your work on an upstream</span><br><span class="line">hint: branch that already exists at the remote, you may need to</span><br><span class="line">hint: run <span class="string">"git fetch"</span> to retrieve it.</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning to push out a new <span class="built_in">local</span> branch that</span><br><span class="line">hint: will track its remote counterpart, you may want to use</span><br><span class="line">hint: <span class="string">"git push -u"</span> to <span class="built_in">set</span> the upstream config as you push.</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 81, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 81 (delta 42), reused 81 (delta 42), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (81/81), <span class="keyword">done</span>.</span><br><span class="line">From github.com:liuyanjie/knowledge</span><br><span class="line">   2f977e2..be00fff  feature/x -&gt; origin/feature/x</span><br><span class="line">Your configuration specifies to merge with the ref <span class="string">'refs/heads/feature/abc'</span></span><br><span class="line">from the remote, but no such ref was fetched.</span><br></pre></td></tr></table></figure>
<p>需要提及的一点是：</p>
<p><code>pull</code> 操作，不应该涉及 <code>合并</code> 或 <code>变基</code> 操作，即 <code>pull</code> 应该总是 快速前进 的。</p>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>head@local</th>
<th>remote@local</th>
<th>remote@remote</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody>
</table>
<p><code>git pull</code> 在 <code>git fetch</code> 的基础之上增加了 <code>git merge</code>，将 <code>远程分支对应的本地分支</code> 合并到 <code>追踪的本地开发分支</code></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><a href="https://git-scm.com/docs/git-push" target="_blank" rel="noopener">git push</a></h3><blockquote>
<p>使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p>
</blockquote>
<p><code>git push</code> 是与 <code>git pull</code> 相对应的推送操作，同样需要能够推送本地的多种情形的变更到远程仓库。git 向远程仓库推送的操作只有 <code>push</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">     [--all | --mirror | --tags]</span><br><span class="line">     [--follow-tags]</span><br><span class="line">     [--atomic]</span><br><span class="line">     [-n | --dry-run]</span><br><span class="line">     [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">     [--repo=&lt;repository&gt;]</span><br><span class="line">     [-f | --force]</span><br><span class="line">     [-d | --delete]</span><br><span class="line">     [--prune]</span><br><span class="line">     [-v | --verbose]</span><br><span class="line">     [-u | --<span class="built_in">set</span>-upstream]</span><br><span class="line">     [--push-option=&lt;string&gt;]</span><br><span class="line">     [--[no-]signed|--sign=(<span class="literal">true</span>|<span class="literal">false</span>|<span class="keyword">if</span>-asked)]</span><br><span class="line">     [--force-with-lease[=&lt;ref-name&gt;[:&lt;expect&gt;]]]</span><br><span class="line">     [--no-verify]</span><br><span class="line">     [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git push                                 <span class="comment"># 如果当前分支只有一个追踪分支，那么主机名都可以省略</span></span><br><span class="line">git push origin HEAD                     <span class="comment"># 将 当前 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master                   <span class="comment"># 将 master 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master -u                <span class="comment"># 将 master 分支 推送 到远程 master 分支，并建立追踪关系</span></span><br><span class="line">git push origin master --<span class="built_in">set</span>-upstream    <span class="comment"># 同上</span></span><br><span class="line">git push origin --all                    <span class="comment"># 将所有本地分支都推送到origin主机</span></span><br><span class="line">git push origin --force                  <span class="comment"># 强制推送更新远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin :hotfix/xxxx             <span class="comment"># 删除远程仓库的 hotfix/xxxx 分支</span></span><br><span class="line">git push origin :master                  <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line">git push origin --delete master          <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line"></span><br><span class="line">git push origin --prune                  <span class="comment"># 删除在本地没有对应分支的远程分支</span></span><br><span class="line"></span><br><span class="line">git push --tags                          <span class="comment"># 把所有tag推送到远程仓库</span></span><br></pre></td></tr></table></figure>
<p>推送模式：</p>
<ul>
<li>simple  模式: 不带任何参数的git push，默认只推送当前分支。2.0以上版本，默认此方式。</li>
<li>matching模式: 会推送所有有对应的远程分支的本地分支。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 1.25 KiB | 1.25 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 2 <span class="built_in">local</span> objects.</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line">   d26f671..e081fb3  master -&gt; master</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete ref...</span><br></pre></td></tr></table></figure>
<p>推送代码到服务器与拉取代码到本地其实是相同的，所以服务代码推送到服务全之后，同样有可能出现需要合并的情况，如推送者本地仓库在没有 <code>pull</code> 后进行 <code>commit</code> 后 <code>push</code>，导致本地代码和远程服务器代码分叉，此时服务端也要面临合并问题，合并就有可能产生冲突，但是服务端没有解决冲突的能力，所以实质上服务端是禁止发生合并的，只能进行快速前进。当不能快速前进，服务端会返回错误给客户端，错误会提示先 <code>pull</code> 再 <code>push</code>。此时，<code>pull</code> 操作是一定会进行 <code>merge</code> 的，可能需要处理 <code>merge</code>，此时就需要处理前面提到的处理本地合并的问题了。</p>
<h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a><a href="https://git-scm.com/docs/git-submodule" target="_blank" rel="noopener">git submodule</a></h3><blockquote>
<p>初始化、更新或检查子模块</p>
</blockquote>
<p><a href="https://git-scm.com/docs/gitsubmodules" target="_blank" rel="noopener">gitsubmodules</a>  - mounting one repository inside another</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--] &lt;repository&gt; [&lt;path&gt;]</span><br><span class="line">git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] init [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…​)</span><br><span class="line">git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch]</span><br><span class="line">        [--[no-]recommend-shallow] [-f|--force] [--rebase|--merge]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--recursive]</span><br><span class="line">        [--<span class="built_in">jobs</span> &lt;n&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] summary [--cached|--files] [(-n|--summary-limit) &lt;n&gt;]</span><br><span class="line">        [commit] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] foreach [--recursive] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…​]</span><br></pre></td></tr></table></figure>
<p>添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -b master --name knowledge --reference=/Volumes/Data/Data/ws/knowledge -- git@github.com:liuyanjie/knowledge.git ./third_parts/knowledge</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   third_parts</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"..."</span></span><br><span class="line">[master 83506db] ...</span><br><span class="line"> 2 files changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 third_parts</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 7, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 5.31 KiB | 5.31 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">To github.com:liuyanjie/about.git</span><br><span class="line">   53abb09..83506db  master -&gt; master</span><br></pre></td></tr></table></figure>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git 是一个分布式的结构，有本地版本库和远程版本库，便有了本地分支和远程分支的区别了。</p>
<p>本地分支和远程分支在 <code>git push</code> 的时候可以随意指定，交错对应，只要不出现版本从图即可。</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git-branch"></a><a href="https://git-scm.com/docs/git-branch" target="_blank" rel="noopener">git-branch</a></h3><blockquote>
<p>创建、修改、删除、查看、重命名、复制分支</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch (-t | --[no-]track) (-l | --[no-]create-reflog) [-f | --force] &lt;branch-name&gt; [&lt;start-point&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置/修改上游分支</span></span><br><span class="line">git branch [-u | --<span class="built_in">set</span>-upstream-to=] &lt;upstream&gt; [&lt;branch-name&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch -a --all</span><br><span class="line">git branch -r</span><br><span class="line">git branch --list &lt;pattern&gt;...</span><br><span class="line">git branch --list --[no-]contains [&lt;commit&gt;]</span><br><span class="line">git branch --list --[no-]merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置分支</span></span><br><span class="line">git branch (-f --force) &lt;branch-name&gt; &lt;start-point&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名分支</span></span><br><span class="line">git branch (-m --move | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-m --move) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -M [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制分支</span></span><br><span class="line">git branch (-c --copy) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-c --copy) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -C [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="comment"># -r 可以同时删除远程追踪分支，但是只有在远程分支删除的情况下才有意义，否则会fetch回来</span></span><br><span class="line">git branch (-d --delete) [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch (-d --delete)  --force [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch -D [-r] &lt;branchname&gt;…​</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑分支描述</span></span><br><span class="line">git branch --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>
<p><code>git branch</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>。</p>
<p><code>remotes/origin/*</code> 下的分支删除：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;branch-name&gt;</span><br><span class="line">git push :&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<p>以上命令在删除远程仓库的分支的同时，同步删除 <code>remotes/origin/*</code> 下的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;remote-name&gt;/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<p>以上命令删除 <code>remotes/origin/*</code> 下的分支，但是远程分支并未删除，在 <code>git fetch</code> 后还会拉下来，所以这种删除无意义。</p>
<p>分支类型：</p>
<ul>
<li>远程分支（remote-branch），远程服务器上的分支，<code>refs/heads/*</code>@remote，是<code>远程追踪分支</code>的<code>上游分支</code>。</li>
<li>远程追踪分支（remote-tracking branch），远程服务器对应在本地的分支，与<code>远程分支</code>存在<code>追踪</code>关系，可能是<code>本地分支</code>的<code>上游分支</code>。</li>
<li>本地分支（local branch），<code>refs/heads/*</code>@local，可能与<code>远程追踪分支</code>存在<code>追踪</code>关系。</li>
</ul>
<p>分支关系：</p>
<ul>
<li>追踪分支（tracking branch），能够主动追踪其他分支，自动跟随其他分支变化更新的分支。</li>
<li>上游分支（upstream branch），被追踪的分支。</li>
</ul>
<blockquote>
<p>Checking out a <code>local branch</code> from a <code>remote-tracking branch</code> automatically creates what is called a <code>“tracking branch”</code> (and the branch it tracks is called an <code>“upstream branch”</code>).</p>
</blockquote>
<p>只有把概念定义清楚，才能够进行准确的描述，要不然都可能带来理解上的偏差。</p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git-tag"></a><a href="https://git-scm.com/docs/git-tag" target="_blank" rel="noopener">git-tag</a></h3><blockquote>
<p>创建、删除、查看、校验标签</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e] &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br><span class="line">git tag -d &lt;tagname&gt;…​</span><br><span class="line">git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;]</span><br><span class="line">  [--points-at &lt;object&gt;] [--column[=&lt;options&gt;] | --no-column]</span><br><span class="line">  [--create-reflog] [--sort=&lt;key&gt;] [--format=&lt;format&gt;]</span><br><span class="line">  [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…​]</span><br><span class="line">git tag -v [--format=&lt;format&gt;] &lt;tagname&gt;…​</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l --list <span class="string">"v*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">"tagging version 1.0.0"</span></span><br><span class="line">git tag -a --force v1.0.0 -m <span class="string">"tagging version 1.0.0"</span></span><br><span class="line">git tag -a v1.0.0 --file=&lt;file&gt;</span><br><span class="line">git tag -a v1.0.0 &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>
<p>与分支不同，<code>git push</code> 默认不推送标签到远程，所以需要主动推送标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<p>同样，<code>git tag</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>，通常也不会直接操作远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;tag-name&gt;</span><br><span class="line">git push --delete v1.0.0</span><br></pre></td></tr></table></figure>
<p>清理 远程不能存在本地存在 的标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l | xargs git tag -d ; git fetch --tags</span><br></pre></td></tr></table></figure>
<p>标签并不像分支那样，存在远程标签/本地标签等区分，所以也不存在本地标签与远程标签之间的对应关系，自然也就不需要维护对应关系。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git-checkout"></a><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">git-checkout</a></h3><ul>
<li>切换分支并检出内容到工作区，也可创建分支</li>
</ul>
<p>检出已存在的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout    &lt;branch&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>创建并检出分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start-point&gt;]</span><br></pre></td></tr></table></figure>
<p>检出<code>tree-ish</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br></pre></td></tr></table></figure>
<p>检出内容到本地的时候会发生什么？</p>
<ol>
<li>本地是干净的，无任何修改</li>
<li>本地存在新增加的文件</li>
<li>本地存在修改后未提交的文件</li>
</ol>
<p>Ref：<a href="https://git-scm.com/docs/git-checkout#_detached_head" target="_blank" rel="noopener">DETACHED HEAD</a></p>
<p>HEAD 通常指向某一个分支，这一分支即是当前工作的分支。当 HEAD 不再指向分支的时候，仓库即处于 <code>DETACHED HEAD</code> 状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout ccdd28a</span><br><span class="line">Note: checking out <span class="string">'ccdd28a'</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by using -b with the checkout <span class="built_in">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at ccdd28a git update</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">HEAD detached at ccdd28a</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>处于这种状态下的仓库，如果进行修改并且提交，就会很危险，因为没有任何分支指向新的提交，当 <code>HEAD</code> 切换到其他位置的时候，当前的修改就不容易找不到了。</p>
<p>如果需要基于此节点进行修改，需要先基于此节点创建分支。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git-merge"></a><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noopener">git-merge</a></h3><blockquote>
<p>将两个或多个分支历史合并在一起</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br><span class="line">  [-q --quiet]</span><br><span class="line">  [-v --verbose]</span><br><span class="line">  [--[no-]progress]</span><br><span class="line">  [--commit] [--no-commit]</span><br><span class="line">  [-e | --edit] [--no-edit]</span><br><span class="line">  [-ff] [--no-ff] [--ff-only]</span><br><span class="line">  [--<span class="built_in">log</span>[=&lt;n&gt;]] [--no-log]</span><br><span class="line">  [-n] [--<span class="built_in">stat</span>] [--no-stat]</span><br><span class="line">  [--[no-]squash]</span><br><span class="line">  [--[no-]signoff]</span><br><span class="line">  [-s &lt;strategy&gt;] [--strategy=&lt;strategy&gt;]</span><br><span class="line">  [-X &lt;strategy-option&gt;] [--strategy-option=&lt;option&gt;]</span><br><span class="line">  [-S[&lt;keyid&gt;]] --gpg-sign[=&lt;keyid&gt;]</span><br><span class="line">  [--[no-]verify-signatures]</span><br><span class="line">  [--[no-]summary]</span><br><span class="line">  [--[no-]allow-unrelated-histories]</span><br><span class="line">  [--[no-]rerere-autoupdate]</span><br><span class="line">  [-m &lt;msg&gt;]</span><br><span class="line">  [&lt;commit&gt;…​]</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/11646107/you-have-not-concluded-your-merge-merge-head-exists</span><br><span class="line"></span><br><span class="line"><span class="comment"># git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present.</span></span><br><span class="line"><span class="comment"># 中断 merge，当发生冲突时，可以通过中断合并回到合并前的状态</span></span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续 merge，当发生冲突时，需要解决冲突，解决冲突后，继续执行合并</span></span><br><span class="line">git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>有如下版本库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge topic</span><br></pre></td></tr></table></figure>
<p>合并后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure>
<p>squash mode</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash topic</span><br><span class="line">git commit -m <span class="string">"message"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G---(ABC) master</span><br></pre></td></tr></table></figure>
<p><code>--squash</code> 效果相当于将 topic 分支上的多个 commit A-B-C 合并成一个 ABC，放在当前分支上，原来的 commit 历史则没有拿过来。</p>
<p>判断是否使用 <code>--squash</code> 选项最根本的标准是，待合并分支上的历史是否有意义。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p>
<p>只有在开发分支上每个 commit 都有其独自存在的意义，并且能够编译通过的情况下，才应该选择缺省的合并方式来保留 commit 历史。</p>
<p>fast forward mode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --ff topic</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic master</span><br><span class="line">             /</span><br><span class="line">D---E---F---G</span><br></pre></td></tr></table></figure>
<p>合并的前提是：准备合并的两个 <code>commit</code> 不在一条直线上，在一条直线上可以进行快速前进，也可以使用 <code>--no-ff</code> 强制合并（无意义）。</p>
<p>合并的过程中需要处理可能得冲突，未冲突的文件将会进行自动合并，在新版本的<code>tree</code>中产生一个新版本的<code>blob</code>，所以Git能够完整检出不需要依赖历史中的<code>commit</code>，只需要当前的<code>commit</code>。</p>
<p>合并的结果是：产生一个新的 <code>commit</code>，实际上，<code>squash mode</code> <code>fast forward mode</code> 并不是真正意义上的合并。</p>
<p>冲突：</p>
<p>冲突有两种类型，一种是树冲突，修改/删除同一文件，另一种是文件冲突，修改了同一文件中的相同内容。</p>
<p>冲突是如何判断的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<p>假如有文件 <code>README.md</code> 在 <code>E</code>，且 <code>topic</code> 和 <code>master</code> 都有修改此文件，合并 <code>topic</code> 到 <code>master</code> 时，冲突检查的依据不是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 是否相同，而是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 相对于 <code>E</code> 的变化。即使是 <code>README.md</code> 文件在被修改后的内容是相同的，也会产生冲突。而冲突产生的文件，就是将 相对于 <code>E</code>，都合并到同一个文件中，并交由用户解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">=======</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt</span><br></pre></td></tr></table></figure>
<p>最佳实践：</p>
<ol>
<li>尽量避免在本地使用 <code>merge</code>，也尽量避免在本地发生 <code>Merge</code>。</li>
<li><code>merge</code> 时，本地不要有未提交的更改，这些修改可能会在中断合并时丢失。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><blockquote>
<p>添加文件到索引中，为下一次提交准备内容。</p>
</blockquote>
<p>将工作区的修改添加到暂存区中，此命令使用在工作树中找到的最新内容更新索引，以准备为下次提交暂存内容。</p>
<p>典型的情况下，将整个文件添加到暂存区中，通过特定的选项，也可以将工作区修改的部分内容加到暂存区中。</p>
<p>暂存区保存工作树内容的快照，并将此快照作为下一次提交的内容。因此，在对工作树进行任何更改之后，在运行commit命令之前，必须使用add命令将任何新的或修改的文件添加到索引中。</p>
<p>默认情况下，<code>git add</code> 不会添加忽略的文件，<code>git add -f</code> 会进行强制添加。</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><blockquote>
<p>从工作区和暂存区移除文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…​</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm *.txt</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm *.txt</span><br><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>
<p>仅从暂存区删除内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached *.txt</span><br></pre></td></tr></table></figure>
<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><blockquote>
<p>重命名或移动文件，同步更新暂存区</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv &lt;options&gt;…​ &lt;args&gt;…​</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; &lt;destination&gt;</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; ... &lt;destination directory&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name new_name            <span class="comment"># 重命名</span></span><br><span class="line">git mv -f old_name new_name         <span class="comment"># 强制重命名，即时目标名称已经存在</span></span><br><span class="line">git mv -k old_name new_name         <span class="comment"># 跳过会导致错误的动作</span></span><br><span class="line">git mv -v old_name new_name         <span class="comment"># 报告被移动文件</span></span><br><span class="line">git mv --dry-run old_name new_name  <span class="comment"># 只显示将会发生什么</span></span><br></pre></td></tr></table></figure>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><blockquote>
<p>Show changes between commits, commit and working tree, etc</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment"># 查看尚未暂存的文件更新了哪些部分，不加参数直接输入。</span></span><br><span class="line">git diff --cached       <span class="comment"># 查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异</span></span><br><span class="line">git diff --staged       <span class="comment"># 显示的是下一次 commit 时会提交到HEAD的内容(不带-a情况下)</span></span><br><span class="line">git diff HEAD           <span class="comment"># 显示工作版本(Working tree)和HEAD的差别</span></span><br><span class="line">git diff topic master   <span class="comment"># 直接将两个分支上最新的提交做diff</span></span><br><span class="line">git diff topic...master <span class="comment"># 输出自 topic 和 master 分别开发以来，master 分支上的 changed。</span></span><br><span class="line">git diff --<span class="built_in">stat</span>         <span class="comment"># 查看简单的diff结果，可以加上--stat参数</span></span><br><span class="line">git diff <span class="built_in">test</span>           <span class="comment"># 查看当前目录和另外一个分支的差别 显示当前目录和另一个叫 test 分支的差别</span></span><br><span class="line">git diff HEAD -- ./lib  <span class="comment"># 显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下）</span></span><br><span class="line">git diff HEAD^ HEAD     <span class="comment"># 比较上次提交commit和上上次提交</span></span><br><span class="line">git diff SHA1 SHA2      <span class="comment"># 比较两个历史版本之间的差异</span></span><br></pre></td></tr></table></figure>
<p><a href="https://en.wikipedia.org/wiki/Diff_utility" target="_blank" rel="noopener">Diff_utility</a></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><blockquote>
<p>Record changes to the repository</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit                          <span class="comment"># 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</span></span><br><span class="line">git commit -a                       <span class="comment"># 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。</span></span><br><span class="line">git commit -a -m <span class="string">'commit info'</span>      <span class="comment"># 注释，如果没有 -m，会默认会使用vi编辑注释。</span></span><br><span class="line">git commit -am <span class="string">"This is a commit"</span>   <span class="comment"># 同上，合并提交，将 add 和 commit 合为一步</span></span><br><span class="line">git commit --amend                  <span class="comment"># 对上一次提交进行修改，合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit --amend -a               <span class="comment"># 提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交</span></span><br><span class="line">git commit --author=&lt;author&gt;        <span class="comment"># 设置作者，与提交者分开</span></span><br><span class="line">git commit --file=&lt;file&gt;            <span class="comment"># 注释从文件中读取</span></span><br></pre></td></tr></table></figure>
<p>对于 commit 来说，最重要的是，每一次 commit 都应该是一个完整的提交，而且应该有个规范清晰的注释。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><blockquote>
<p>显示工作树状态</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status     <span class="comment"># 显示状态</span></span><br><span class="line">git status -s  <span class="comment"># 显示简短信息</span></span><br><span class="line">git status -b  <span class="comment"># 显示分支状态</span></span><br></pre></td></tr></table></figure>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><blockquote>
<p>重置工作区，将当前分支回退到某一节点</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>
<p><code>git reset</code> 会修改当前分支头从某一个 <code>&lt;commit-id&gt;</code> 移动到另外的一个指定的 <code>&lt;commit-id&gt;</code></p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              HEAD</span><br><span class="line">              ↓</span><br><span class="line">              topic</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<p>当前活跃的分支是 <code>topic</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset A</span><br></pre></td></tr></table></figure>
<p>执行以上操作后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      HEAD</span><br><span class="line">      ↓</span><br><span class="line">      topic</span><br><span class="line">      ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>
<p>此时，<code>HEAD -&gt; topic -&gt; A</code>，B、C 此时处于悬挂状态，如同普通的对象一样，没有任何引用后，会被 Git GC 回收。</p>
<p>执行此操作后，B、C 两点虽然依然存在于仓库中，但是它们已经逻辑上脱离了Git。</p>
<p>此时，B、C 两点提交的内容怎么办？是不是就丢失了呢？</p>
<p>Git 给了我们多种选择：</p>
<ul>
<li>–soft，B、C 提交的内容不会回到工作区和暂存区。因为当前工作区内容是基于 C 修改的，所以实际上并无内容丢失。</li>
<li>–mixed，B、C 提交的内容回到暂存区，但是工作区内容不变，也就是某些文件处于 <code>修改未提交状态</code>。同上，也无内容丢失。</li>
<li>–hard，B、C 提交的内容不会回到工作区和暂存区，同时暂存区和工作区回到A点状态，B、C 提交的内容以及工作区后续的修改全部丢失。</li>
</ul>
<p>如果 <code>reset</code> 误操作操作怎么办？</p>
<ol>
<li><p>如果存在上游分支，可以通过上游分支恢复</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset master^2</span><br><span class="line">git reset origin/master</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过 <code>reflog</code> 恢复</p>
<p> <code>reflog</code> 记录 HEAD 的变化，所以可以通过 <code>reflog</code> 找到 <code>reset</code> 之前的 <code>HEAD</code> 的位置，但是前提是后续节点未被垃圾回收。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">58c1d5d (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: update git</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;1&#125;: checkout: moving from <span class="built_in">test</span> to master</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;2&#125;: checkout: moving from master to <span class="built_in">test</span></span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;3&#125;: commit: git update</span><br><span class="line">e081fb3 HEAD@&#123;4&#125;: commit: update python</span><br><span class="line">d26f671 HEAD@&#123;5&#125;: commit: update</span><br><span class="line">33db13f HEAD@&#123;6&#125;: commit (amend): update and format</span><br><span class="line">5c41033 HEAD@&#123;7&#125;: commit: update and format</span><br><span class="line">e56ec4e HEAD@&#123;8&#125;: commit: 移除乱码字符</span><br><span class="line">6595b95 HEAD@&#123;9&#125;: commit: feat(): add hexo.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>未提交的内容是很难就行恢复的，所有在进行 <code>reset</code> 操作时，要将工作区的内容提交。</p>
<p>reset 除了将工作区回退到某个节点之外，常用的应用就是将后续的多个提交合并为一个提交，因为后续提交的内容可以回到暂存区或工作区中。</p>
<p>在某些Git工作流中，要求将多个提交合并成一个之后才能合并到上游分支。</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git revert --<span class="built_in">continue</span></span><br><span class="line">git revert --quit</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~3</span><br><span class="line">git revert -n master~5..master~2</span><br></pre></td></tr></table></figure>
<p><code>git revert</code> 用于撤销一个或多个提交，并建立一个新的提交。<code>commit</code> 中所做的修改都会被移除掉，相当于 <code>commit</code> 反向操作。</p>
<p><code>git revert</code> 通常用户快速回滚。</p>
<p>示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            HEAD</span><br><span class="line">            ↓</span><br><span class="line">            master</span><br><span class="line">            ↓</span><br><span class="line">A---B---C---D</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert C</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                HEAD</span><br><span class="line">                ↓</span><br><span class="line">                master</span><br><span class="line">                ↓</span><br><span class="line">A---B---C---D---C<span class="string">'</span></span><br></pre></td></tr></table></figure>
<p><code>C&#39;</code> 是一个全新的 <code>Commit</code> 与 <code>C</code> 是不同的，但是这种情况下，<code>C&#39;</code> 与 <code>C</code> 中的 <code>tree</code> 是相同的。</p>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><blockquote>
<p>变基操作，基指的是起始提交，即参数中常见的 <start-point></start-point></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;]</span><br><span class="line">git rebase --<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突之后继续 rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过</span></span><br><span class="line">git rebase --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断 rebase</span></span><br><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C ← topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A&apos;--B&apos;--C&apos; ← topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>
<p>以上，通过变基操作，将topic分支的 <start-point> 从 <code>E</code> 调整到了 <code>G</code>。</start-point></p>
<p>变基操作的原理：将 A B C 基于 G 重新提交，提交的过程可能与 F G 存在冲突，需要解决冲突。</p>
<p>变基操作的应用：</p>
<ol>
<li>保持与上游分支同步，同步上游分支的最新版本</li>
<li>合并时存在冲突，通过变基操作解决冲突</li>
</ol>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>源文件地址：<a href="https://github.com/liuyanjie/knowledge/tree/master/vcs/git/git-working-mechanism.md" target="_blank" rel="noopener">https://github.com/liuyanjie/knowledge/tree/master/vcs/git/git-working-mechanism.md</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/GIT/">GIT</a>►<a class="article-category-link" href="/categories/GIT/VCS/">VCS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GIT/">GIT</a><a href="/tags/Git命令/">Git命令</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="/posts/Git深入理解-命令工作机制/" data-title="Git深入理解-命令工作机制 | lyj&#39;s blog" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/posts/Git学习资料整理/" title="Git学习资料整理">
  <strong>上一篇：</strong><br>
  <span>
  Git学习资料整理</span>
</a>
</div>


<div class="next">
<a href="/posts/Git深入理解-对象模型/" title="Git深入理解-对象模型">
 <strong>下一篇：</strong><br> 
 <span>Git深入理解-对象模型
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#仓库创建"><span class="toc-number">1.</span> <span class="toc-text">仓库创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Init"><span class="toc-number">1.1.</span> <span class="toc-text">Init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone"><span class="toc-number">1.2.</span> <span class="toc-text">Clone</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#仓库维护"><span class="toc-number">2.</span> <span class="toc-text">仓库维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RefSpec"><span class="toc-number">2.1.</span> <span class="toc-text">RefSpec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-remote"><span class="toc-number">2.2.</span> <span class="toc-text">git remote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-fetch"><span class="toc-number">2.3.</span> <span class="toc-text">git fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-pull"><span class="toc-number">2.4.</span> <span class="toc-text">git pull</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-push"><span class="toc-number">2.5.</span> <span class="toc-text">git push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-submodule"><span class="toc-number">2.6.</span> <span class="toc-text">git submodule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分支管理"><span class="toc-number">3.</span> <span class="toc-text">分支管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-branch"><span class="toc-number">3.1.</span> <span class="toc-text">git-branch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-tag"><span class="toc-number">3.2.</span> <span class="toc-text">git-tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-checkout"><span class="toc-number">3.3.</span> <span class="toc-text">git-checkout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-merge"><span class="toc-number">3.4.</span> <span class="toc-text">git-merge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本操作"><span class="toc-number">4.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-add"><span class="toc-number">4.1.</span> <span class="toc-text">git add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rm"><span class="toc-number">4.2.</span> <span class="toc-text">git rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-mv"><span class="toc-number">4.3.</span> <span class="toc-text">git mv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-diff"><span class="toc-number">4.4.</span> <span class="toc-text">git diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-commit"><span class="toc-number">4.5.</span> <span class="toc-text">git commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-status"><span class="toc-number">4.6.</span> <span class="toc-text">git status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-reset"><span class="toc-number">4.7.</span> <span class="toc-text">git reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-revert"><span class="toc-number">4.8.</span> <span class="toc-text">git revert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rebase"><span class="toc-number">4.9.</span> <span class="toc-text">git rebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-cherry-pick"><span class="toc-number">4.10.</span> <span class="toc-text">git cherry-pick</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/GIT/" title="GIT">GIT<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Language/JavaScript/" title="JavaScript">JavaScript<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Language/" title="Language">Language<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/GIT/VCS/" title="VCS">VCS<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/GIT/" title="GIT">GIT<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Git命令/" title="Git命令">Git命令<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/GIT对象模型/" title="GIT对象模型">GIT对象模型<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript基础/" title="JavaScript基础">JavaScript基础<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript执行上下文/" title="JavaScript执行上下文">JavaScript执行上下文<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://blog.xizhibei.me" target="_blank" title="须臾之学">须臾之学</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/GIT/" style="font-size: 20px;">GIT</a> <a href="/tags/GIT对象模型/" style="font-size: 10px;">GIT对象模型</a> <a href="/tags/Git命令/" style="font-size: 15px;">Git命令</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript基础/" style="font-size: 10px;">JavaScript基础</a> <a href="/tags/JavaScript执行上下文/" style="font-size: 10px;">JavaScript执行上下文</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	
	<section class="info">
		<p> Not every technical problems should be resolved through technical means. <br>
			Fighting</p>
	</section>
	 
	<div class="social-font">
		
		
		<a href="https://github.com/liuyanjie" target="_blank" class="icon-github" title="github"></a>
		
		
		<a href="http://stackoverflow.com/users/5954388" target="_blank" class="icon-stack-overflow" title="stackoverflow"></a>
		
		
		
		
		
		
		
		<a href="https://plus.google.com/101963751496807079381?rel=author" target="_blank" class="icon-google_plus" title="Google+"></a>
		
		
		<a href="mailto:liuyj619@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc.svg" alt="Creative Commons">
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="lyj">lyj</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'liuyanjie';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>








<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-131498998-1', '');  
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4cd57e104d0d9f5862dd91d0acdb9eee";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
