<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png">
  <link rel="mask-icon" href="/favicon.png" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;blog.butonly.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:true,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;algolia&quot;:{&quot;appID&quot;:&quot;FRAAR0AUP0&quot;,&quot;apiKey&quot;:&quot;459ace1d7f5aabfa15b4f89baba340b3&quot;,&quot;indexName&quot;:&quot;blog.butonly.com&quot;,&quot;hits&quot;:{&quot;per_page&quot;:10}}}</script>
<meta name="description" content="KISS DRY">
<meta property="og:type" content="website">
<meta property="og:title" content="liuyanjie&#39;s blog">
<meta property="og:url" content="https://blog.butonly.com/index.html">
<meta property="og:site_name" content="liuyanjie&#39;s blog">
<meta property="og:description" content="KISS DRY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liuyanjie">
<meta property="article:tag" content="个人博客,技术分享,前端,后端,容器,架构">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.butonly.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>liuyanjie's blog</title><script src="/js/config.js"></script>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=014348069229275019795:-z92dm0sjiy"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;014348069229275019795:-z92dm0sjiy&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?4cd57e104d0d9f5862dd91d0acdb9eee"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="liuyanjie's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liuyanjie's blog</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/logo.png" alt="liuyanjie's blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">10</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">5</span></a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liuyanjie"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">liuyanjie</p>
  <div class="site-description" itemprop="description">KISS DRY</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liuyanjie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuyanjie" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/liuyj619@gmail.com" title="E-Mail → liuyj619@gmail.com"><i class="envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/butonly" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/vcs/git/git-working-mechanism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/vcs/git/git-working-mechanism/" class="post-title-link" itemprop="url">Git命令工作机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-24 12:00:00" itemprop="dateCreated datePublished" datetime="2019-06-24T12:00:00+08:00">2019-06-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-23 13:15:53" itemprop="dateModified" datetime="2021-05-23T13:15:53+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/vcs/git/git-working-mechanism/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/vcs/git/git-working-mechanism/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Git 是当前最广泛使用的版本控制系统，具备非常强大的版本控制能力。Git 有非常多的命令，很多人被种类繁多的命令搞的非常头大，也会经常忘记。本文尝试从原理角度来介绍 Git 常用命令，以便于加深对 Git 原理的理解。只有理解了原理，才能知道这些命令到底对仓库做了什么，进而才能更好使用命令，也更加不容易忘记。作为一个版本控制系统，理解其原理也是十分必要的，否则，很多命令根本不敢用，用错了可能会造成严重后果，搞丢代码的成本是非常大的，谁都不想自己或他人做工作被一键抹除。知道原理后，即使一不小心操作错了，也可以坦然处之，轻松恢复。</p>
<p>相比命令行工具，可视化的 GUI 就要直观和方便很多，但是很多时候一样可能因为对于具体做什么不了解而操作错误，并且，目前常用的 GUI 软件，都未提供全部的命令行操作能力，GUI 很多时候，也没有命令方便快捷。</p>
<h2 id="仓库概述"><a href="#仓库概述" class="headerlink" title="仓库概述"></a>仓库概述</h2><p>Git 是一个分布式的版本控制系统，不同于 <strong>svn</strong> 只有一个<strong>中心仓库</strong>，必须能连接到 svn 服务才能提交，Git 可以随时提交而不依赖于中心仓库，因为本地存在一个独立的仓库，完全支持离线操作。本地仓库和远程仓库是一种比较松散的关系。</p>
<p>Git 中，每个仓库可以存在多个仓库副本，这个仓库暂且称为 “原始仓库”，“原始仓库” 因为需要备份或协作等方面的需要通常存储在托管服务器上。</p>
<p><strong>仓库副本</strong>通常是通过 <code>clone</code> 或 <code>Fork</code>（本质其实也是<code>clone</code>） 创建的，仓库副本和原始仓库是<strong>上下游</strong>关系，这些副本仓库可能在本地，也可能在某台服务器上。</p>
<p><strong>原始仓库</strong>如果托管在托管服务器上，通过 <code>Fork</code> 的方式可以创建很多位于托管服务上的副本，这些副本在不同的账户下，<code>Fork</code> 并不是 Git 提供的，而是托管服务提供的。<code>Fork</code> 出来的仓库副本与原始仓库之间的关系也由托管服务记录和维护的，这些副本仓库都有一个相同的 <code>上游仓库</code>（即原始仓库），同时副本仓库也可以继续被 <code>Fork</code> 产生多个 <code>下游仓库</code>，下游仓库可以通过 <code>PullRequest/MergeRequest</code> 向上游仓库发起跨仓库的 <code>merge</code> 请求，进行仓库间的交互。这些位于托管服务上的仓库，不论是原始仓库还是<code>Fork</code>出来的副本仓库，都可以被 <code>clone</code> 到本地创建本地仓库，本地仓库也是一个副本。</p>
<p><strong>本地仓库</strong>可以是<strong>原始仓库</strong>的副本，也可以是<strong>原始仓库</strong>的某副本的副本，相对于本地仓库，这些仓库称之为<strong>远程仓库</strong>，本地版本库可以同时对应多个远程仓库。本地仓库通过 <code>push</code>、<code>fetch</code> 等命令和远程仓库同步。</p>
<p>通过前面的描述，引申出了几个概念：原始仓库 &lt;-&gt; 副本仓库、上游仓库 &lt;-&gt; 下游仓库、远程仓库 &lt;-&gt; 本地仓库，这些概念都是相对而言的，便于进行角色区分。</p>
<p>仓库间的交互：</p>
<ol>
<li>远程仓库 和 本地仓库 之间，主要进行的是同步，本地修改同步到远程，或远程同步到本地。</li>
<li>远程仓库 和 远程仓库 之间，主要进行的是跨仓库的分支合并，也就是 <code>PullRequest/MergeRequest</code>。</li>
</ol>
<p>在未使用 <code>Fork</code> 的模式中，就没有 <code>2</code> 这种情况了。</p>
<p>本地仓库主要用来完成内容变更，远程仓库主要用来完成多人协作与数据备份。</p>
<p>托管服务上，<code>Fork</code> 创建的仓库副本关系如下：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">base</span>/<span class="built_in">Base</span></span><br><span class="line">├──── user_a1/<span class="built_in">Base</span></span><br><span class="line">├──── user_a2/<span class="built_in">Base</span></span><br><span class="line">├──── user_a3/<span class="built_in">Base</span></span><br><span class="line">├──── user_a4/<span class="built_in">Base</span></span><br><span class="line">│     ├─── user_b1/<span class="built_in">Base</span></span><br><span class="line">│     └─── user_b2/<span class="built_in">Base</span></span><br><span class="line">└──── user_a5/<span class="built_in">Base</span></span><br></pre></td></tr></table></figure>

<p>这些仓库都可被有权限的用户 <code>pull</code> 本地仓库，并正在修改之后 <code>push</code> 远程仓库。</p>
<p>为什么需要 <code>Fork</code>？</p>
<ol>
<li>避免分配原始仓库的访问权限给无关用户，防止仓库被破坏</li>
<li>本地仓库无法直接 Merge 到远程仓库，远程副本仓库能够提供了合并到原始仓库的能力</li>
<li>合并需要发起 <code>PullRequest/MergeRequest</code> 提供了代码审核的窗口</li>
</ol>
<p>Git 的单个仓库的工作原理是比较简单的，但是当多个不同角色的仓库同时存在协同工作的时候，确实非常复杂的，有非常多的玩法。只有真正的理解内部原理，方能运用自如。</p>
<p>Git 的命令是建立在这些底层模型上的，命令也正是为处理并维护这些关系而设计的。所以也只要有理解原理，才能熟练运用这些命令。</p>
<p>下面开始进入正题。</p>
<h2 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h2><p>任何操作开始前，首先要有个一个仓库。</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-init">Init</a></h3><p>核心功能：</p>
<ol>
<li>创建一个新的空 Git 仓库，或者重新初始化一个已经存在的 Git 仓库。</li>
</ol>
<p>常规方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git init workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/workspace/.git/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">└── workspace</span><br><span class="line">    └── .git</span><br><span class="line">        ├── refs</span><br><span class="line">        │   ├── tags</span><br><span class="line">        │   └── heads</span><br><span class="line">        ├── objects</span><br><span class="line">        │   ├── pack</span><br><span class="line">        │   └── info</span><br><span class="line">        ├── info</span><br><span class="line">        │   └── exclude</span><br><span class="line">        ├── hooks</span><br><span class="line">        │   ├── update.sample</span><br><span class="line">        │   ├── prepare-commit-msg.sample</span><br><span class="line">        │   ├── pre-receive.sample</span><br><span class="line">        │   ├── pre-rebase.sample</span><br><span class="line">        │   ├── pre-push.sample</span><br><span class="line">        │   ├── pre-commit.sample</span><br><span class="line">        │   ├── pre-applypatch.sample</span><br><span class="line">        │   ├── post-update.sample</span><br><span class="line">        │   ├── fsmonitor-watchman.sample</span><br><span class="line">        │   ├── commit-msg.sample</span><br><span class="line">        │   └── applypatch-msg.sample</span><br><span class="line">        ├── description</span><br><span class="line">        ├── config</span><br><span class="line">        └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 15 files</span><br></pre></td></tr></table></figure>

<p>以上创建的仓库，仓库文件 存放在 工作区目录 <code>workspace</code> 的子目录 <code>.git</code> 下。</p>
<p>分离的方式创建一个仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git init --separate-git-dir=.tig workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/.tig/</span><br><span class="line"></span><br><span class="line">$ tree -ar</span><br><span class="line">.</span><br><span class="line">├── workspace</span><br><span class="line">│   └── .git</span><br><span class="line">└── .tig</span><br><span class="line">    ├── refs</span><br><span class="line">    │   ├── tags</span><br><span class="line">    │   └── heads</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── pack</span><br><span class="line">    │   └── info</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── update.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   └── applypatch-msg.sample</span><br><span class="line">    ├── description</span><br><span class="line">    ├── config</span><br><span class="line">    └── HEAD</span><br><span class="line"></span><br><span class="line">10 directories, 16 files</span><br><span class="line"></span><br><span class="line">$ cat workspace/.git</span><br><span class="line">gitdir: /Users/liuyanjie/git-learn/.tig</span><br></pre></td></tr></table></figure>

<p>从上面的目录结构可以看到，相比常规方式创建仓库，通过分离的方式创建的仓库将 <code>仓库(.git)</code> 从 <code>工作区目录(workspace)</code> 中分离出去。<code>仓库(.git)</code> 不再是一个目录，而是包含指向仓库路径的一个文件，实际上利用这一特性，可以创建多个工作区共享同一仓库，也就可以支持同一个仓库拥有多个工作区。</p>
<p>另外也可以通过环境变量 <code>GIT_DIR=path/to/repo.git</code> 指定 <code>仓库(.git)</code> 的路径，下面这种方式和上面的方式是等价的（注意：相对路径不同）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_DIR=../.tig git init workspace</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/.tig/</span><br></pre></td></tr></table></figure>

<p>不仅如此，Git 还支持将 Objects 从 <code>仓库(.git)</code> 中移出，通过 <code>GIT_OBJECT_DIRECTORY=$GIT_DIR/objects</code> Git 对象存储路径，不过这种用法在本地很少见。</p>
<p>有兴趣可以用以下命令做实验：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_OBJECT_DIRECTORY=../objects GIT_DIR=../.tig git init workspace</span><br></pre></td></tr></table></figure>

<p>默认情况下，仓库在创建的过程中，拷贝了一些的模版文件到 <code>仓库(.git)</code> 目录下，默认的模版路径和文件示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ tree /usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/git/2.18.0/share/git-core/templates</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">└── info</span><br><span class="line">    └── exclude</span><br><span class="line"></span><br><span class="line">2 directories, 13 files</span><br></pre></td></tr></table></figure>

<p>可以看到，模版目录里面的内容，和实际仓库的内容相同的，用模版创建仓库时，就是原封不动的将仓库内容拷贝到仓库目录下。<br>基于这一点，我们可以以一个已经存在的仓库作为模版，创建另一个仓库，Git 会把模板路径下的文件的拷贝到新的仓库下。</p>
<p>可以在运行的时候通过 <code>--template=</code> 或 <code>GIT_TEMPLATE_DIR</code> 环境变量 或 <code>init.templateDir</code> 配置 指定模版路径位置。</p>
<p>还可以通过 <code>git init --bare</code> 参数创建一个裸仓库，裸仓库的指没有工作区的仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git init --bare          </span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-learn/</span><br><span class="line"></span><br><span class="line"><span class="comment"># liuyanjie @ bogon in /Users/liuyanjie/git-learn on git:master o [16:48:01] </span></span><br><span class="line">$ ls</span><br><span class="line">HEAD        config      description hooks       info        objects     refs</span><br></pre></td></tr></table></figure>

<p>因为无工作区，仓库文件直接放在当前目录下了，可以手动创建工作区并链接到仓库目录。</p>
<p>在一个已经存在的仓库目录中运行 <code>init</code> 命令是安全的，它不会覆盖原来已经存在的文件（包括仓库和工作区）。<br>重新运行 <code>init</code> 的可以用来安装新添加的模版，或者用来将仓库分离到其他的位置。</p>
<p>新创建的仓库的仓库配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">	<span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line">	<span class="attr">filemode</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">ignorecase</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">precomposeunicode</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>只有 <code>core</code> 相关的几个配置项。</p>
<p>通过以上对命令及参数的效果的参考，可以了解到 Git 文档中不为人知的一些内容。</p>
<p>初始化仓库是 Git 工作流中的第一步，通常发生在本地，在托管服务创建仓库之后，仓库并未初始化，需要在本地创建并初始化仓库后，同步到远程，然后再同步本地。</p>
<p>通常情况下，都是需要两个仓库的，一个本地仓库，一个远程仓库，以支持复杂的开发工作流。</p>
<h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone">Clone</a></h3><p>核心功能：</p>
<ol>
<li>初始化并配置仓库，记录本地仓库和远程仓库的对应关系，包括仓库和分支映射关系<ol>
<li>克隆仓库到一个新的目录，实际上就是 <code>git init</code></li>
<li>为每一个被克隆仓库中的分支创建对应的远程追踪分支</li>
<li>从克隆仓库的当前活动分支创建并检出初始分支到工作区目录</li>
</ol>
</li>
<li>同步仓库<ol>
<li>通过 <code>git fetch</code> 更新所有远程追踪分支</li>
<li>通过 <code>git pull</code> 合并远程 <code>master</code> 分支到本地 <code>master</code> 分支，快速合并</li>
</ol>
</li>
</ol>
<p>类似于如下过程：</p>
<p><code>git init</code> -&gt; <code>git remote set-url origin git://...</code> -&gt; <code>git fetch</code> -&gt; <code>git pull</code> -&gt; <code>git checkout HEAD</code></p>
<p>通过以上核心功能可以看到，<code>Clone</code> 实际上是对多个命令功能的组合，并进行了一些配置工作。这样我们可以猜测，<code>Clone</code> 命令的很多参数应该是从其他命令继承过来的。</p>
<p>克隆一个远程仓库需要存在一个远程仓库，并且有一个可以访问的远程仓库的地址，Git支持多种访问协议，最常见的如 <code>git://</code> 和 <code>https://</code>。<br>详见：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a">GIT-URLS</a></p>
<p>下面是一个常见的 <code>clone</code> 操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/spec.git</span><br><span class="line">Cloning into <span class="string">&#x27;spec&#x27;</span>...</span><br><span class="line">remote: Counting objects: 49, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 49 (delta 0), reused 0 (delta 0), pack-reused 49</span><br><span class="line">Receiving objects: 100% (49/49), 49.83 KiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (15/15), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>通过输出内容可以看到，<code>Clone</code> 主要都做了哪些事情，可以对比上面的过程描述。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat spec/.git/config</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	url = git@github.com:liuyanjie/spec.git</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">&quot;master&quot;</span>]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/master</span><br></pre></td></tr></table></figure>

<p><code>git clone</code> 之后的仓库配置中，可以看到多出了以上内容，配置了对应的远程仓库地址及追踪关系，配置了本地 <code>master</code> 对应的远程分支，该配置为 Git 默认配置，一般不需要修改。</p>
<p>常见用法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆本地仓库 默认是硬链接的，关闭需要加 --no-hardlinks</span></span><br><span class="line">git <span class="built_in">clone</span> path/to/<span class="built_in">local</span>/git/repository</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Counting objects: 495, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (141/141), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库 只克隆最后一个Commit提速</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:liuyanjie/knowledge.git --depth=1</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Counting objects: 300, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (247/247), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆远程仓库 只克隆最后一个Commit提速，并通过另外一个仓库加速</span></span><br><span class="line">$ git <span class="built_in">clone</span> \</span><br><span class="line">  --depth=1 \</span><br><span class="line">  --reference-if-able=/Volumes/Data/Data/ws/knowledge \</span><br><span class="line">  git@github.com:liuyanjie/knowledge.git</span><br><span class="line">Cloning into <span class="string">&#x27;knowledge&#x27;</span>...</span><br><span class="line">remote: Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>

<p>在 <code>Clone</code> 的过程中，通过一些参数可以有效的减少 <code>Clone</code> 的等待时间，如在 CI 的构建流程中，可以提高构建时间。</p>
<p>了解 <code>git clone</code> 命令的实际工作流程，能够了解 <code>clone</code> 的过程做了什么以及能做到什么，日常使用也用不到很多复杂的操作，关于更多的命令参数，可自行通过文档了解。</p>
<h2 id="仓库同步"><a href="#仓库同步" class="headerlink" title="仓库同步"></a>仓库同步</h2><p>因为 Git 是一个分布式的版本控制系统，同时存在多个仓库副本，仓库副本之间的同步是非常重要的一环。不同于许多分布式系统（例如分布式数据库）能够自动完成节点间的数据同步，Git 无法自动的完成仓库同步，所以仓库同步完全依赖于使用者自行通过各类操作界面完成。</p>
<p>数据同步的内容主要有：分支、标签、数据等内容</p>
<p>数据同步基于 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec">RefSpec</a> ，它描述了本地仓库与远程仓库间分支和标签的映射关系及同步策略。</p>
<p>下面示例中 <code>+refs/heads/*:refs/remotes/origin/*</code> 即为 <code>RefSpec</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p><code>Ref</code></p>
<p>示例中的 <code>RefSpec</code> 表明：远程仓库中所有分支 <code>refs/heads/*</code>，对应到本地仓库下所有分支 <code>refs/remotes/origin/*</code>，分支名称不变。如果需要改变分支名称，则需要配置针对分支特定的 <code>RefSpec</code>。</p>
<p>在了解 <code>RefSpec</code> 之前，需要先了解下 <code>Ref</code>：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-References">Git 内部原理 - Git References</a></p>
<p>如同描述的一样，<code>RefSpec</code> 描述了 <code>remote-refs</code> 和 <code>local-refs</code> 的对应关系。</p>
<p>RefSpec 写法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">+refs/heads/master:master</span><br><span class="line">+master:refs/remotes/origin/master</span><br><span class="line">master:master</span><br><span class="line">:master</span><br><span class="line">master:</span><br></pre></td></tr></table></figure>

<p><code>RefSpec</code> 的格式是一个可选的 <code>+</code> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code> 是远程仓库的引用格式，<code>&lt;dst&gt;</code> 是将要记录在本地仓库的引用格式。可选的 <code>+</code> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它，也就是与远程保持强一致的同步。</p>
<p>从远程仓库获取指定数据到本地仓库，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branch master &lt;==&gt; +refs/heads/master:+refs/remotes/origin/master</span><br><span class="line">branch    A:a &lt;==&gt; +refs/heads/A:+refs/remotes/origin/a</span><br><span class="line">tag     &lt;tag&gt; &lt;==&gt; +refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">        ...</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">$ tree .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">├── heads</span><br><span class="line">│   ├── feature</span><br><span class="line">│   │   └── travis-ci</span><br><span class="line">│   └── master</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       ├── feature</span><br><span class="line">│       │   └── travis-ci</span><br><span class="line">│       └── master</span><br><span class="line">└── tags</span><br><span class="line">    └── v0.0.0</span><br></pre></td></tr></table></figure>

<p>以上对应关系：</p>
<table>
<thead>
<tr>
<th>local-branch@local</th>
<th>remote-branch@local</th>
<th>remote-branch@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p>表格中，只描述了存在一个远程仓库 <code>origin</code> 的情形，实际上是可能存在多个远程仓库的。</p>
<p>注意：<code>RefSpec</code> 描述了 <code>remote-branch@local</code> 和 <code>remote-branch@remote</code> 之间的对应关系，并不是 <code>local-branch@local</code> 和 <code>remote-branch@remote</code> 之间的关系，它们之间的存在的追踪关系在其他配置项中描述。</p>
<p><code>local-branch@local</code> 下的 分支，是在本地存在的分支，可能从远程某个分支 <code>checkout</code>，也可能是本地新建的。</p>
<p><code>RefSpec</code> 可以应用在命令行中，但是一般不会出现在命令行中，而是由某些命令自动写在配置文件中，并在某些命令执行时自动应用配置。</p>
<p>例如：<code>git remote add remote-name</code>，Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/remote-name</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote add liuyanjie git@github.com:liuyanjie/knowledge.git</span><br><span class="line"></span><br><span class="line">$ cat .git/config</span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"></span><br><span class="line">[remote <span class="string">&quot;liuyanjie&quot;</span>]</span><br><span class="line">        url = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/liuyanjie/*</span><br></pre></td></tr></table></figure>

<p>以下几种方式是等价的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master</span><br><span class="line">git <span class="built_in">log</span> heads/master</span><br><span class="line">git <span class="built_in">log</span> refs/heads/master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> origin/master</span><br><span class="line">git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>通常都是使用省略 <code>refs/heads/</code> 和 <code>refs/remotes/</code> 的形式。</p>
<p>以上示例中 <code>RefSpec</code> 中包含 <code>*</code> 会使 Git 拉取所有远程分支到本地，如果想让Git只拉取固定的分支，可以将 <code>*</code> 修改为指定的分支名。</p>
<p>也可以在命令行上指定多个 <code>RefSpec</code>，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure>

<p>同样，也可以将以上命令行中的 <code>RefSpec</code> 写入配置中：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">       <span class="attr">url</span> = git@github.com:liuyanjie/knowledge.git</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/develop:refs/remotes/origin/develop</span><br><span class="line">       <span class="attr">fetch</span> = +refs/heads/feature/*:refs/remotes/origin/feature/*</span><br></pre></td></tr></table></figure>

<p>以上，<code>feature</code> 可以看做是命名空间，划分不同的分支类型。</p>
<p>上面描述都是拉取时 <code>RefSpec</code> 的作用，同样推送是也需要 <code>RefSpec</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p>推送一个空分支可以删除远程分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/heads/qa/master</span><br></pre></td></tr></table></figure>

<p><code>RefSpec</code> 描述了本地仓库分支和远程仓库分支的对应关系。很多时候可以省略，因为 Git 包含了很多默认行为。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 的分支大都是 其他 <code>本地仓库</code> 同步到远程的。</p>
<p>远程仓库 <code>refs/heads/*</code> 中 <code>创建</code> 的新分支，在同步数据的时候默认会被拉到本地，<code>删除</code> 的分支默认不会在本地进行同步删除，<code>修改</code> 的分支会被更新，并与本地追踪的开发分支进行合并。</p>
<p>更多阅读：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec">Git 内部原理 - The Refspec</a></p>
<p>以上，通过 <code>RefSpec</code> 描述的 本地仓库 和 远程仓库 中 分支 是如何对应的，了解了 本地仓库 和 远程仓库 之间的对应关系。</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-remote">git remote</a></h3><blockquote>
<p>管理本地仓库对应的一组远程仓库，包括 查看、更新、添加、删除、重命名、设置 等一系列操作</p>
</blockquote>
<p>该命令的主要工作是在维护配置文件，也就是维护 <code>.git/config</code>，通常当不记得命令的时候，可以直接修改配置文件，因为配置文件格式很简单，很容易记忆。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v | --verbose]</span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br><span class="line"></span><br><span class="line">git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote remove   &lt;name&gt;</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line"></span><br><span class="line">git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">git remote set-branches  [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line"></span><br><span class="line">git remote get-url       [--push] [--all] &lt;name&gt;</span><br><span class="line">git remote set-url       [--push] &lt;name&gt; &lt;new-url&gt; [&lt;old-url&gt;]</span><br><span class="line">git remote set-url --add [--push] &lt;name&gt; &lt;new-url&gt;</span><br><span class="line">git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line"></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git remote                                                  <span class="comment"># 列出已经存在的远程分支</span></span><br><span class="line">git remote -v                                               <span class="comment"># 查看远程主机的地址</span></span><br><span class="line">git remote show   remote_name                               <span class="comment"># 查看该远程主机的详细信息</span></span><br><span class="line">git remote add    remote_name remote_url                    <span class="comment"># 添加远程主机</span></span><br><span class="line">git remote remove remote_name                               <span class="comment"># 删除远程主机</span></span><br><span class="line">git remote rename remote_name new_remote_name               <span class="comment"># 重命名远程主机</span></span><br><span class="line"></span><br><span class="line">git remote set-head remote_name branch_name --auto          <span class="comment"># 查询远程获得默认分支</span></span><br><span class="line">git remote set-head remote_name branch_name --delete        <span class="comment"># 删除默认分支</span></span><br><span class="line"></span><br><span class="line">git remote set-branches [--add] remote_name branch_name     <span class="comment"># 设置 RefSpec， [remote &quot;remote_name&quot;].fetch</span></span><br><span class="line"></span><br><span class="line">git remote get-url remote_name                              <span class="comment"># 查看远程主机地址 [remote &quot;remote_name&quot;].url</span></span><br><span class="line">git remote set-url remote_name git://new.url.here           <span class="comment"># 设置远程主机地址</span></span><br><span class="line">git remote set-url remote_name --push   git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote set-url remote_name --add    git://new.url.here  <span class="comment"># 修改远程主机地址</span></span><br><span class="line">git remote set-url remote_name --delete git://new.url.here  <span class="comment"># 删除远程主机地址</span></span><br><span class="line"></span><br><span class="line">git remote prune [-n | --dry-run] &lt;remote_name&gt;…​            <span class="comment"># 删除某个远程名下过期（即不存在）的分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see http://stackoverflow.com/questions/1856499/differences-between-git-remote-update-and-fetch</span></span><br><span class="line">git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  Push  URL: git@github.com:liuyanjie/knowledge.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    feature/travis-ci tracked</span><br><span class="line">    master            tracked</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    feature/travis-ci merges with remote feature/travis-ci</span><br><span class="line">    master            merges with remote master</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    feature/travis-ci pushes to feature/travis-ci (up to date)</span><br><span class="line">    master            pushes to master            (up to date)</span><br></pre></td></tr></table></figure>

<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch">git fetch</a></h3><blockquote>
<p>从另外一个仓库下载 <strong>Refs</strong>，以及完成他们的变更历史所需要的 <strong>Objects</strong>，追踪的远程分支将会被更新。</p>
</blockquote>
<p>从一个或多个其他存储库中获取分支，以及完成它们的历史记录所需的对象，追踪的远程分支将会被更新（具体策略取决于 <code>RefSpec</code>）。</p>
<p>默认情况下，还会获取指向要获取分支的历史记录上的标签，效果是获取指向您感兴趣的分支的标签。分支和标签统称为 <code>Refs</code>。也可以改变这种行为。</p>
<p><code>git fetch</code> 的主要工作就是和远程同步 <code>Refs</code>，而 <code>Refs</code> 可以 被 <code>创建、修改、删除</code>，所以 <code>fetch</code> 操作必然应该能够同步这些变化。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_remotes_a_id_remotes_a">REMOTES</a></li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_configured_remote_tracking_branches_a_id_crtb_a">CONFIGURED REMOTE-TRACKING BRANCHES</a></li>
</ul>
<p><code>.git/FETCH_HEAD</code>：是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/FETCH_HEAD                                </span><br><span class="line">25f8a1026c24d8dee71a7ffd43310588d01c246f                        branch <span class="string">&#x27;master&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">0d572bc6b622355f930688af4f44ae8f3416e12b        not-for-merge   branch <span class="string">&#x27;feature/travis-ci&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">58a6618947d44720494860fbb77a6a22c9a30ddb        not-for-merge   branch <span class="string">&#x27;feature/vpn&#x27;</span> of github.com:liuyanjie/knowledge</span><br><span class="line">c761eb7a69dc54260b88c271b6271df559e7bce0        not-for-merge   branch <span class="string">&#x27;php-lang&#x27;</span> of github.com:liuyanjie/knowledge</span><br></pre></td></tr></table></figure>

<p>执行过 <code>fetch</code> 操作的项目都会存在一个 <code>FETCH_HEAD</code> 文件，其中每一行对应于远程服务器的一个分支。当前分支指向的 <code>FETCH_HEAD</code>，就是这个文件第一行对应的那个分支。</p>
<p>从本质上来说，唯一能从服务器下拉取数据的只有 <code>fetch</code>，其他命令的下拉数据的操作都是基于 <code>fetch</code> 的，所以 <code>fetch</code> 必然需要能够尽可能处理所有下拉数据时可能出现的情况。</p>
<p>Options:</p>
<ul>
<li><p>[shallow] 限制下拉指定的提交数：</p>
<ul>
<li><code>--depth=&lt;depth&gt;</code></li>
<li><code>--deepen=&lt;depth&gt;</code></li>
</ul>
</li>
<li><p>[shallow]限制下拉指定的提交时间：</p>
<ul>
<li><code>--shallow-since=&lt;date&gt;</code></li>
<li><code>--shallow-exclude=&lt;revision&gt;</code></li>
</ul>
</li>
<li><p>[deep]</p>
<ul>
<li><code>--unshallow</code>，<code>deep clone</code></li>
<li><code>--update-shallow</code></li>
</ul>
</li>
<li><p>[prune] 剪枝操作</p>
<p>远程仓库可能对已有的分支标签进行删除，而本地仓库并未删除，需要同步删除操作</p>
<ul>
<li><code>-p</code> <code>--prune</code></li>
<li><code>-p</code> <code>--prune-tags</code></li>
</ul>
</li>
<li><p>[tags] 默认情况下，<code>git fetch</code> 会下拉 <code>tag</code></p>
<ul>
<li><code>-t</code> <code>--tags</code> 【默认】下拉标签</li>
<li><code>-n</code> <code>--no-tags</code> 不下拉标签</li>
</ul>
</li>
<li><p>子模块</p>
<ul>
<li><code>--recurse-submodules-default=[yes|on-demand]</code></li>
<li><code>--recurse-submodules[=yes|on-demand|no]</code></li>
<li><code>--no-recurse-submodules</code></li>
<li><code>--submodule-prefix=&lt;path&gt;</code></li>
</ul>
</li>
</ul>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>local-branch@local</th>
<th>remote-branch@local</th>
<th>remote-branch@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p><code>git fetch</code> 将 <code>remote-branch@remote</code> fetch <code>remote-branch@local</code>，而 <code>RefSpec（+refs/heads/*:refs/remotes/origin/*）</code> 前面的 <code>+</code> 使 Git 在不能快速前进的情况下也强制更新，所以不会出现 <code>remote-branch@remote --merge--&gt; remote-branch@local</code> 的情况，实际上合并是不合理的行为，因为本地的 <code>refs/remotes/origin/*</code> 就是与远程保持同步的，如果合并了，就不同步了，更重要的是，远程分支可能修改了分支历史，如果合并，修改前的内容又合并进版本库了，有可能还需要解决冲突，而之后的 <code>remote-branch@local --merge--&gt; local-branch@local</code> 又会有可能合并。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git fetch                                         <span class="comment"># 获取 所有远程仓库 上的所有分支，将其记录到 .git/FETCH_HEAD 文件中</span></span><br><span class="line">git fetch -all                                    <span class="comment"># 获取 所有远程仓库 上的所有分支</span></span><br><span class="line">git fetch remote                                  <span class="comment"># 获取 remote 上的所有分支</span></span><br><span class="line">git fetch remote branch-name                      <span class="comment"># 获取 remote 上的分支：branch-name</span></span><br><span class="line">git fetch remote branch-name:local-branch-name    <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支</span></span><br><span class="line">git fetch remote branch-name:local-branch-name -f <span class="comment"># 获取 remote 上的分支：branch-name，并在本地创建对应分支，[强制]</span></span><br><span class="line">git fetch -f | --force                            <span class="comment"># 当使用 refspec(&lt;branch&gt;:&lt;branch&gt;) 时，跳过亲子关系检查，强制更新本地分支</span></span><br><span class="line">git fetch -p | --prune                            <span class="comment"># 获取所有远程分支并清除服务器上已删掉的分支</span></span><br><span class="line">git fetch -t | --tags                             <span class="comment"># 从远程获取数据时获取tags</span></span><br><span class="line">git fetch -n | --no-tags                          <span class="comment"># 从远程获取数据时去除tags</span></span><br><span class="line">git fetch --progress --verbose                    <span class="comment"># 显示进度及冗长日志</span></span><br><span class="line">git fetch --dry-run                               <span class="comment"># 显示做了什么，但是并不实际修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --depth=3 --no-tags --progress origin +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br><span class="line">git fetch --depth=3 --no-tags --progress git@github.com:liuyanjie/knowledge.git +refs/heads/master:refs/remotes/origin/master  +refs/heads/release/*:refs/remotes/origin/release/*</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --prune --progress --verbose --dry-run</span><br><span class="line">From github.com:remote-name/branch-name</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/abcd</span><br><span class="line"> - [deleted]             (none)     -&gt; origin/feature/efg</span><br><span class="line">remote: Counting objects: 34, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 34 (delta 18), reused 24 (delta 16), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (34/34), <span class="keyword">done</span>.</span><br><span class="line">   f4e75b13a..6a338066c  master              -&gt; origin/master</span><br><span class="line"> + c29324269...641076244 develop             -&gt; origin/develop  (forced update)</span><br><span class="line"> = [up to date]          release/1.0.0       -&gt; origin/release/1.0.0</span><br><span class="line"> * [new branch]          release/1.1.0       -&gt; origin/release/1.1.0</span><br><span class="line"> * [new tag]             v1.1.0              -&gt; v1.1.0</span><br></pre></td></tr></table></figure>

<p><code>--prune</code> 只能清理 <code>.git/refs/remotes/remote-name</code> 目录下的远程追踪分支，而不会删除 <code>.git/refs/heads</code> 下的本地分支，即使这些分支已经合并，这些分支的清理需要特定的命令。</p>
<p>清理本地已合并的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> <span class="comment"># 查看确认</span></span><br><span class="line">git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | xargs git branch -d</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | xargs git branch -d</span><br><span class="line">Deleted branch feature/auto-tag-ci (was 98147f0e3).</span><br><span class="line">Deleted branch feature/build-optimize (was d359f4179).</span><br><span class="line">Deleted branch feature/contract (was c0c4bdaa8).</span><br><span class="line">Deleted branch feature/cross-domain (was 2e9b25c82).</span><br><span class="line">Deleted branch feature/deploy (was 3650db271).</span><br><span class="line">Deleted branch feature/nvmrc (was 1d174fcd8).</span><br><span class="line">Deleted branch feature/winston-logstash (was f13700c66).</span><br></pre></td></tr></table></figure>

<p>清理远程已合并的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> <span class="comment"># 查看确认</span></span><br><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> | xargs -n 1 git push origin</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r --merged | egrep -v <span class="string">&quot;(^\*|master|develop|release)&quot;</span> | sed <span class="string">&#x27;s/origin\//:/&#x27;</span> | xargs -n 1 git push origin</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line"> - [deleted]             feature/xxxx</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/master topic:refs/remotes/origin/topic</span><br><span class="line">From git@github.com:schacon/simple</span><br><span class="line"> ! [rejected]        master     -&gt; origin/master  (non fast forward)</span><br><span class="line"> * [new branch]      topic      -&gt; origin/topic</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中， <code>master</code> 分支因为不是一个可以 <code>快速演进</code> 的引用而拉取操作被拒绝。你可以在 <code>RefSpec</code> 之前使用一个 <code>+</code> 号来重载这种行为。</p>
<p>输出格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;flag&gt; &lt;summary&gt; &lt;from&gt; -&gt; &lt;to&gt; [&lt;reason&gt;]</span><br></pre></td></tr></table></figure>

<p>输出格式详细介绍见：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-fetch#_output">OUTPUT</a></p>
<p><code>fetch</code> 负责将 远程仓库 更新到 远程仓库在本地的对应部分，其他工作又其他 命令 负责。</p>
<p>在实际使用中，大多数时候都是使用 <code>pull</code> 间接的使用 <code>fetch</code>。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-pull">git pull</a></h3><blockquote>
<p>将来自远程存储库的更改合并到当前分支中</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master  <span class="comment"># 获取远程分支 master 并 merge 到当前分支</span></span><br></pre></td></tr></table></figure>

<p>默认模式下，<code>git pull</code> 等价于以下两步:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>特例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout master</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>

<p>更确切的说，<code>git pull</code> 已指定的参数运行 <code>git fetch</code>，然后 调用 <code>git merge</code> 合并 检索到的分支头到当前分支，通过 <code>--rebase</code> 参数，<code>git merge</code> 也可以被替换成 <code>git rebase</code>。</p>
<p>假定有如下的历史，并且当前分支是 <code>master</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>调用 <code>git pull</code> 时，首先需要 <code>fetch</code> 变更从远处分支，下拉之后的仓库状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master in your repository</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<p>因为 远程分支 master (C) 已经和 本地分支 master (G) 已经处于分离状态，此时，<code>git merge</code> 合并 <code>origin/master</code> 到 <code>master</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H ← master</span><br></pre></td></tr></table></figure>

<p>以上过程发生了一次 <code>远程</code> 合并到 <code>本地</code> 的情形，git 会自动生成类似下面的 <code>commit message</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;master&#x27; of github.com:liuyanjie/knowledge into master</span><br></pre></td></tr></table></figure>

<p>出现 <code>远程</code> 合并到 <code>本地</code> 的情形 在 Git 中是一种不良好的实践，应该极力避免甚至是禁止出现，这种情形在多个人同时在同一个分支上开发的时候非常容易出现。</p>
<p>记住一点：一般来书，<code>分支</code>是要合并到远程服务器上的分支，而不是远程服务分支合并到本地分支的。</p>
<p>在实际开发过程中，所有的合并操作都应该发生在远程服务器上，保持所有的分支有清晰的历史。同样，也应该避免不必要的合并，甚至是禁止合并。</p>
<blockquote>
<p>一般情况下，创建了分支必然需要通过合并来将分支上的内容整合到分支的基上，但是也有不合并的其他方法</p>
</blockquote>
<p>合并产生的 <code>Commit</code> 并未给版本库带来新的改变，但是却使版本历史不够清晰了。</p>
<p>合并使分支历史从单向链表变成了有向图，一堆线杂乱无章交错，分支历史难以理解。</p>
<p>合并产生的 <code>Commit</code> 有两个或多个父 <code>Commit</code>， <code>Reset</code> 难以进行。</p>
<p>如何避免 本地合并？</p>
<ol>
<li>在 <code>commit</code> 之前先 <code>pull</code>，避免分叉。</li>
<li>在 <code>commit</code> 之后立即 <code>push</code>，使其他人的本地仓库能及时获取到最新的 <code>commit</code>。</li>
</ol>
<p>知道一定会 发生本地 合并时如何处理？</p>
<ol>
<li><code>git pull --ff-only</code> or <code>git fetch</code></li>
<li><code>git rebase origin/master</code></li>
</ol>
<p>已经出现 本地合并 如何解决？</p>
<ol>
<li><code>git reset C</code> 重置当前分支到 <code>C</code>，<code>F</code> <code>G</code> 会重新回到暂存区。</li>
<li><code>git commit -am &quot;commit message&quot;</code> 重新提交。</li>
<li><code>git push</code></li>
</ol>
<p>解决之后的分支图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">              origin/master</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C---F---G ← master</span><br><span class="line">     /</span><br><span class="line">D---E</span><br></pre></td></tr></table></figure>

<p>假设版本库当前的状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>以上版本库库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← master</span><br><span class="line">     /        ↑</span><br><span class="line">D---E         origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>以上版本库满足快速前进的条件，可以进行快速前进 <code>--ff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E ← master</span><br><span class="line">    ↑</span><br><span class="line">    origin/master in your repository</span><br></pre></td></tr></table></figure>

<p>快速前进不产生新的 <code>Commit</code>，效果上只移动分支头即可，默认情况下进行就是快速前进</p>
<p>在能够进行快速前进的情况下，也可以强制进行合并，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              master on origin</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C ← origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E-----------H ← master</span><br></pre></td></tr></table></figure>

<p>所以 <code>git pull</code> 的参数主要由 <code>git fetch</code> 和 <code>git merge</code> 的参数组成。</p>
<p><code>git pull</code> 的运行过程：</p>
<ol>
<li>首先，基于本地的 <code>FETCH_HEAD</code> 记录，比对本地的 <code>FETCH_HEAD</code> 记录与远程仓库的版本号</li>
<li>然后通过 <code>git fetch</code> 获得当前指向的远程分支的后续版本的数据</li>
<li>最后通过 <code>git merge</code> 将其与本地的当前分支合并</li>
</ol>
<p>若有多个 remote，git pull remote_name 所做的事情是：</p>
<ul>
<li>获取 <code>[remote_name]</code> 下的所有分支</li>
<li>寻找本地分支有没有 <code>tracking</code> 这些分支的，若有则 <code>merge</code> 这些分支，若没有则 <code>merge</code> 当前分支</li>
</ul>
<p>另外，若只有一个 remote，假设叫 origin，那么 git pull 等价于 git pull origin；平时养成好习惯，没谱的时候都把【来源】带上。</p>
<p>怎么知道 <code>tracking</code> 了没有？</p>
<ul>
<li>如果你曾经这么推过：<code>git push -u origin master</code>，那么你执行这条命令时所在的分支就已经 <code>tracking to origin/master</code> 了</li>
<li>如果你记不清了：<code>cat .git/config</code>，由此可见，<code>tracking</code> 的本质就是指明 <code>pull</code> 的 <code>merge</code> 动作来源</li>
</ul>
<p>总结:</p>
<ul>
<li><code>git pull = git fetch + git merge</code></li>
<li><code>git fetch</code> 拿到了远程所有分支的更新，<code>cat .git/FETCH_HEAD</code> 可以看到其状态，若是 <code>not-for-merge</code> 则不会有接下来的 <code>merge</code> 动作</li>
<li><code>merge</code> 动作的默认目标是当前分支，若要切换目标，可以直接切换分支</li>
<li><code>merge</code> 动作的来源则取决于你是否有 <code>tracking</code>，若有则读取配置自动完成，若无则请指明【来源】</li>
</ul>
<p><code>pull</code> 时还可能存在远程分支不存在的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">test</span></span><br><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">$ git branch --set-upstream-to=origin/<span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line">error: the requested upstream branch <span class="string">&#x27;origin/test&#x27;</span> does not exist</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning on basing your work on an upstream</span><br><span class="line">hint: branch that already exists at the remote, you may need to</span><br><span class="line">hint: run <span class="string">&quot;git fetch&quot;</span> to retrieve it.</span><br><span class="line">hint:</span><br><span class="line">hint: If you are planning to push out a new <span class="built_in">local</span> branch that</span><br><span class="line">hint: will track its remote counterpart, you may want to use</span><br><span class="line">hint: <span class="string">&quot;git push -u&quot;</span> to <span class="built_in">set</span> the upstream config as you push.</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 81, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 81 (delta 42), reused 81 (delta 42), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (81/81), <span class="keyword">done</span>.</span><br><span class="line">From github.com:liuyanjie/knowledge</span><br><span class="line">   2f977e2..be00fff  feature/x -&gt; origin/feature/x</span><br><span class="line">Your configuration specifies to merge with the ref <span class="string">&#x27;refs/heads/feature/abc&#x27;</span></span><br><span class="line">from the remote, but no such ref was fetched.</span><br></pre></td></tr></table></figure>

<p>需要提及的一点是：</p>
<p><code>pull</code> 操作，不应该涉及 <code>合并</code> 或 <code>变基</code> 操作，即 <code>pull</code> 应该总是 快速前进 的。</p>
<p>再看对应关系：</p>
<table>
<thead>
<tr>
<th>head@local</th>
<th>remote@local</th>
<th>remote@remote</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td><code>origin/master</code></td>
<td><code>master</code></td>
</tr>
<tr>
<td><code>feature/travis-ci</code></td>
<td><code>origin/feature/travis-ci</code></td>
<td><code>feature/travis-ci</code></td>
</tr>
<tr>
<td><code>refs/heads/feature/travis-ci</code></td>
<td><code>refs/remotes/origin/feature/travis-ci</code></td>
<td><code>refs/heads/feature/travis-ci</code></td>
</tr>
</tbody></table>
<p><code>git pull</code> 在 <code>git fetch</code> 的基础之上增加了 <code>git merge</code>，将 <code>远程分支对应的本地分支</code> 合并到 <code>追踪的本地开发分支</code></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-push">git push</a></h3><blockquote>
<p>使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p>
</blockquote>
<p><code>git push</code> 是与 <code>git pull</code> 相对应的推送操作，同样需要能够推送本地的多种情形的变更到远程仓库。git 向远程仓库推送的操作只有 <code>push</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">     [--all | --mirror | --tags]</span><br><span class="line">     [--follow-tags]</span><br><span class="line">     [--atomic]</span><br><span class="line">     [-n | --dry-run]</span><br><span class="line">     [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">     [--repo=&lt;repository&gt;]</span><br><span class="line">     [-f | --force]</span><br><span class="line">     [-d | --delete]</span><br><span class="line">     [--prune]</span><br><span class="line">     [-v | --verbose]</span><br><span class="line">     [-u | --set-upstream]</span><br><span class="line">     [--push-option=&lt;string&gt;]</span><br><span class="line">     [--[no-]signed|--sign=(<span class="literal">true</span>|<span class="literal">false</span>|if-asked)]</span><br><span class="line">     [--force-with-lease[=&lt;ref-name&gt;[:&lt;expect&gt;]]]</span><br><span class="line">     [--no-verify]</span><br><span class="line">     [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git push                                 <span class="comment"># 如果当前分支只有一个追踪分支，那么主机名都可以省略</span></span><br><span class="line">git push origin HEAD                     <span class="comment"># 将 当前 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master                   <span class="comment"># 将 master 分支 推送 到远程 master 分支</span></span><br><span class="line">git push origin master -u                <span class="comment"># 将 master 分支 推送 到远程 master 分支，并建立追踪关系</span></span><br><span class="line">git push origin master --set-upstream    <span class="comment"># 同上</span></span><br><span class="line">git push origin --all                    <span class="comment"># 将所有本地分支都推送到origin主机</span></span><br><span class="line">git push origin --force                  <span class="comment"># 强制推送更新远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin :hotfix/xxxx              <span class="comment"># 删除远程仓库的 hotfix/xxxx 分支</span></span><br><span class="line">git push origin :master                  <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line">git push origin --delete master          <span class="comment"># 删除远程仓库的 master 分支</span></span><br><span class="line"></span><br><span class="line">git push origin --prune                  <span class="comment"># 删除在本地没有对应分支的远程分支</span></span><br><span class="line"></span><br><span class="line">git push --tags                          <span class="comment"># 把所有tag推送到远程仓库</span></span><br></pre></td></tr></table></figure>

<p>推送模式：</p>
<ul>
<li>simple  模式: 不带任何参数的git push，默认只推送当前分支。2.0以上版本，默认此方式。</li>
<li>matching模式: 会推送所有有对应的远程分支的本地分支。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 1.25 KiB | 1.25 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 2 <span class="built_in">local</span> objects.</span><br><span class="line">To github.com:liuyanjie/knowledge.git</span><br><span class="line">   d26f671..e081fb3  master -&gt; master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete ref...</span><br></pre></td></tr></table></figure>

<p>推送代码到服务器与拉取代码到本地其实是相同的，所以服务代码推送到服务全之后，同样有可能出现需要合并的情况，如推送者本地仓库在没有 <code>pull</code> 后进行 <code>commit</code> 后 <code>push</code>，导致本地代码和远程服务器代码分叉，此时服务端也要面临合并问题，合并就有可能产生冲突，但是服务端没有解决冲突的能力，所以实质上服务端是禁止发生合并的，只能进行快速前进。当不能快速前进，服务端会返回错误给客户端，错误会提示先 <code>pull</code> 再 <code>push</code>。此时，<code>pull</code> 操作是一定会进行 <code>merge</code> 的，可能需要处理 <code>merge</code>，此时就需要处理前面提到的处理本地合并的问题了。</p>
<h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-submodule">git submodule</a></h3><blockquote>
<p>初始化、更新或检查子模块</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/docs/gitsubmodules">gitsubmodules</a>  - mounting one repository inside another</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--] &lt;repository&gt; [&lt;path&gt;]</span><br><span class="line">git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] init [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…​)</span><br><span class="line">git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch]</span><br><span class="line">        [--[no-]recommend-shallow] [-f|--force] [--rebase|--merge]</span><br><span class="line">        [--reference &lt;repository&gt;] [--depth &lt;depth&gt;] [--recursive]</span><br><span class="line">        [--<span class="built_in">jobs</span> &lt;n&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] summary [--cached|--files] [(-n|--summary-limit) &lt;n&gt;]</span><br><span class="line">        [commit] [--] [&lt;path&gt;…​]</span><br><span class="line">git submodule [--quiet] foreach [--recursive] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…​]</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -b master --name knowledge --reference=/Volumes/Data/Data/ws/knowledge -- git@github.com:liuyanjie/knowledge.git ./third_parts/knowledge</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   third_parts</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">[master 83506db] ...</span><br><span class="line"> 2 files changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 third_parts</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 7, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 5.31 KiB | 5.31 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">To github.com:liuyanjie/about.git</span><br><span class="line">   53abb09..83506db  master -&gt; master</span><br></pre></td></tr></table></figure>


<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git 是一个分布式的结构，有本地版本库和远程版本库，便有了本地分支和远程分支的区别了。</p>
<p>本地分支和远程分支在 <code>git push</code> 的时候可以随意指定，交错对应，只要不出现版本从图即可。</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git-branch"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-branch">git-branch</a></h3><blockquote>
<p>创建、修改、删除、查看、重命名、复制分支</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch (-t | --[no-]track) (-l | --[no-]create-reflog) [-f | --force] &lt;branch-name&gt; [&lt;start-point&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置/修改上游分支</span></span><br><span class="line">git branch [-u | --set-upstream-to=] &lt;upstream&gt; [&lt;branch-name&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch -a --all</span><br><span class="line">git branch -r</span><br><span class="line">git branch --list &lt;pattern&gt;...</span><br><span class="line">git branch --list --[no-]contains [&lt;commit&gt;]</span><br><span class="line">git branch --list --[no-]merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置分支</span></span><br><span class="line">git branch (-f --force) &lt;branch-name&gt; &lt;start-point&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名分支</span></span><br><span class="line">git branch (-m --move | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-m --move) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -M [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制分支</span></span><br><span class="line">git branch (-c --copy) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch (-c --copy) --force [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line">git branch -C [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="comment"># -r 可以同时删除远程追踪分支，但是只有在远程分支删除的情况下才有意义，否则会fetch回来</span></span><br><span class="line">git branch (-d --delete) [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch (-d --delete)  --force [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch -D [-r] &lt;branchname&gt;…​</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑分支描述</span></span><br><span class="line">git branch --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>

<p><code>git branch</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>。</p>
<p><code>remotes/origin/*</code> 下的分支删除：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;branch-name&gt;</span><br><span class="line">git push :&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>以上命令在删除远程仓库的分支的同时，同步删除 <code>remotes/origin/*</code> 下的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;remote-name&gt;/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>以上命令删除 <code>remotes/origin/*</code> 下的分支，但是远程分支并未删除，在 <code>git fetch</code> 后还会拉下来，所以这种删除无意义。</p>
<p>分支类型：</p>
<ul>
<li>远程分支（remote-branch），远程服务器上的分支，<code>refs/heads/*</code>@remote，是<code>远程追踪分支</code>的<code>上游分支</code>。</li>
<li>远程追踪分支（remote-tracking branch），远程服务器对应在本地的分支，与<code>远程分支</code>存在<code>追踪</code>关系，可能是<code>本地分支</code>的<code>上游分支</code>。</li>
<li>本地分支（local branch），<code>refs/heads/*</code>@local，可能与<code>远程追踪分支</code>存在<code>追踪</code>关系。</li>
</ul>
<p>分支关系：</p>
<ul>
<li>追踪分支（tracking branch），能够主动追踪其他分支，自动跟随其他分支变化更新的分支。</li>
<li>上游分支（upstream branch），被追踪的分支。</li>
</ul>
<blockquote>
<p>Checking out a <code>local branch</code> from a <code>remote-tracking branch</code> automatically creates what is called a <code>“tracking branch”</code> (and the branch it tracks is called an <code>“upstream branch”</code>).</p>
</blockquote>
<p>只有把概念定义清楚，才能够进行准确的描述，要不然都可能带来理解上的偏差。</p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git-tag"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-tag">git-tag</a></h3><blockquote>
<p>创建、删除、查看、校验标签</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e] &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br><span class="line">git tag -d &lt;tagname&gt;…​</span><br><span class="line">git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;]</span><br><span class="line">  [--points-at &lt;object&gt;] [--column[=&lt;options&gt;] | --no-column]</span><br><span class="line">  [--create-reflog] [--sort=&lt;key&gt;] [--format=&lt;format&gt;]</span><br><span class="line">  [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…​]</span><br><span class="line">git tag -v [--format=&lt;format&gt;] &lt;tagname&gt;…​</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l --list <span class="string">&quot;v*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;tagging version 1.0.0&quot;</span></span><br><span class="line">git tag -a --force v1.0.0 -m <span class="string">&quot;tagging version 1.0.0&quot;</span></span><br><span class="line">git tag -a v1.0.0 --file=&lt;file&gt;</span><br><span class="line">git tag -a v1.0.0 &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>

<p>与分支不同，<code>git push</code> 默认不推送标签到远程，所以需要主动推送标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<p>同样，<code>git tag</code> 只能操作本地仓库，无法直接操作远程仓库，操作远程仓库必须通过 <code>git push</code>，通常也不会直接操作远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --delete &lt;tag-name&gt;</span><br><span class="line">git push --delete v1.0.0</span><br></pre></td></tr></table></figure>

<p>清理 远程不能存在本地存在 的标签：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l | xargs git tag -d ; git fetch --tags</span><br></pre></td></tr></table></figure>

<p>标签并不像分支那样，存在远程标签/本地标签等区分，所以也不存在本地标签与远程标签之间的对应关系，自然也就不需要维护对应关系。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git-checkout"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout">git-checkout</a></h3><ul>
<li>切换分支并检出内容到工作区，也可创建分支</li>
</ul>
<p>检出已存在的分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout    &lt;branch&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>创建并检出分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b|-B &lt;new_branch&gt; [&lt;start-point&gt;]</span><br></pre></td></tr></table></figure>

<p>检出<code>tree-ish</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​</span><br></pre></td></tr></table></figure>

<p>检出内容到本地的时候会发生什么？</p>
<ol>
<li>本地是干净的，无任何修改</li>
<li>本地存在新增加的文件</li>
<li>本地存在修改后未提交的文件</li>
</ol>
<p>Ref：<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-checkout#_detached_head">DETACHED HEAD</a></p>
<p>HEAD 通常指向某一个分支，这一分支即是当前工作的分支。当 HEAD 不再指向分支的时候，仓库即处于 <code>DETACHED HEAD</code> 状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout ccdd28a</span><br><span class="line">Note: checking out <span class="string">&#x27;ccdd28a&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by using -b with the checkout <span class="built_in">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at ccdd28a git update</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">HEAD detached at ccdd28a</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>处于这种状态下的仓库，如果进行修改并且提交，就会很危险，因为没有任何分支指向新的提交，当 <code>HEAD</code> 切换到其他位置的时候，当前的修改就不容易找不到了。</p>
<p>如果需要基于此节点进行修改，需要先基于此节点创建分支。</p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git-merge"></a><a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-merge">git-merge</a></h3><blockquote>
<p>将两个或多个分支历史合并在一起</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br><span class="line">  [-q --quiet]</span><br><span class="line">  [-v --verbose]</span><br><span class="line">  [--[no-]progress]</span><br><span class="line">  [--commit] [--no-commit]</span><br><span class="line">  [-e | --edit] [--no-edit]</span><br><span class="line">  [-ff] [--no-ff] [--ff-only]</span><br><span class="line">  [--<span class="built_in">log</span>[=&lt;n&gt;]] [--no-log]</span><br><span class="line">  [-n] [--<span class="built_in">stat</span>] [--no-stat]</span><br><span class="line">  [--[no-]squash]</span><br><span class="line">  [--[no-]signoff]</span><br><span class="line">  [-s &lt;strategy&gt;] [--strategy=&lt;strategy&gt;]</span><br><span class="line">  [-X &lt;strategy-option&gt;] [--strategy-option=&lt;option&gt;]</span><br><span class="line">  [-S[&lt;keyid&gt;]] --gpg-sign[=&lt;keyid&gt;]</span><br><span class="line">  [--[no-]verify-signatures]</span><br><span class="line">  [--[no-]summary]</span><br><span class="line">  [--[no-]allow-unrelated-histories]</span><br><span class="line">  [--[no-]rerere-autoupdate]</span><br><span class="line">  [-m &lt;msg&gt;]</span><br><span class="line">  [&lt;commit&gt;…​]</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/11646107/you-have-not-concluded-your-merge-merge-head-exists</span><br><span class="line"></span><br><span class="line"><span class="comment"># git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present.</span></span><br><span class="line"><span class="comment"># 中断 merge，当发生冲突时，可以通过中断合并回到合并前的状态</span></span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续 merge，当发生冲突时，需要解决冲突，解决冲突后，继续执行合并</span></span><br><span class="line">git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>有如下版本库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge topic</span><br></pre></td></tr></table></figure>

<p>合并后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure>

<p>squash mode</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash topic</span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G---(ABC) master</span><br></pre></td></tr></table></figure>

<p><code>--squash</code> 效果相当于将 topic 分支上的多个 commit A-B-C 合并成一个 ABC，放在当前分支上，原来的 commit 历史则没有拿过来。</p>
<p>判断是否使用 <code>--squash</code> 选项最根本的标准是，待合并分支上的历史是否有意义。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。</p>
<p>只有在开发分支上每个 commit 都有其独自存在的意义，并且能够编译通过的情况下，才应该选择缺省的合并方式来保留 commit 历史。</p>
<p>fast forward mode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --ff topic</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A---B---C topic master</span><br><span class="line">             /</span><br><span class="line">D---E---F---G</span><br></pre></td></tr></table></figure>

<p>合并的前提是：准备合并的两个 <code>commit</code> 不在一条直线上，在一条直线上可以进行快速前进，也可以使用 <code>--no-ff</code> 强制合并（无意义）。</p>
<p>合并的过程中需要处理可能得冲突，未冲突的文件将会进行自动合并，在新版本的<code>tree</code>中产生一个新版本的<code>blob</code>，所以Git能够完整检出不需要依赖历史中的<code>commit</code>，只需要当前的<code>commit</code>。</p>
<p>合并的结果是：产生一个新的 <code>commit</code>，实际上，<code>squash mode</code> <code>fast forward mode</code> 并不是真正意义上的合并。</p>
<p>冲突：</p>
<p>冲突有两种类型，一种是树冲突，修改/删除同一文件，另一种是文件冲突，修改了同一文件中的相同内容。</p>
<p>冲突是如何判断的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>假如有文件 <code>README.md</code> 在 <code>E</code>，且 <code>topic</code> 和 <code>master</code> 都有修改此文件，合并 <code>topic</code> 到 <code>master</code> 时，冲突检查的依据不是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 是否相同，而是对比 <code>README.md@topic</code> 和 <code>README.md@master</code> 相对于 <code>E</code> 的变化。即使是 <code>README.md</code> 文件在被修改后的内容是相同的，也会产生冲突。而冲突产生的文件，就是将 相对于 <code>E</code>，都合并到同一个文件中，并交由用户解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">=======</span><br><span class="line">Git makes conflict resolution easy.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt</span><br></pre></td></tr></table></figure>

<p>最佳实践：</p>
<ol>
<li>尽量避免在本地使用 <code>merge</code>，也尽量避免在本地发生 <code>Merge</code>。</li>
<li><code>merge</code> 时，本地不要有未提交的更改，这些修改可能会在中断合并时丢失。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><blockquote>
<p>添加文件到索引中，为下一次提交准备内容。</p>
</blockquote>
<p>将工作区的修改添加到暂存区中，此命令使用在工作树中找到的最新内容更新索引，以准备为下次提交暂存内容。</p>
<p>典型的情况下，将整个文件添加到暂存区中，通过特定的选项，也可以将工作区修改的部分内容加到暂存区中。</p>
<p>暂存区保存工作树内容的快照，并将此快照作为下一次提交的内容。因此，在对工作树进行任何更改之后，在运行commit命令之前，必须使用add命令将任何新的或修改的文件添加到索引中。</p>
<p>默认情况下，<code>git add</code> 不会添加忽略的文件，<code>git add -f</code> 会进行强制添加。</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><blockquote>
<p>从工作区和暂存区移除文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…​</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm *.txt</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm *.txt</span><br><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>

<p>仅从暂存区删除内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached *.txt</span><br></pre></td></tr></table></figure>

<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><blockquote>
<p>重命名或移动文件，同步更新暂存区</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv &lt;options&gt;…​ &lt;args&gt;…​</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; &lt;destination&gt;</span><br><span class="line">git mv [-v] [-f] [-n] [-k] &lt;<span class="built_in">source</span>&gt; ... &lt;destination directory&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name new_name            <span class="comment"># 重命名</span></span><br><span class="line">git mv -f old_name new_name         <span class="comment"># 强制重命名，即时目标名称已经存在</span></span><br><span class="line">git mv -k old_name new_name         <span class="comment"># 跳过会导致错误的动作</span></span><br><span class="line">git mv -v old_name new_name         <span class="comment"># 报告被移动文件</span></span><br><span class="line">git mv --dry-run old_name new_name  <span class="comment"># 只显示将会发生什么</span></span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><blockquote>
<p>Show changes between commits, commit and working tree, etc</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [options] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment"># 查看尚未暂存的文件更新了哪些部分，不加参数直接输入。</span></span><br><span class="line">git diff --cached       <span class="comment"># 查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异</span></span><br><span class="line">git diff --staged       <span class="comment"># 显示的是下一次 commit 时会提交到HEAD的内容(不带-a情况下)</span></span><br><span class="line">git diff HEAD           <span class="comment"># 显示工作版本(Working tree)和HEAD的差别</span></span><br><span class="line">git diff topic master   <span class="comment"># 直接将两个分支上最新的提交做diff</span></span><br><span class="line">git diff topic...master <span class="comment"># 输出自 topic 和 master 分别开发以来，master 分支上的 changed。</span></span><br><span class="line">git diff --<span class="built_in">stat</span>         <span class="comment"># 查看简单的diff结果，可以加上--stat参数</span></span><br><span class="line">git diff <span class="built_in">test</span>           <span class="comment"># 查看当前目录和另外一个分支的差别 显示当前目录和另一个叫 test 分支的差别</span></span><br><span class="line">git diff HEAD -- ./lib  <span class="comment"># 显示当前目录下的lib目录和上次提交之间的差别（更准确的说是在当前分支下）</span></span><br><span class="line">git diff HEAD^ HEAD     <span class="comment"># 比较上次提交commit和上上次提交</span></span><br><span class="line">git diff SHA1 SHA2      <span class="comment"># 比较两个历史版本之间的差异</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diff_utility">Diff_utility</a></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><blockquote>
<p>Record changes to the repository</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit                          <span class="comment"># 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</span></span><br><span class="line">git commit -a                       <span class="comment"># 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。</span></span><br><span class="line">git commit -a -m <span class="string">&#x27;commit info&#x27;</span>      <span class="comment"># 注释，如果没有 -m，会默认会使用vi编辑注释。</span></span><br><span class="line">git commit -am <span class="string">&quot;This is a commit&quot;</span>   <span class="comment"># 同上，合并提交，将 add 和 commit 合为一步</span></span><br><span class="line">git commit --amend                  <span class="comment"># 对上一次提交进行修改，合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit --amend -a               <span class="comment"># 提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交</span></span><br><span class="line">git commit --author=&lt;author&gt;        <span class="comment"># 设置作者，与提交者分开</span></span><br><span class="line">git commit --file=&lt;file&gt;            <span class="comment"># 注释从文件中读取</span></span><br></pre></td></tr></table></figure>

<p>对于 commit 来说，最重要的是，每一次 commit 都应该是一个完整的提交，而且应该有个规范清晰的注释。</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><blockquote>
<p>显示工作树状态</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status     <span class="comment"># 显示状态</span></span><br><span class="line">git status -s  <span class="comment"># 显示简短信息</span></span><br><span class="line">git status -b  <span class="comment"># 显示分支状态</span></span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><blockquote>
<p>重置工作区，将当前分支回退到某一节点</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…​</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…​]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>

<p><code>git reset</code> 会修改当前分支头从某一个 <code>&lt;commit-id&gt;</code> 移动到另外的一个指定的 <code>&lt;commit-id&gt;</code></p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">              HEAD</span><br><span class="line">              ↓</span><br><span class="line">              topic</span><br><span class="line">              ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>当前活跃的分支是 <code>topic</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset A</span><br></pre></td></tr></table></figure>

<p>执行以上操作后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      HEAD</span><br><span class="line">      ↓</span><br><span class="line">      topic</span><br><span class="line">      ↓</span><br><span class="line">      A---B---C</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure>

<p>此时，<code>HEAD -&gt; topic -&gt; A</code>，B、C 此时处于悬挂状态，如同普通的对象一样，没有任何引用后，会被 Git GC 回收。</p>
<p>执行此操作后，B、C 两点虽然依然存在于仓库中，但是它们已经逻辑上脱离了Git。</p>
<p>此时，B、C 两点提交的内容怎么办？是不是就丢失了呢？</p>
<p>Git 给了我们多种选择：</p>
<ul>
<li>–soft，B、C 提交的内容不会回到工作区和暂存区。因为当前工作区内容是基于 C 修改的，所以实际上并无内容丢失。</li>
<li>–mixed，B、C 提交的内容回到暂存区，但是工作区内容不变，也就是某些文件处于 <code>修改未提交状态</code>。同上，也无内容丢失。</li>
<li>–hard，B、C 提交的内容不会回到工作区和暂存区，同时暂存区和工作区回到A点状态，B、C 提交的内容以及工作区后续的修改全部丢失。</li>
</ul>
<p>如果 <code>reset</code> 误操作操作怎么办？</p>
<ol>
<li><p>如果存在上游分支，可以通过上游分支恢复</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset master^2</span><br><span class="line">git reset origin/master</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过 <code>reflog</code> 恢复</p>
<p> <code>reflog</code> 记录 HEAD 的变化，所以可以通过 <code>reflog</code> 找到 <code>reset</code> 之前的 <code>HEAD</code> 的位置，但是前提是后续节点未被垃圾回收。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">58c1d5d (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: update git</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;1&#125;: checkout: moving from <span class="built_in">test</span> to master</span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;2&#125;: checkout: moving from master to <span class="built_in">test</span></span><br><span class="line">ccdd28a (test2, test1, <span class="built_in">test</span>) HEAD@&#123;3&#125;: commit: git update</span><br><span class="line">e081fb3 HEAD@&#123;4&#125;: commit: update python</span><br><span class="line">d26f671 HEAD@&#123;5&#125;: commit: update</span><br><span class="line">33db13f HEAD@&#123;6&#125;: commit (amend): update and format</span><br><span class="line">5c41033 HEAD@&#123;7&#125;: commit: update and format</span><br><span class="line">e56ec4e HEAD@&#123;8&#125;: commit: 移除乱码字符</span><br><span class="line">6595b95 HEAD@&#123;9&#125;: commit: feat(): add hexo.yaml</span><br></pre></td></tr></table></figure></li>
</ol>
<p>未提交的内容是很难就行恢复的，所有在进行 <code>reset</code> 操作时，要将工作区的内容提交。</p>
<p>reset 除了将工作区回退到某个节点之外，常用的应用就是将后续的多个提交合并为一个提交，因为后续提交的内容可以回到暂存区或工作区中。</p>
<p>在某些Git工作流中，要求将多个提交合并成一个之后才能合并到上游分支。</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">git revert --<span class="built_in">continue</span></span><br><span class="line">git revert --quit</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~3</span><br><span class="line">git revert -n master~5..master~2</span><br></pre></td></tr></table></figure>

<p><code>git revert</code> 用于撤销一个或多个提交，并建立一个新的提交。<code>commit</code> 中所做的修改都会被移除掉，相当于 <code>commit</code> 反向操作。</p>
<p><code>git revert</code> 通常用户快速回滚。</p>
<p>示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            HEAD</span><br><span class="line">            ↓</span><br><span class="line">            master</span><br><span class="line">            ↓</span><br><span class="line">A---B---C---D</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert C</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                HEAD</span><br><span class="line">                ↓</span><br><span class="line">                master</span><br><span class="line">                ↓</span><br><span class="line">A---B---C---D---C<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>C&#39;</code> 是一个全新的 <code>Commit</code> 与 <code>C</code> 是不同的，但是这种情况下，<code>C&#39;</code> 与 <code>C</code> 中的 <code>tree</code> 是相同的。</p>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><blockquote>
<p>变基操作，基指的是起始提交，即参数中常见的 <start-point></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] [&lt;upstream&gt; [&lt;branch&gt;]]</span><br><span class="line">git rebase [-i | --interactive] [&lt;options&gt;] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;] --root [&lt;branch&gt;]</span><br><span class="line">git rebase --<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突之后继续 rebase</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过</span></span><br><span class="line">git rebase --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断 rebase</span></span><br><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C ← topic</span><br><span class="line">     /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              A&#x27;--B&#x27;--C&#x27; ← topic</span><br><span class="line">             /</span><br><span class="line">D---E---F---G ← master</span><br></pre></td></tr></table></figure>

<p>以上，通过变基操作，将topic分支的 <start-point> 从 <code>E</code> 调整到了 <code>G</code>。</p>
<p>变基操作的原理：将 A B C 基于 G 重新提交，提交的过程可能与 F G 存在冲突，需要解决冲突。</p>
<p>变基操作的应用：</p>
<ol>
<li>保持与上游分支同步，同步上游分支的最新版本</li>
<li>合并时存在冲突，通过变基操作解决冲突</li>
</ol>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/vcs/git/git-working-mechanism.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/vcs/git/git-working-mechanism.md">编辑源文件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/vcs/git/git-object-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/vcs/git/git-object-model/" class="post-title-link" itemprop="url">Git对象模型：一步一步分析Git底层对象模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-24 11:00:00" itemprop="dateCreated datePublished" datetime="2019-06-24T11:00:00+08:00">2019-06-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-08-18 13:47:16" itemprop="dateModified" datetime="2019-08-18T13:47:16+08:00">2019-08-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/vcs/git/git-object-model/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/vcs/git/git-object-model/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Git是一个非常强大的版本管理工具，有非常多的概念和命令，也有非常多且复杂的用法。但是其底层模型相对而言却非常简单，了解底层对象模型将非常有助于理解上层命令到底对仓库做了什么。如果想要精通Git，了解底层对象模型也是必不可少的。本文将会通过基本的命令操作，分析每一步操作对仓库数据做了哪些改动，进而分析出Git底层对象模型。</p>
<h2 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h2><h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p>所有用来表示项目历史信息的文件，都是通过一个40个字符的（40-digit）“对象名”来索引的，对象名看起来像这样:</p>
<blockquote>
<p>6ff87c4664981e4397625791c8ea3bbb5f2279a3</p>
</blockquote>
<p>在后边使用对象名时，只使用前面几个字符即可，但是最少需要4个。</p>
<p>你会在Git里到处看到这种“40个字符”字符串。每一个“对象名”都是对“对象”内容做SHA1哈希计算得来的。这样就意味着两个不同内容的对象几乎不可能（理论上是可能发生碰撞的）有相同的“对象名”。</p>
<p>这样做会有几个好处：</p>
<ul>
<li><p>只要比较对象名，就可以很快的判断两个对象是否相同。</p>
<p>因为在每个仓库（repository）的“对象名”的计算方法都完全一样，如果同样的内容存在两个不同的仓库中，就会存在相同的“对象名”下。</p>
</li>
<li><p>还可以通过检查对象内容的SHA1的哈希值和“对象名”是否相同，来判断对象内容是否正确。</p>
</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>每个对象(object) 包括三个部分：类型、大小和内容。大小就是指内容的大小，内容取决于对象的类型。</p>
<p>有四种类型的对象：<code>&quot;blob&quot;</code>、<code>&quot;tree&quot;</code>、<code>&quot;commit&quot;</code> 和 <code>&quot;tag&quot;</code>。</p>
<p>几乎所有的Git功能都是使用这四个简单的对象类型来完成的。它就像是在你本机的文件系统之上构建一个小的文件系统。</p>
<h4 id="blob-文件-对象"><a href="#blob-文件-对象" class="headerlink" title="blob (文件) 对象"></a>blob (文件) 对象</h4><p><code>blob</code> 用来存储文件数据，通常是一个文件。</p>
<p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/object-blob.png" alt="blob"></p>
<h4 id="tree-目录-对象"><a href="#tree-目录-对象" class="headerlink" title="tree (目录) 对象"></a>tree (目录) 对象</h4><p><code>tree</code> 像一个目录，管理 <code>tree（子目录）</code> 或 <code>blob（文件）</code></p>
<p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/object-tree.png" alt="tree"></p>
<h4 id="commit-提交-对象"><a href="#commit-提交-对象" class="headerlink" title="commit (提交) 对象"></a>commit (提交) 对象</h4><p>一个 <code>commit</code> 只指向一个 <code>tree</code>，它用来标记项目某一个特定时间点的状态。<code>commit</code> 保存了树根的 <code>对象名</code>。</p>
<p>它包括一些关于时间点的元数据，如 <code>时间戳</code>、<code>最近一次提交的作者</code>、<code>指向上次提交（commits）的指针</code> 等等。</p>
<p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/object-commit.png" alt="tree"></p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p <span class="number">830</span>f<span class="number">4857e9</span>f<span class="number">579818</span><span class="keyword">c</span><span class="number">5e69104</span>d<span class="number">3e2</span><span class="keyword">cc</span><span class="number">30</span>f<span class="number">1</span>f<span class="number">0</span>d<span class="number">0</span>d</span><br><span class="line">tree f<span class="number">25061</span>fa<span class="number">4</span>f<span class="number">8</span>b<span class="number">3</span>bffbf<span class="number">8</span>ebcc<span class="number">3</span>ab<span class="number">2351</span>efdad<span class="number">2</span>f<span class="number">605</span></span><br><span class="line">parent <span class="number">06e13701</span>ac<span class="number">86</span>eb<span class="number">09</span><span class="keyword">c</span><span class="number">2035329</span>a<span class="number">5e1</span><span class="keyword">c</span><span class="number">18</span>f<span class="number">95898</span>cf<span class="number">2</span></span><br><span class="line">author liuyanjie &lt;<span class="keyword">x</span><span class="title">@gmail.com</span>&gt; <span class="number">1526828841</span> +<span class="number">0800</span></span><br><span class="line">committer liuyanjie &lt;<span class="keyword">x</span><span class="title">@gmail.com</span>&gt; <span class="number">1526828841</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">commit message</span><br></pre></td></tr></table></figure>

<h4 id="tag-标签-对象"><a href="#tag-标签-对象" class="headerlink" title="tag (标签) 对象"></a>tag (标签) 对象</h4><p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/object-tag.png" alt="tag"></p>
<p>一个 <code>tag</code> 是来标记某一个 <code>commit</code> 的方法。</p>
<p>实际上 <code>tag</code> 本身是文件名，内容是 <code>commit</code> 的对象名。<code>tag</code> 是 <code>commit</code> 的别名，类似于域名和ip地址的关系。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git<span class="regexp">/refs/</span>tags/v0.<span class="number">0.0</span></span><br><span class="line"><span class="number">830</span>f4857e9f579818c5e69104d3e2cc30f1f0d0d</span><br></pre></td></tr></table></figure>

<h4 id="commit-gt-tree-gt-blob"><a href="#commit-gt-tree-gt-blob" class="headerlink" title="commit -&gt; tree -&gt; blob"></a>commit -&gt; tree -&gt; blob</h4><p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/object-c-t-b.png" alt="object-c-t-b"></p>
<p>从图上可以看出：一个 <code>commit</code> 指向了一棵由 <code>tree</code> 和 <code>blob</code> 构成的 Git 对象树。</p>
<h3 id="与其他版本控制系统的区别"><a href="#与其他版本控制系统的区别" class="headerlink" title="与其他版本控制系统的区别"></a>与其他版本控制系统的区别</h3><p>Git与你熟悉的大部分版本控制系统的差别是很大的。</p>
<p>也许你熟悉 <code>Subversion</code>、<code>CVS</code>、<code>Perforce</code>、<code>Mercurial</code> 等等，他们使用 “增量文件系统” （Delta Storage systems）, 就是说它们存储每次提交(commit)之间的差异。</p>
<p>Git正好与之相反，它会把你的每次提交的文件的全部内容（snapshot）都会记录下来。</p>
<p>这会是在使用Git时的一个很重要的理念。</p>
<p>综上，Git对象模型非常简单，与普通的文件系统非常的相似。</p>
<h2 id="一步一步了解Git在做什么"><a href="#一步一步了解Git在做什么" class="headerlink" title="一步一步了解Git在做什么"></a>一步一步了解Git在做什么</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>初始化目录并创建一个Git仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> git-obj-model</span><br><span class="line"></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/liuyanjie/git-obj-model/.git/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下初始化的git仓库中到底有些什么内容。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">8 directories, 15 files</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config</span><br><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = <span class="literal">true</span></span><br><span class="line">	bare = <span class="literal">false</span></span><br><span class="line">	logallrefupdates = <span class="literal">true</span></span><br><span class="line">	ignorecase = <span class="literal">true</span></span><br><span class="line">	precomposeunicode = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p>查看仓库状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面忽略 <code>.git/hooks/</code> 下的文件。</p>
<h3 id="增加一个文件README-md"><a href="#增加一个文件README-md" class="headerlink" title="增加一个文件README.md"></a>增加一个文件README.md</h3><p>现在创建一个 <code>README.md</code>，查看 <code>.git</code> 目录，发现没有什么变化。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;# Readme&quot;</span> &gt; README.md</span><br><span class="line"></span><br><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">8 directories, 15 files</span><br></pre></td></tr></table></figure>

<p>查看当前状态，可以看到，此时有一个未追踪的 <code>README.md</code> 文件，此文件存在于 <code>工作区</code> 中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	README.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 <code>git add</code> 命令后，可以看到增加了两个文件：</p>
<ul>
<li>.git/index</li>
<li>.git/objects/f3/954314c1026028e77ea3a765aadefa67b45195</li>
</ul>
<blockquote>
<p>git add 把文件暂存到索引中为下一次提交做准备，git commit 创建新的提交。</p>
</blockquote>
<p>应该知道，这应该是一个 <code>blob</code> 类型的文件，里面存储文件内容。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">9 directories, 17 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看当前状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看对象内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p f39543</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看暂存区</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files --stage</span><br><span class="line">100644 f3954314c1026028e77ea3a765aadefa67b45195 0	README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.git/index 是 Git索引文件，是一个在 <code>工作区</code> 和 <code>仓库</code> 间的 <code>暂存区域(staging area)</code>。</p>
<p>索引是一个二进制格式的文件，里面存放了与当前暂存内容相关的信息，包括暂存的<code>文件名</code>、<code>文件内容的SHA1哈希串值</code> 和 <code>文件访问权限</code>，整个索引文件的内容以暂存的文件名进行排git ls-files –stage序保存的。</p>
<p>因为这个文件记录了将要提交的文件, 所以我们才能够多次修改一起提交(commit)。</p>
<p>所以创建了一个新的提交(commit)，提交的一般是暂存区里的内容, 而不是工作目录中的内容。</p>
<p>一个Git项目中文件的状态大概分成下面的两大类，而第二大类又分为三小类：</p>
<ol>
<li>未被跟踪的文件（Untracked files）</li>
<li>已被跟踪的文件（Tracked files）<ol>
<li>被修改 未暂存 的文件（Changed but not updated 或 Modified）</li>
<li>被修改 已暂存 可以 被提交 的文件（Changes to be committed 或 Staged）</li>
<li>未修改 的文件（自上次提交以来）(Clean 或 Unmodified)</li>
</ol>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (no files)</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (no files)</span><br><span class="line">Untracked files:</span><br><span class="line">? .gitignore</span><br></pre></td></tr></table></figure>

<p>执行 <code>git commit</code> 命令，发现路径下又增加了两个文件：</p>
<ul>
<li>.git/objects/9d/978d59f2f22062c0382c859f4c3ef929026303</li>
<li>.git/objects/c1/067ba0a7ba51f937518c9bc051ea744ca748fe</li>
</ul>
<p>从上面的结构图，可以想到：</p>
<p>提交可定会产生一个提交对象，提交对象指向一个树对象，树对象包含上一步添加的<code>blob</code>对象。</p>
<p>下面将通过查看文件内容验证这一点。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;First Commmit&quot;</span> README.md</span><br><span class="line"></span><br><span class="line">[master (root-commit) 033fa1a] First Commmit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5 +</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe +</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">14 directories, 23 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>033f</code> 对象内容，此时不知道这个文件类型及内容是什么</p>
<p>此时，<code>commit</code> 对象为初始提交，所以并无 <code>parent</code> 引用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 033f</span><br><span class="line">tree c1067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800</span><br><span class="line"></span><br><span class="line">First Commmit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>c106</code> 对象内容，通过上一步，已知此对象是一个 <code>tree</code> 类型的对象，通过内容可以看到，树类型的对象实际就是存储每行一条数据的列表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p c106</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看 <code>.git/refs/heads/master</code> 文件内容</p>
<p>文件内容只有一行，内容是 <code>033f</code> 对象。<code>master</code> 即是 <code>master</code> 分支的物理表示。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，还可看到，新增了 <code>.git/logs</code> 目录及内容</p>
<p>该目录下保存了各个分支的提交记录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line"></span><br><span class="line">$ cat .git/logs/HEAD</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Tag</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.0.1 -m <span class="string">&#x27;tag v0.0.1&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看目录文件变化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">│   ├── cc</span><br><span class="line">│   │   └── f88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line">        └── v0.0.1</span><br><span class="line"></span><br><span class="line">15 directories, 25 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>.git/refs/tags/v0.0.1</code> 文件内容，可以看到内容恰好是新增的 objects <code>对象名</code>，所以可想而知 <code>ccf8</code> 是一个 <code>tag</code> 类型的对象</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/tags/v0.0.1</span><br><span class="line">ccf88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看新增的 <code>ccf8</code> 文件内容，文件指向了 <code>commit</code> 对象 <code>033f</code></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p ccf8</span><br><span class="line">object <span class="number">033</span>fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line"><span class="keyword">type</span> commit</span><br><span class="line"><span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">0.1</span></span><br><span class="line">tagger liuyanjie <span class="tag">&lt;x@gmail.com&gt;</span> <span class="number">1527523284</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">0.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上查看 <code>.git</code> 目录的变化过程，可以大致分析出Git是如何存储这些文件内容的。</p>
<p>上面只执行了 <code>git add</code> 和 <code>git commit</code> 两条操作。</p>
<h3 id="继续添加文件"><a href="#继续添加文件" class="headerlink" title="继续添加文件"></a>继续添加文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;# CHANGELOG&quot;</span> &gt; CHANGELOG.md</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;# CONTRIBUTING&quot;</span> &gt; CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	CHANGELOG.md</span><br><span class="line">	CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br><span class="line">$ git add CHANGELOG.md CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   CHANGELOG.md</span><br><span class="line">	new file:   CONTRIBUTING.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── cf709bc0991b5340080f944d02894dc1596d46</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── b9e95b39b8cd8ead8bbf4b118104741017de1b</span><br><span class="line">│   ├── cc</span><br><span class="line">│   │   └── f88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line">        └── v0.0.1</span><br><span class="line"></span><br><span class="line">17 directories, 27 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files --stage</span><br><span class="line">100644 a0cf709bc0991b5340080f944d02894dc1596d46 0	CHANGELOG.md</span><br><span class="line">100644 c6b9e95b39b8cd8ead8bbf4b118104741017de1b 0	CONTRIBUTING.md</span><br><span class="line">100644 f3954314c1026028e77ea3a765aadefa67b45195 0	README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分别查看一下各个文件的内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p a0cf</span><br><span class="line"><span class="comment"># CHANGELOG</span></span><br><span class="line"></span><br><span class="line">$ git cat-file -p c6b9</span><br><span class="line"><span class="comment"># CONTRIBUTING</span></span><br><span class="line"></span><br><span class="line">$ git cat-file -p f395</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再查看一下树对象的内容，然而并没有任何变化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p c106</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面提交这两个文件，可以通过日志方便的查看信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --all -m <span class="string">&quot;add CHANGELOG.md and CONTRIBUTING.md files&quot;</span></span><br><span class="line">[master 28baf4f] add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 CHANGELOG.md</span><br><span class="line"> create mode 100644 CONTRIBUTING.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样再看一下<code>.git</code>目录下的内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">│   ├── 28</span><br><span class="line">│   │   └── baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line">│   ├── 2c</span><br><span class="line">│   │   └── affd90cd736e58f516e3988e3af84f5fa42b4f</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── cf709bc0991b5340080f944d02894dc1596d46</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── b9e95b39b8cd8ead8bbf4b118104741017de1b</span><br><span class="line">│   ├── cc</span><br><span class="line">│   │   └── f88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line">        └── v0.0.1</span><br><span class="line"></span><br><span class="line">19 directories, 29 files</span><br></pre></td></tr></table></figure>

<p>查看一下master上的提交日志，刚刚提交内容在新的一行，与首次提交稍微有点差别，首次提交是commit (initial)。</p>
<p>还可以发现第二次提交的第一列和第一次提交的第二列一样，可以猜到，第一列指向上一次的提交对象。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5 28baf4f77fb49abf99c18bc1c12363d898f3ced7 liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800	commit: add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>28ba</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 28ba</span><br><span class="line">tree 2caffd90cd736e58f516e3988e3af84f5fa42b4f</span><br><span class="line">parent 033fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800</span><br><span class="line"></span><br><span class="line">add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相比 <code>033f</code>，<code>28ba</code> 多了 parent 字段 且 parent 字段值是 <code>033f</code></p>
<p>同时 <code>master</code> 也指向了新的提交对象。</p>
<p>第一次产生的提交对象同样存在于目录当中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">28baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在看树对象<code>2caf</code>，发现相比之前，多了两行，分别指向新增加的文件。</p>
<p><code>README.md</code> 文件出现在了 <code>2caf</code> 对象中，实际上，它同时还存在于 <code>c106</code> 对象中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 2caf</span><br><span class="line">100644 blob a0cf709bc0991b5340080f944d02894dc1596d46	CHANGELOG.md</span><br><span class="line">100644 blob c6b9e95b39b8cd8ead8bbf4b118104741017de1b	CONTRIBUTING.md</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p c106</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到现在为止，整个目录下有3个文件，而 <code>.git</code> 目录下已经有多个文件，为了跟踪记录版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">CHANGELOG.md CONTRIBUTING.md README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上 <code>.git</code> 目录变化，可以发现：</p>
<p>每次提交都会产出一 <code>commit</code> 对象，这些 <code>commit</code> 通过 <code>parent</code>，形成一个由高版本到低版本的链表，追溯这个链表，可以回溯到任意版本。</p>
<p><code>commit</code> 对象保存一个 <code>tree</code> 的根节点，根节点下面再包含 <code>blob</code> 或 <code>tree</code>，类似普通文件系统结构，和上面的图一致，从根节点开始，可以找到某一般版本下的所有文件。</p>
<p>在每一颗树下，因为都是使用类似指针的结构，所以每次修改都是将变化的文件，重新创建一个blob文件，并修改相应指针。</p>
<p>目录中的 <code>.git/refs/heads/master</code> 指向某一次提交，当由另外一个分支的时候，会有 <code>.git/refs/heads/branch-xxx</code> 文件指向另外一次提交，而初始时与父分支指向相同。</p>
<h3 id="再添加一个带有目录文件"><a href="#再添加一个带有目录文件" class="headerlink" title="再添加一个带有目录文件"></a>再添加一个带有目录文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;// Author: liuyanjie&quot;</span> &gt; ./lib/index.js</span><br><span class="line"></span><br><span class="line">$ git add lib/index.js</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add lib/index.js&quot;</span> lib/index.js</span><br><span class="line">[master 2b9fc85] add lib/index.js</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 lib/index.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 2b9fc85</span><br><span class="line">tree 9609811e44367d44f2915435f4454716e1e535fd</span><br><span class="line">parent 28baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800</span><br><span class="line"></span><br><span class="line">add lib/index.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 9609</span><br><span class="line">100644 blob a0cf709bc0991b5340080f944d02894dc1596d46	CHANGELOG.md</span><br><span class="line">100644 blob c6b9e95b39b8cd8ead8bbf4b118104741017de1b	CONTRIBUTING.md</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br><span class="line">040000 tree 2fb9045bb558889ea2bd8cc5d8fe45e7247706da	lib</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 2fb9</span><br><span class="line">100644 blob 39a204af28de9b4f0411735e597e0da7416ca35a	index.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面连续几步和之前的效果一样，但是可以看到，在树对象 <code>9609</code> 中，包含了另一个树对象 <code>2fb9</code> ，这个对象的内容指向<code>index.js</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5 28baf4f77fb49abf99c18bc1c12363d898f3ced7 liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800	commit: add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line">28baf4f77fb49abf99c18bc1c12363d898f3ced7 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800	commit: add lib/index.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>git log</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">commit 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 (HEAD -&gt; master)</span><br><span class="line">Author: liuyanjie &lt;x@gmail.com&gt;</span><br><span class="line">Date:   Tue May 29 09:19:05 2018 +0800</span><br><span class="line"></span><br><span class="line">    add lib/index.js</span><br><span class="line"></span><br><span class="line">commit 28baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line">Author: liuyanjie &lt;x@gmail.com&gt;</span><br><span class="line">Date:   Tue May 29 00:20:52 2018 +0800</span><br><span class="line"></span><br><span class="line">    add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line"></span><br><span class="line">commit 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 (tag: v0.0.1)</span><br><span class="line">Author: liuyanjie &lt;x@gmail.com&gt;</span><br><span class="line">Date:   Mon May 28 23:38:14 2018 +0800</span><br><span class="line"></span><br><span class="line">    First Commmit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开始创建分支"><a href="#开始创建分支" class="headerlink" title="开始创建分支"></a>开始创建分支</h3><p>创建并切换到分支 <code>feature-a</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line">* master 2b9fc85 add lib/index.js</span><br><span class="line"></span><br><span class="line">$ git checkout -b feature-a</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature-a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># liuyanjie @ bmw in ~/git-obj-model on git:feature-a o [9:25:01]</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line">* feature-a 2b9fc85 add lib/index.js</span><br><span class="line">  master    2b9fc85 add lib/index.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-a</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           ├── feature-a</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">│   ├── 28</span><br><span class="line">│   │   └── baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line">│   ├── 2b</span><br><span class="line">│   │   └── 9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line">│   ├── 2c</span><br><span class="line">│   │   └── affd90cd736e58f516e3988e3af84f5fa42b4f</span><br><span class="line">│   ├── 2f</span><br><span class="line">│   │   └── b9045bb558889ea2bd8cc5d8fe45e7247706da</span><br><span class="line">│   ├── 39</span><br><span class="line">│   │   └── a204af28de9b4f0411735e597e0da7416ca35a</span><br><span class="line">│   ├── 96</span><br><span class="line">│   │   └── 09811e44367d44f2915435f4454716e1e535fd</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── cf709bc0991b5340080f944d02894dc1596d46</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── b9e95b39b8cd8ead8bbf4b118104741017de1b</span><br><span class="line">│   ├── cc</span><br><span class="line">│   │   └── f88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   ├── feature-a</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line">        └── v0.0.1</span><br><span class="line"></span><br><span class="line">23 directories, 35 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下<code>.git</code>文件内容，可以看到<code>.git/refs/heads</code>目录下多了个<code>feature-a</code></p>
<p>查看一下 <code>feature-a</code> 的相关内容，指向的提交对象和 <code>master</code> 一样，并指明 <code>Created from HEAD</code>。</p>
<p>从内容中可以看出，两个分支指向同一个提交对象 <code>1ad0e5</code>，但是两个分支的日志不同。</p>
<p>日志记录了分支的历史，而提交对象记录了分支的数据内容和所有分支的历史。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/logs/refs/heads/feature-a</span><br><span class="line">0000000000000000000000000000000000000000 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527557101 +0800	branch: Created from HEAD</span><br><span class="line"></span><br><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5 28baf4f77fb49abf99c18bc1c12363d898f3ced7 liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800	commit: add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line">28baf4f77fb49abf99c18bc1c12363d898f3ced7 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800	commit: add lib/index.js</span><br></pre></td></tr></table></figure>

<p>初始化<code>package.json</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">Is this ok? (yes)</span><br></pre></td></tr></table></figure>

<p>安装 <code>bluebird</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install bluebird --save</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN git-obj-model@1.0.0 No description</span><br><span class="line">npm WARN git-obj-model@1.0.0 No repository field.</span><br><span class="line"></span><br><span class="line">+ bluebird@3.5.1</span><br><span class="line">added 1 package <span class="keyword">in</span> 1.999s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加文件到版本库，并查看变化。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add package.json</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提交文件到版本库，并查看变化，提交指针已经指向新的提交对象，分支的版本超前于master，因为parent指向<code>1ad0e5</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git commit package.json -m <span class="string">&#x27;add package.json&#x27;</span></span><br><span class="line">[feature-a 74ce192] add package.json</span><br><span class="line"> 1 file changed, 17 insertions(+)</span><br><span class="line"> create mode 100644 package.json</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">74ce19245be785772b33e1193df0d2c6a940ed10</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 74ce</span><br><span class="line">tree 9d23f8ad2ecc9f8e49d78174bcc6e4668ca7f031</span><br><span class="line">parent 2b9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527557656 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527557656 +0800</span><br><span class="line"></span><br><span class="line">add package.json</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 9d23</span><br><span class="line">100644 blob a0cf709bc0991b5340080f944d02894dc1596d46	CHANGELOG.md</span><br><span class="line">100644 blob c6b9e95b39b8cd8ead8bbf4b118104741017de1b	CONTRIBUTING.md</span><br><span class="line">100644 blob f3954314c1026028e77ea3a765aadefa67b45195	README.md</span><br><span class="line">040000 tree 2fb9045bb558889ea2bd8cc5d8fe45e7247706da	lib</span><br><span class="line">100644 blob 5ee275ce022007c38d187c58aef13f8d9e04b553	package.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>合并分支 <code>feature-a</code> 到 <code>master</code> 分支，可以看到 <code>master</code> 分支跟上了 <code>feature-a</code>，只改指针既可，非常快。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git merge feature-a --no-ff</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> package.json | 17 +++++++++++++++++</span><br><span class="line"> 1 file changed, 17 insertions(+)</span><br><span class="line"> create mode 100644 package.json</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">b98c36254dba6e169429c2be57b1bbeccb6e1f28</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">74ce19245be785772b33e1193df0d2c6a940ed10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tig</span><br><span class="line"></span><br><span class="line">2018-05-29 09:37 liuyanjie M─┐ [master] Merge branch <span class="string">&#x27;feature-a&#x27;</span></span><br><span class="line">2018-05-29 09:34 liuyanjie │ o [feature-a] add package.json</span><br><span class="line">2018-05-29 09:19 liuyanjie o─┘ add lib/index.js</span><br><span class="line">2018-05-29 00:20 liuyanjie o add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line">2018-05-28 23:38 liuyanjie I &lt;v0.0.1&gt; First Commmit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改 <code>master</code> 分支，编辑文件并提交</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Already on <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;\n\n# About&quot;</span> &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">$ git commit README.md -m <span class="string">&quot;add About Me&quot;</span></span><br><span class="line">[master cc52745] add About Me</span><br><span class="line"> 1 file changed, 4 insertions(+)</span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># About</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>feature-a</code> 分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout feature-a</span><br><span class="line">Switched to branch <span class="string">&#x27;feature-a&#x27;</span></span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;\n\n# About&quot;</span> &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># About</span></span><br><span class="line"></span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit README.md -m <span class="string">&quot;add About Me&quot;</span></span><br><span class="line">[feature-a fd885cf] add About Me</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看分支头和历史记录，可以看到分支头指向不同的提交对象，而提交对象，又来源于同一个提交对象<code>0cb214741c044af3fb4677fe72e3ae175f3e0358</code>，两个分支之间存在交叉。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">74ce19245be785772b33e1193df0d2c6a940ed10</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">cc52745b13b00c672c7ac9b1dc42336953293b7a</span><br><span class="line"></span><br><span class="line">$ cat .git/logs/refs/heads/feature-a</span><br><span class="line">0000000000000000000000000000000000000000 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527557101 +0800	branch: Created from HEAD</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6 74ce19245be785772b33e1193df0d2c6a940ed10 liuyanjie &lt;x@gmail.com&gt; 1527557656 +0800	commit: add package.json</span><br><span class="line">74ce19245be785772b33e1193df0d2c6a940ed10 fd885cfcd548a24fabb2f5b49ea60beadc8c5912 liuyanjie &lt;x@gmail.com&gt; 1527558668 +0800	commit: add About Me</span><br><span class="line"></span><br><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5 28baf4f77fb49abf99c18bc1c12363d898f3ced7 liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800	commit: add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line">28baf4f77fb49abf99c18bc1c12363d898f3ced7 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800	commit: add lib/index.js</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6 b98c36254dba6e169429c2be57b1bbeccb6e1f28 liuyanjie &lt;x@gmail.com&gt; 1527557853 +0800	merge feature-a: Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line">b98c36254dba6e169429c2be57b1bbeccb6e1f28 cc52745b13b00c672c7ac9b1dc42336953293b7a liuyanjie &lt;x@gmail.com&gt; 1527558514 +0800	commit: add About Me</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>切换到 <code>master</code> 分支，再次合并 <code>feature-a</code> 到 <code>master</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git merge feature-a</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">$ cat README.md</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">## About</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">## About</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature-a</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>解决冲突之后的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.md</span><br><span class="line"><span class="comment"># Readme</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## About</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit README.md -m <span class="string">&#x27;fix conflict&#x27;</span></span><br><span class="line">fatal: cannot <span class="keyword">do</span> a partial commit during a merge.</span><br><span class="line"></span><br><span class="line">$ git commit -a</span><br><span class="line">[master 5a68c74] Merge branch <span class="string">&#x27;feature-a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/feature-a</span><br><span class="line">fd885cfcd548a24fabb2f5b49ea60beadc8c5912</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">5a68c7402c30ae44fd82dadba2d8f148efb75541</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/logs/refs/heads/master</span><br><span class="line">0000000000000000000000000000000000000000 033fa1ab71f0d54f348f07a3a0ffcefd52804df5 liuyanjie &lt;x@gmail.com&gt; 1527521894 +0800	commit (initial): First Commmit</span><br><span class="line">033fa1ab71f0d54f348f07a3a0ffcefd52804df5 28baf4f77fb49abf99c18bc1c12363d898f3ced7 liuyanjie &lt;x@gmail.com&gt; 1527524452 +0800	commit: add CHANGELOG.md and CONTRIBUTING.md files</span><br><span class="line">28baf4f77fb49abf99c18bc1c12363d898f3ced7 2b9fc8524bac21d5d5c2f988b5793315ce93abc6 liuyanjie &lt;x@gmail.com&gt; 1527556745 +0800	commit: add lib/index.js</span><br><span class="line">2b9fc8524bac21d5d5c2f988b5793315ce93abc6 b98c36254dba6e169429c2be57b1bbeccb6e1f28 liuyanjie &lt;x@gmail.com&gt; 1527557853 +0800	merge feature-a: Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line">b98c36254dba6e169429c2be57b1bbeccb6e1f28 cc52745b13b00c672c7ac9b1dc42336953293b7a liuyanjie &lt;x@gmail.com&gt; 1527558514 +0800	commit: add About Me</span><br><span class="line">cc52745b13b00c672c7ac9b1dc42336953293b7a 5a68c7402c30ae44fd82dadba2d8f148efb75541 liuyanjie &lt;x@gmail.com&gt; 1527559277 +0800	commit (merge): Merge branch <span class="string">&#x27;feature-a&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --<span class="built_in">stat</span> feature-a</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">$ git branch -d feature-a</span><br><span class="line">Deleted branch feature-a (was fd885cf).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line">$ git cat-file -p fd88</span><br><span class="line">tree 82e47e13f87031cab7c47b455744bc4ed3fdba3c</span><br><span class="line">parent 74ce19245be785772b33e1193df0d2c6a940ed10</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527558668 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527558668 +0800</span><br><span class="line"></span><br><span class="line">add About Me</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 5a68</span><br><span class="line">tree 42564bab966d59e3501a1903c1cb2066adc2bd2d</span><br><span class="line">parent cc52745b13b00c672c7ac9b1dc42336953293b7a</span><br><span class="line">parent fd885cfcd548a24fabb2f5b49ea60beadc8c5912</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527559277 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527559277 +0800</span><br><span class="line"></span><br><span class="line">Merge branch <span class="string">&#x27;feature-a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --all --pretty=format:<span class="string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --date=relative</span><br><span class="line">*   5a68c74 - (HEAD -&gt; master) Merge branch <span class="string">&#x27;feature-a&#x27;</span> (7 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">|\</span><br><span class="line">| * fd885cf - add About Me (17 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">* | cc52745 - add About Me (20 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">* |   b98c362 - Merge branch <span class="string">&#x27;feature-a&#x27;</span> (31 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">|\ \</span><br><span class="line">| |/</span><br><span class="line">| * 74ce192 - add package.json (34 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">|/</span><br><span class="line">* 2b9fc85 - add lib/index.js (49 minutes ago) &lt;liuyanjie&gt;</span><br><span class="line">* 28baf4f - add CHANGELOG.md and CONTRIBUTING.md files (10 hours ago) &lt;liuyanjie&gt;</span><br><span class="line">* 033fa1a - (tag: v0.0.1) First Commmit (11 hours ago) &lt;liuyanjie&gt;</span><br></pre></td></tr></table></figure>

<p>配置命令别名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.lg <span class="string">&quot;log --graph --all --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span></span><br><span class="line">git lg</span><br></pre></td></tr></table></figure>

<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.0.2 -m <span class="string">&quot;v0.0.2&quot;</span></span><br><span class="line">v0.0.1</span><br><span class="line">v0.0.2</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v0.0.2</span><br><span class="line">174c530154ab3b4d4d322bcbd66cdde18882eb00</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 174c</span><br><span class="line">object 5a68c7402c30ae44fd82dadba2d8f148efb75541</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v0.0.2</span><br><span class="line">tagger liuyanjie &lt;x@gmail.com&gt; 1527559851 +0800</span><br><span class="line"></span><br><span class="line">v0.0.2</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 5a68</span><br><span class="line">tree 42564bab966d59e3501a1903c1cb2066adc2bd2d</span><br><span class="line">parent cc52745b13b00c672c7ac9b1dc42336953293b7a</span><br><span class="line">parent fd885cfcd548a24fabb2f5b49ea60beadc8c5912</span><br><span class="line">author liuyanjie &lt;x@gmail.com&gt; 1527559277 +0800</span><br><span class="line">committer liuyanjie &lt;x@gmail.com&gt; 1527559277 +0800</span><br><span class="line"></span><br><span class="line">Merge branch <span class="string">&#x27;feature-a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">$ tree .git</span><br><span class="line">.git</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── HEAD</span><br><span class="line">├── ORIG_HEAD</span><br><span class="line">├── co.gitup.mac</span><br><span class="line">│   ├── cache.db</span><br><span class="line">│   ├── info.plist</span><br><span class="line">│   └── snapshots.data</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── logs</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   └── refs</span><br><span class="line">│       └── heads</span><br><span class="line">│           └── master</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 03</span><br><span class="line">│   │   └── 3fa1ab71f0d54f348f07a3a0ffcefd52804df5</span><br><span class="line">│   ├── 17</span><br><span class="line">│   │   └── 4c530154ab3b4d4d322bcbd66cdde18882eb00</span><br><span class="line">│   ├── 28</span><br><span class="line">│   │   └── baf4f77fb49abf99c18bc1c12363d898f3ced7</span><br><span class="line">│   ├── 2b</span><br><span class="line">│   │   └── 9fc8524bac21d5d5c2f988b5793315ce93abc6</span><br><span class="line">│   ├── 2c</span><br><span class="line">│   │   └── affd90cd736e58f516e3988e3af84f5fa42b4f</span><br><span class="line">│   ├── 2f</span><br><span class="line">│   │   └── b9045bb558889ea2bd8cc5d8fe45e7247706da</span><br><span class="line">│   ├── 30</span><br><span class="line">│   │   └── be8054b61a4a124e4cd8a1201de8474cb45e12</span><br><span class="line">│   ├── 39</span><br><span class="line">│   │   └── a204af28de9b4f0411735e597e0da7416ca35a</span><br><span class="line">│   ├── 42</span><br><span class="line">│   │   └── 564bab966d59e3501a1903c1cb2066adc2bd2d</span><br><span class="line">│   ├── 44</span><br><span class="line">│   │   └── 2b821b9b4acb5b0e632042542b3b29e2cf721e</span><br><span class="line">│   ├── 48</span><br><span class="line">│   │   └── 1cab7467cdb697bf7affdba0f2a5673a03366d</span><br><span class="line">│   ├── 5a</span><br><span class="line">│   │   └── 68c7402c30ae44fd82dadba2d8f148efb75541</span><br><span class="line">│   ├── 5e</span><br><span class="line">│   │   └── e275ce022007c38d187c58aef13f8d9e04b553</span><br><span class="line">│   ├── 74</span><br><span class="line">│   │   └── ce19245be785772b33e1193df0d2c6a940ed10</span><br><span class="line">│   ├── 82</span><br><span class="line">│   │   └── e47e13f87031cab7c47b455744bc4ed3fdba3c</span><br><span class="line">│   ├── 96</span><br><span class="line">│   │   └── 09811e44367d44f2915435f4454716e1e535fd</span><br><span class="line">│   ├── 9d</span><br><span class="line">│   │   └── 23f8ad2ecc9f8e49d78174bcc6e4668ca7f031</span><br><span class="line">│   ├── a0</span><br><span class="line">│   │   └── cf709bc0991b5340080f944d02894dc1596d46</span><br><span class="line">│   ├── b9</span><br><span class="line">│   │   └── 8c36254dba6e169429c2be57b1bbeccb6e1f28</span><br><span class="line">│   ├── c1</span><br><span class="line">│   │   └── 067ba0a7ba51f937518c9bc051ea744ca748fe</span><br><span class="line">│   ├── c6</span><br><span class="line">│   │   └── b9e95b39b8cd8ead8bbf4b118104741017de1b</span><br><span class="line">│   ├── cc</span><br><span class="line">│   │   ├── 52745b13b00c672c7ac9b1dc42336953293b7a</span><br><span class="line">│   │   └── f88a6f1649213499841c33f9bb36d1d8756fb7</span><br><span class="line">│   ├── f3</span><br><span class="line">│   │   └── 954314c1026028e77ea3a765aadefa67b45195</span><br><span class="line">│   ├── fd</span><br><span class="line">│   │   └── 885cfcd548a24fabb2f5b49ea60beadc8c5912</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    └── tags</span><br><span class="line">        ├── v0.0.1</span><br><span class="line">        └── v0.0.2</span><br><span class="line"></span><br><span class="line">36 directories, 51 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/964876/head-and-orig-head-in-git">https://stackoverflow.com/questions/964876/head-and-orig-head-in-git</a></p>
<p>.git/HEAD 指明了当前活跃分支是哪个分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/vcs/git/images/git-obj-model.svg">svg版</a></p>
<p><img data-src="https://raw.githubusercontent.com/liuyanjie/knowledge/master/vcs/git/images/git-obj-model.png" alt="git-obj-model"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/vcs/git/git-object-model.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/vcs/git/git-object-model.md">编辑源文件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/node.js/libuv/8-libuv-threadpool/" class="post-title-link" itemprop="url">libuv源码分析（八）线程池（Threadpool）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-23 15:00:08" itemprop="dateCreated datePublished" datetime="2019-04-23T15:00:08+08:00">2019-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-08 16:18:19" itemprop="dateModified" datetime="2021-05-08T16:18:19+08:00">2021-05-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/node.js/libuv/8-libuv-threadpool/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/node.js/libuv/8-libuv-threadpool/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多线程在程序设计中是常用的提升并发计算能力、提升吞吐量的常用手段，线程通常事先创建好，形成线程池，来对线程进行管理。</p>
<p>libuv 内部也实现了线程池，主要用于支持异步任务，在 libuv 中，线程池是和事件循环配合工作的。</p>
<p>libuv 提供可用于执行用户代码的线程池，并且能够在任务完成时，向事件循环线程发送消息通知主线程完成收尾工作。</p>
<p>默认情况下，线程池的大小是 <code>4</code>，但是可以在启动阶段通过设置 <code>UV_THREADPOOL_SIZE</code> 环境变量进行修改，最大为 <code>128</code>。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>线程池是全局的结构，所以所有的事件循环实例共享同一个线程池，当特定的函数使用线程池时（例如，调用 <code>uv_queue_work()</code>），libuv 通过 <code>init_threads</code> 函数预分配和初始化一定数量的线程，初始化函数只会被调用一次，这会带来一定的内存开销，但是可以提升运行时性能。</p>
<h3 id="线程池初始化"><a href="#线程池初始化" class="headerlink" title="线程池初始化"></a>线程池初始化</h3><p>线程池是由 <code>init_threads</code> 函数初始化的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_threads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* val;</span><br><span class="line">  <span class="keyword">uv_sem_t</span> sem;</span><br><span class="line"></span><br><span class="line">  nthreads = ARRAY_SIZE(default_threads);</span><br><span class="line">  val = getenv(<span class="string">&quot;UV_THREADPOOL_SIZE&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val != <span class="literal">NULL</span>)</span><br><span class="line">    nthreads = atoi(val);</span><br><span class="line">  <span class="keyword">if</span> (nthreads == <span class="number">0</span>)</span><br><span class="line">    nthreads = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (nthreads &gt; MAX_THREADPOOL_SIZE)</span><br><span class="line">    nthreads = MAX_THREADPOOL_SIZE;</span><br><span class="line"></span><br><span class="line">  threads = default_threads;</span><br><span class="line">  <span class="keyword">if</span> (nthreads &gt; ARRAY_SIZE(default_threads)) &#123;</span><br><span class="line">    threads = uv__malloc(nthreads * <span class="keyword">sizeof</span>(threads[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      nthreads = ARRAY_SIZE(default_threads);</span><br><span class="line">      threads = default_threads;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_cond_init(&amp;cond))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_mutex_init(&amp;mutex))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  QUEUE_INIT(&amp;wq);</span><br><span class="line">  QUEUE_INIT(&amp;slow_io_pending_wq);</span><br><span class="line">  QUEUE_INIT(&amp;run_slow_work_message);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化逻辑如下：</p>
<ol>
<li>线程池中线程数量，并分配用于存储线程信息的内存空间；</li>
<li>初始化静态全局的 <code>线程锁</code> 和 <code>线程条件变量</code>；</li>
<li>初始化静态全局 <code>uv__work</code> 队列；<ol>
<li><code>wq</code> 待执行的任务队列，未执行完毕，<code>loop-&gt;wq</code> 同为任务队列，但是保持的是执行完毕的任务；</li>
<li><code>slow_io_pending_wq</code> 慢IO延迟任务队列；</li>
<li><code>run_slow_work_message</code> 慢IO延迟任务队列代表，当存在慢IO延迟任务队列时，<code>run_slow_work_message</code> 被插入到 <code>wq</code> 中代替所有慢IO任务排队；</li>
</ol>
</li>
<li>创建一定数量的线程；</li>
<li>等待所以线程创建完成。</li>
</ol>
<p>在创建线程的时候，线程执行的函数是 <code>worker</code>，该函数负责在线程中处理 <code>wq</code> 上的任务。</p>
<p><code>worker</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To avoid deadlock with uv_cancel() it&#x27;s crucial that the worker</span></span><br><span class="line"><span class="comment"> * never holds the global mutex and the loop-local mutex at the same time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">int</span> is_slow_work;</span><br><span class="line"></span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁 mutex</span></span><br><span class="line">  <span class="comment">// 因为只有一个线程能抢占锁，所以多个线程也只能一个接一个的进入循环</span></span><br><span class="line">  <span class="comment">// 因为整个线程池中线程创建过程中不会出现其他线程在其他位置抢占并锁定 mutex 的情形出现，</span></span><br><span class="line">  <span class="comment">// 所以只有该位置会抢占加锁，而后很快释放锁，所以线程池中的线程之后短暂的阻塞在这里。</span></span><br><span class="line">  <span class="comment">// 工作线程需要不断的等待处理任务，所以需要进入死循环</span></span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* `mutex` should always be locked at this point. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep waiting while either no work is present or only slow I/O</span></span><br><span class="line"><span class="comment">       and we&#x27;re at the threshold for that. */</span></span><br><span class="line">    <span class="comment">// 条件满足时，没有任务需要处理，线程进入挂起等待状态，等待被唤醒。</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      <span class="comment">// 任务队列为空</span></span><br><span class="line">      QUEUE_EMPTY(&amp;wq) ||</span><br><span class="line">      <span class="comment">// 任务队列非空，但是</span></span><br><span class="line">           <span class="comment">// 队列头部被标记为慢速IO任务</span></span><br><span class="line">           <span class="comment">// 且该队列中只有run_slow_work_message一个数据节点</span></span><br><span class="line">           <span class="comment">// 且正在处理的慢IO任务超过阈值（默认2）</span></span><br><span class="line">           <span class="comment">//   该一个条件避免太多线程同时都在处理慢IO操作</span></span><br><span class="line">           <span class="comment">//   达到阈值后空闲的线程不再接慢IO任务而是挂起，等待非慢IO操作任务 能有机会尽快得到处理</span></span><br><span class="line">           <span class="comment">//   正在进行的慢IO任务完成后，阈值限制解除，可以接慢IO任务</span></span><br><span class="line">           <span class="comment">//   最终，保证了最多只有 `(nthreads + 1) / 2` 个线程处理慢IO</span></span><br><span class="line">           <span class="comment">//   区分了快车道和慢车道后，能有效避免慢车堵快车，提升性能</span></span><br><span class="line">           (QUEUE_HEAD(&amp;wq) == &amp;run_slow_work_message</span><br><span class="line">           &amp;&amp; QUEUE_NEXT(&amp;run_slow_work_message) == &amp;wq </span><br><span class="line">           &amp;&amp; slow_io_work_running &gt;= slow_work_thread_threshold())) &#123;</span><br><span class="line">      <span class="comment">// 进入休息区，注意某线程在执行 while 循环时该线程一定抢占了 mutex，不论是首次还是后续执行</span></span><br><span class="line">      <span class="comment">// 线程挂起，等待唤醒</span></span><br><span class="line">      <span class="comment">// uv_cond_wait 会使线程挂起等待cond上的信号，为防止多线程同时调用 uv_cond_wait，必须提前加锁</span></span><br><span class="line">      <span class="comment">// uv_cond_wait 在挂起前会释放 mutex，其他阻塞在 mutex 上的线程会在 mutex 释放时被唤醒，并在唤醒时重新抢占 mutex，即只能唤醒一个</span></span><br><span class="line">      <span class="comment">// 所以，阻塞在for循环外的多个线程中的某一个会重新抢占 mutex 执行到达此处挂起，又继续唤醒其他线程</span></span><br><span class="line">      <span class="comment">//   也可能唤醒 阻塞在 uv__work_submit -&gt; post 函数提交任务的抢占锁的位置的线程（通常为主事件循环线程）</span></span><br><span class="line">      <span class="comment">// 挂起的线程都是空闲的线程，被唤醒后为非空闲的线程，所以需要更新空闲线程计数</span></span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);    </span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 挂起的线程在被唤醒后，一定不满足再次进入循环的条件，会继续向下执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入工作区，一共有三个区间，前后两个区间都有锁，中间的区间执行用户代码无锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程被唤醒，开始干活</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下操作因线程被唤醒时会自动对mutex上锁</span></span><br><span class="line">    <span class="comment">// 所以以下解锁前的区域对共享变量的操作都是安全的</span></span><br><span class="line">    <span class="comment">// 锁定区间代码同一时段只能有一个线程在执行</span></span><br><span class="line">    <span class="comment">// 因并无耗时任务，所以不会影响性能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务</span></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    <span class="comment">// 如果收到线程退出消息，跳出循环，线程声明周期结束</span></span><br><span class="line">    <span class="comment">// 在外部发送消息通知线程主动退出，也可在外部kill线程</span></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message) &#123;</span><br><span class="line">      uv_cond_signal(&amp;cond);</span><br><span class="line">      uv_mutex_unlock(&amp;mutex);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将任务摘出来</span></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);  <span class="comment">/* Signal uv_cancel() that the work req is executing. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化慢IO操作标记为0，即非慢IO操作</span></span><br><span class="line">    is_slow_work = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q == &amp;run_slow_work_message) &#123;</span><br><span class="line">      <span class="comment">// 该任务为慢IO任务</span></span><br><span class="line">      <span class="comment">// 通常情况下，while 的第二个条件成立才能进入此段代码</span></span><br><span class="line">      <span class="comment">// 此时 q 只是一个慢IO任务标记，真正的任务在 slow_io_pending_wq 中</span></span><br><span class="line">      <span class="comment">// 所以需要特殊处理，获取真正的任务 q</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we&#x27;re at the slow I/O threshold, re-schedule until after all</span></span><br><span class="line"><span class="comment">         other work in the queue is done. */</span></span><br><span class="line">      <span class="comment">// 如果当前运行的慢IO操作的线程数达到阈值（2个线程）</span></span><br><span class="line">      <span class="comment">// 则将这些操作插入到 wq 队列末尾，延迟处理</span></span><br><span class="line">      <span class="comment">// 避免多个线程同时处理慢IO</span></span><br><span class="line">      <span class="comment">// 临界状态：已经有达到阈值限制个数的线程进入工作区处理慢IO任务，但是还没执行更新慢IO线程计数器代码，</span></span><br><span class="line">      <span class="comment">//         后续被慢IO任务唤醒的线程线程可能因为慢IO线程计数器未更新而满足进入条件。</span></span><br><span class="line">      <span class="comment">//         但是，因为该区间锁定了 mutex，阻塞在 uv_cond_wait 处的代码无法抢占锁无法执行，也就是无法跳出 while 循环，</span></span><br><span class="line">      <span class="comment">//         到 mutex 释放时，被唤醒的线程能够抢占锁时，计数器已经被更新了，前面所说的进入条件不再满足了。</span></span><br><span class="line">      <span class="comment">//    所以，条件满足时不能动，能动了条件又不满足了，本质上，两次判断在同一段锁定区间，所以以下情形应该难以出现，难道还有其他情况？</span></span><br><span class="line">      <span class="keyword">if</span> (slow_io_work_running &gt;= slow_work_thread_threshold()) &#123;</span><br><span class="line">        QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we encountered a request to run slow I/O work but there is none</span></span><br><span class="line"><span class="comment">         to run, that means it&#x27;s cancelled =&gt; Start over. */</span></span><br><span class="line">      <span class="comment">// 如果慢IO队列为空，可能任务被取消</span></span><br><span class="line">      <span class="keyword">if</span> (QUEUE_EMPTY(&amp;slow_io_pending_wq))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意以上两处不需要 uv_mutex_unlock(&amp;mutex)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记该线程正在处理慢IO操作，同时增加慢IO线程计数器</span></span><br><span class="line">      is_slow_work = <span class="number">1</span>;</span><br><span class="line">      slow_io_work_running++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从慢IO队列中重新获取任务</span></span><br><span class="line">      q = QUEUE_HEAD(&amp;slow_io_pending_wq);</span><br><span class="line">      QUEUE_REMOVE(q);</span><br><span class="line">      QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If there is more slow I/O work, schedule it to be run as well. */</span></span><br><span class="line">      <span class="comment">// 如果还有更多的慢IO操作，则将这些任务插入到 wq 队列末尾，本次只能处理 q 这一个任务</span></span><br><span class="line">      <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;slow_io_pending_wq)) &#123;</span><br><span class="line">        QUEUE_INSERT_TAIL(&amp;wq, &amp;run_slow_work_message);</span><br><span class="line">        <span class="comment">// 如果有空闲线程，唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">          uv_cond_signal(&amp;cond);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁 mutex</span></span><br><span class="line">    uv_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有以下两行不涉及竞态资源读写，不需要加锁，实际也不能锁</span></span><br><span class="line">    <span class="comment">// 慢IO任务还是非慢IO任务，指的是w-&gt;work</span></span><br><span class="line">    w = QUEUE_DATA(q, struct uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 loop 在多线程中共享，所以访问 loop 需要加锁</span></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  <span class="comment">/* Signal uv_cancel() that the work req is done</span></span><br><span class="line"><span class="comment">                        executing. */</span></span><br><span class="line">    <span class="comment">// 将完成的任务插入到 loop-&gt;wq 队列中，在主事件循环线程中处理</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    <span class="comment">// 发送完成信号，唤醒事件询线程并处理</span></span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lock `mutex` since that is expected at the start of the next</span></span><br><span class="line"><span class="comment">     * iteration. */</span></span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (is_slow_work) &#123;</span><br><span class="line">      <span class="comment">/* `slow_io_work_running` is protected by `mutex`. */</span></span><br><span class="line">      slow_io_work_running--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv_async_send</code> 已经分析过了，它向事件循环线程发送消息唤醒事件循环线程</p>
<h3 id="主线程中的初始化工作"><a href="#主线程中的初始化工作" class="headerlink" title="主线程中的初始化工作"></a>主线程中的初始化工作</h3><p>主线程中的初始化工作是先于线程池初始化的，这部分初始化完成了用于接收 work 线程消息的 AsyncHandle 的初始化工作。</p>
<p><code>uv_async_send</code> 通过 <code>loop-&gt;wq_async</code> Handle 发送了消息，字段定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_PRIVATE_FIELDS                                                \</span></span><br><span class="line"><span class="meta">  uv_mutex_t wq_mutex;                                                        \</span></span><br><span class="line"><span class="meta">  uv_async_t wq_async;                                                        \</span></span><br></pre></td></tr></table></figure>

<p><code>loop-&gt;wq_async</code> 是在 <code>uv_loop_init</code> 初始化的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_loop_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">  loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loop-&gt;wq_async</code> 被解引用了，所以并不会影响 <code>loop</code> 的活动状态。</p>
<p><code>loop-&gt;wq_async</code> 的事件处理函数是 <code>uv__work_done</code>，该函数在事件循环线程中执行，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_done</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  <span class="keyword">uv_loop_t</span>* loop;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE wq;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出所有已完成的work，因与其他线程共享此变量，所以需要同步，因此此处可能会导致事件循环线程短暂阻塞</span></span><br><span class="line">  loop = container_of(handle, <span class="keyword">uv_loop_t</span>, wq_async);</span><br><span class="line">  uv_mutex_lock(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;wq, &amp;wq);</span><br><span class="line">  uv_mutex_unlock(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有已完成的work，调用 w-&gt;done，done 函数由用户提供</span></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line"></span><br><span class="line">    w = container_of(q, struct uv__work, wq);</span><br><span class="line">    err = (w-&gt;work == uv__cancelled) ? UV_ECANCELED : <span class="number">0</span>;</span><br><span class="line">    w-&gt;done(w, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，从线程池初始化到线程处理任务再到线程与事件循环线程通信最后事件循环线程清理已完成的任务的整个流程已经分析完成。</p>
<p>下面，该了解一下，如何向线程池提交任务任务了。</p>
<h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><p>向线程池提交任务的 API 是 <code>uv_queue_work</code>，也实现线程池唯一对外暴露的 API，下面我们看它的具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_queue_work</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">uv_work_t</span>* req,</span></span></span><br><span class="line"><span class="params"><span class="function">                  uv_work_cb work_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  uv_after_work_cb after_work_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  uv__req_init(loop, req, UV_WORK);</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;work_cb = work_cb;</span><br><span class="line">  req-&gt;after_work_cb = after_work_cb;</span><br><span class="line">  uv__work_submit(loop,</span><br><span class="line">                  &amp;req-&gt;work_req,</span><br><span class="line">                  UV__WORK_CPU,</span><br><span class="line">                  uv__queue_work,</span><br><span class="line">                  uv__queue_done);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv_queue_work</code> 初始化了一个 <code>uv_work_t</code> 类型的 <code>request</code>，<code>work_cb</code> 为线程池中线程执行的函数，<code>after_work_cb</code> 为 <code>work_cb</code> 执行完成之后在事件循环线程中执行的函数，<code>req-&gt;work_req</code> 是队列节点。最后通过 <code>uv__work_submit</code> 向线程池中提交任务。</p>
<p>最后通过调用 <code>uv__work_submit</code> 向线程池中提交任务，<code>uv__work_submit</code> 的两个实参 <code>uv__queue_work</code> 和 <code>uv__queue_done</code> 分别对 <code>work_cb</code> 和 <code>after_work_cb</code> 进行简单的封装。实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__queue_work</span><span class="params">(struct uv__work* w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_work_t</span>* req = container_of(w, <span class="keyword">uv_work_t</span>, work_req);</span><br><span class="line"></span><br><span class="line">  req-&gt;work_cb(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__queue_done</span><span class="params">(struct uv__work* w, <span class="keyword">int</span> err)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_work_t</span>* req;</span><br><span class="line"></span><br><span class="line">  req = container_of(w, <span class="keyword">uv_work_t</span>, work_req);</span><br><span class="line">  uv__req_unregister(req-&gt;loop, req);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;after_work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  req-&gt;after_work_cb(req, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__work_submit</code> 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct uv__work* w,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">enum</span> uv__work_kind kind,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">void</span> (*work)(struct uv__work* w),</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">void</span> (*done)(struct uv__work* w, <span class="keyword">int</span> status))</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq, kind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__work_submit</code> 通过调用 <code>init_once</code> 初始化线程池，<code>uv_once</code> 确保线程池初始化函数 <code>init_once</code> 只会被调用一次。</p>
<p>然后对 <code>uv__work</code> 进行初始化，<code>w-&gt;work</code> 在工作线程 <code>worker</code> 中调用，<code>w-&gt;done</code> 在事件循环线程 <code>uv__work_done</code> 中调用</p>
<p>最后通过调用 <code>post</code> 提交任务，<code>post</code> 实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(QUEUE* q, <span class="keyword">enum</span> uv__work_kind kind)</span> </span>&#123;</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">if</span> (kind == UV__WORK_SLOW_IO) &#123;</span><br><span class="line">    <span class="comment">/* Insert into a separate queue. */</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;slow_io_pending_wq, q);</span><br><span class="line">    <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;run_slow_work_message)) &#123;</span><br><span class="line">      <span class="comment">/* Running slow I/O tasks is already scheduled =&gt; Nothing to do here.</span></span><br><span class="line"><span class="comment">         The worker that runs said other task will schedule this one as well. */</span></span><br><span class="line">      uv_mutex_unlock(&amp;mutex);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;run_slow_work_message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">  <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">    uv_cond_signal(&amp;cond);</span><br><span class="line">  uv_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为任务队列会被线程池中的多个线程并发访问，所以在操作队列之前需要先加锁，完成之后需要解锁。如果有空闲的线程，则立即唤醒它们进行工作。</p>
<p>在 <code>post</code> 中，慢IO任务被插入到 <code>slow_io_pending_wq</code> 队列中，如果 <code>run_slow_work_message</code> 不在 <code>wq</code> 中，则需要将 <code>run_slow_work_message</code> 插入 <code>wq</code> 队列尾部，标识 <code>slow_io_pending_wq</code> 中存在任务，当 <code>run_slow_work_message</code> 得到被处理机会时，处理慢任务队列中的任务。</p>
<p>在 <code>uv_queue_work</code> 中的 <code>uv__work_submit</code> 调用时，传递的是 <code>UV__WORK_CPU</code> 表示 CPU 密集型任务。</p>
<p>任务可能在任意一个线程中提交，通常是在事件循环线程中提交，但是也有可能在work线程中提交，即，<code>w-&gt;work</code> 和 <code>w-&gt;done</code> 这两个函数中都有可能调用 <code>uv__work_submit</code>，这取决于实现。</p>
<p>将任务提交到工作队列中，这一阶段的工作就已经完成了，线程池中的线程可以开始工作了。</p>
<p>至此，整个线程池的工作原理已经分析完成，整个工作流程大致可分为三个阶段：</p>
<ol>
<li>提交任务；</li>
<li>work线程处理任务，完成后通知事件循环线程；</li>
<li>事件循环线程收到通知后完成收尾工作。</li>
</ol>
<p>在接口使用中，是不需要太关心以上流程和工作原理的，更应该关系 <code>work_cb</code> 和 <code>after_work_cb</code> 以及其他逻辑的实现。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>线程池在 libuv 内部用于完成所有文件系统操作（<code>requests</code>），也用于实现 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 等 DNS 相关的操作（<code>requests</code>）。搜索 <code>uv_queue_work</code> 可找到相关使用位置。可以这些内部实现作为使用示例，在内部，并不通过 <code>uv_queue_work</code> 提交任务，而是直接调用 <code>uv__work_submit</code>，因为它们都有各自不同的 <code>uv__x_work</code> 和 <code>uv__x_done</code> 实现。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a target="_blank" rel="noopener" href="http://docs.libuv.org/en/v1.x/threadpool.html">http://docs.libuv.org/en/v1.x/threadpool.html</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.libuv.org/en/v1.x/dns.html">http://docs.libuv.org/en/v1.x/dns.html</a></li>
<li></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/node.js/libuv/8-libuv-threadpool.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/node.js/libuv/8-libuv-threadpool.md">编辑源文件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/node.js/libuv/7-libuv-async/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/node.js/libuv/7-libuv-async/" class="post-title-link" itemprop="url">libuv源码分析（七）异步唤醒（Async）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-23 15:00:07" itemprop="dateCreated datePublished" datetime="2019-04-23T15:00:07+08:00">2019-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-07-24 15:24:34" itemprop="dateModified" datetime="2019-07-24T15:24:34+08:00">2019-07-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/node.js/libuv/7-libuv-async/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/node.js/libuv/7-libuv-async/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Async 允许用户在其他线程中唤醒主事件循环线程并触发回调函数调用。</p>
<p>事件循环线程在运行到 Pool 阶段会因为 <code>epoll_pwait</code> 调用阻塞一定的时间，libuv 会根据事件循环信息预估阻塞多长时间合适，也就是 <code>timeout</code>。但是在某些情境下，libuv 是无法准确预估的，例如线程池支持的异步文件操作，这些其他线程中的任务是无法有效判断多久能够运行完成的，在 libuv 中，其他线程工作完成之后，执行结果需要交给主事件循环线程，而事件循环线程可能恰好阻塞在 <code>epoll_pwait</code> 上，这时为了能够让其他线程的执行结果能够快速得到处理，需要唤醒主事件循环线程，也就是 <code>epoll_pwait</code>，而 Async 正式用来至此唤醒主事件循环的机制，简单的调用 <code>uv_async_send</code> 即可。线程池中的线程也正是利用这个机制和主事件循环线程通讯。</p>
<p>通过前文中对IO观察者的分析，我们知道，让 <code>epoll_pwait</code> 返回的方式，就是让 <code>epoll_pwait</code> 轮询的文件描述符中有I/O事件发生，Async 就是这么做的，通过 <code>uv_async_send</code> 向某个固定的文件描述符发送数据，使 <code>epoll_pwait</code> 返回。</p>
<p>Async 的入口函数共用两个：</p>
<ul>
<li>uv_async_init 初始化 Async Handle</li>
<li>uv_async_send 发送消息唤醒事件循环线程并触发回调函数调用</li>
</ul>
<p>首先，看一下 Async Handle 结构 <code>uv_async_s</code> 的定义：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/v1.28.0/include/uv.h#L789">https://github.com/libuv/libuv/blob/v1.28.0/include/uv.h#L789</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> &#123;</span></span><br><span class="line">  UV_HANDLE_FIELDS</span><br><span class="line">  UV_ASYNC_PRIVATE_FIELDS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_ASYNC_PRIVATE_FIELDS                                               \</span></span><br><span class="line"><span class="meta">  uv_async_cb async_cb;                                                       \</span></span><br><span class="line"><span class="meta">  void* queue[2];                                                             \</span></span><br><span class="line"><span class="meta">  int pending;                                                                \</span></span><br></pre></td></tr></table></figure>

<p>结构比较简单，<code>async_cb</code> 保存回调函数指针，<code>queue</code> 作为队列节点接入 <code>loop-&gt;async_handles</code>，<code>pending</code> 字段表示已发送了唤醒信号，初始化为 <code>0</code>, 在调用唤醒函数之后会被设置为 <code>1</code>。</p>
<p>继续看 <code>uv_async_init</code>：</p>
<p>注意：该初始化函数不同于其他初始化函数，该函数会立即启动 <code>Handle</code>，所以没有 <code>Start</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/async.c#L40">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/async.c#L40</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_async_t</span>* handle, uv_async_cb async_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv__async_start(loop);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_ASYNC);</span><br><span class="line">  handle-&gt;async_cb = async_cb;</span><br><span class="line">  handle-&gt;pending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__async_start</code> 初始化并启动了 <code>loop-&gt;async_io_watcher</code>，使事件循环能够通过 <code>loop-&gt;async_io_watcher</code> 接收到其他线程发送的唤醒消息。</p>
<p>在进行简单的初始化后，直接启动了 <code>handle</code>，并不需要像其他 <code>handle</code> 一样提供 <code>uv_async_start</code> 这样的方法。</p>
<p>我们继续看一下 <code>uv__async_start</code> 如何工作：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/v1.28.0/src/unix/async.c#L156">https://github.com/libuv/libuv/blob/v1.28.0/src/unix/async.c#L156</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__async_start</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;async_io_watcher.fd != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err = uv__async_eventfd();</span><br><span class="line">  <span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    pipefd[<span class="number">0</span>] = err;</span><br><span class="line">    pipefd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (err == UV_ENOSYS) &#123;</span><br><span class="line">    err = uv__make_pipe(pipefd, UV__F_NONBLOCK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="comment">/* Save a file descriptor by opening one of the pipe descriptors as</span></span><br><span class="line"><span class="comment">     * read/write through the procfs.  That file descriptor can then</span></span><br><span class="line"><span class="comment">     * function as both ends of the pipe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;/proc/self/fd/%d&quot;</span>, pipefd[<span class="number">0</span>]);</span><br><span class="line">      fd = uv__open_cloexec(buf, O_RDWR);</span><br><span class="line">      <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        uv__close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        uv__close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        pipefd[<span class="number">0</span>] = fd;</span><br><span class="line">        pipefd[<span class="number">1</span>] = fd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[<span class="number">0</span>]);</span><br><span class="line">  uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN);</span><br><span class="line">  loop-&gt;async_wfd = pipefd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数中，初始化并启动了 <code>loop-&gt;async_io_watcher</code>，该函数中创建了管道，其本质是一个内核缓冲区（4k），有两个文件描述符引用，用于有血缘关系的进程和线程间进行数据传递（通信），<code>pipefd</code> 保存了管道的两端的文件描述符，<code>pipefd[0]</code> 用于读数据，<code>pipefd[1]</code> 用于写数据，<code>pipefd[1]</code> 被保存到了 <code>loop-&gt;async_wfd</code>，通过I/O观察者监听 <code>pipefd[0]</code> 即可接收消息，通过向 <code>loop-&gt;async_wfd</code> 写数据，即可发送消息。<code>uv__async_start</code> 在已经初始化 <code>loop-&gt;async_io_watcher</code> 的情况下，无需再次初始化。</p>
<p>需要注意的是，<code>uv_async_init</code> 可能调用多次用于初始化多个不同的 Async Handle，但是 <code>loop-&gt;async_io_watcher</code> 只有一个，也就是这些 Async Handle 共享了 <code>loop-&gt;async_io_watcher</code>，那么在 <code>loop-&gt;async_io_watcher</code> 上有I/O事件时，并不知道是哪个Async Handle发送的。</p>
<p><code>loop-&gt;async_io_watcher</code> 上的I/O事件，由 <code>uv__async_io</code> 处理，它的实现如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/async.c#L76">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/async.c#L76</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__async_io</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv__io_t</span>* w, <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">ssize_t</span> r;</span><br><span class="line">  QUEUE <span class="built_in">queue</span>;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">uv_async_t</span>* h;</span><br><span class="line"></span><br><span class="line">  assert(w == &amp;loop-&gt;async_io_watcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    r = read(w-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">sizeof</span>(buf))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;async_handles, &amp;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    h = QUEUE_DATA(q, <span class="keyword">uv_async_t</span>, <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmpxchgi(&amp;h-&gt;pending, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;async_cb == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    h-&gt;async_cb(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<ol>
<li>不断的读取 <code>w-&gt;fd</code> 上的数据到 <code>buf</code> 中直到为空，<code>buf</code> 中的数据无实际用途；</li>
<li>遍历 <code>loop-&gt;async_handles</code> 队列，调用所有 <code>h-&gt;pending</code> 值为 <code>1</code> 的 <code>handle</code> 的 <code>async_cb</code> 函数如果存在的话。</li>
</ol>
<p><code>h-&gt;pending</code> 是在 <code>uv_async_send</code> 中被设置为 <code>1</code>。因为 <code>h-&gt;pending</code> 会在多线程中被访问到，所以存在资源争抢的临界状态，<code>cmpxchgi</code> 是原子操作，在这段代码中，如果 <code>h-&gt;pending == 1</code> 会被原子的 修改成 <code>0</code>，其他线程中对 <code>h-&gt;pending</code> 的读写也通过 <code>cmpxchgi</code> 进行原子操作，防止同时读写程序异常。</p>
<p>如上文所述，<code>uv__async_io</code> 并不知道是哪个 Async Handle 上调用的，<code>uv__async_io</code> 实际上调用了所有的 <code>h-&gt;pending</code> 值为 <code>1</code> 也就是发送过唤醒信号的 <code>handle</code>。实际上，Async 的设计的目的是能够唤醒主事件循环线程，所以 libuv 并需要关心是哪个 Async Handle 发送的信号，有可能同时发送。</p>
<p>接下来 我们了解一下 如何唤醒事件循环，简单的调用 <code>uv_async_send</code> 即可：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/v1.28.0/src/unix/async.c#L58">https://github.com/libuv/libuv/blob/v1.28.0/src/unix/async.c#L58</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_send</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Do a cheap read first. */</span></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="keyword">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__async_send</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* buf;</span><br><span class="line">  <span class="keyword">ssize_t</span> len;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">  buf = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  len = <span class="number">1</span>;</span><br><span class="line">  fd = loop-&gt;async_wfd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> val = <span class="number">1</span>;</span><br><span class="line">    buf = &amp;val;</span><br><span class="line">    len = <span class="keyword">sizeof</span>(val);</span><br><span class="line">    fd = loop-&gt;async_io_watcher.fd;  <span class="comment">/* eventfd */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    r = write(fd, buf, len);</span><br><span class="line">  <span class="keyword">while</span> (r == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r == len)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv_async_send</code> 可能在多个线程中同时调用，而且有可能在同一个 Async Handle 上调用，所以要求对 <code>handle-&gt;pending</code> 进行原子性读写。</p>
<p><code>uv__async_send</code> 为实际进行写操作，因为管道中存在缓存区，所以需要不断的向 <code>loop-&gt;async_wfd</code> 写入数据，直到阻塞为止。</p>
<p>以上，就是 Async 唤醒事件循环线程的实现方式，很简单，核心在于竞态问题的解决。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/node.js/libuv/7-libuv-async.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/node.js/libuv/7-libuv-async.md">编辑源文件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.butonly.com/posts/node.js/libuv/6-libuv-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="liuyanjie">
      <meta itemprop="description" content="KISS DRY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuyanjie's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/node.js/libuv/6-libuv-stream/" class="post-title-link" itemprop="url">libuv源码分析（六）流（Stream）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-23 15:00:06" itemprop="dateCreated datePublished" datetime="2019-04-23T15:00:06+08:00">2019-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-07-24 15:24:34" itemprop="dateModified" datetime="2019-07-24T15:24:34+08:00">2019-07-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/node.js/libuv/6-libuv-stream/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/node.js/libuv/6-libuv-stream/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Stream 提供一个全双工的通信信道的抽象，<code>uv_stream_t</code> 是一个抽象数据类型，libuv 提供了 <code>uv_tcp_t</code>、<code>uv_pipe_t</code>、<code>uv_tty_t</code> <code>3</code> 个 <code>Stream</code> 实现。</p>
<h2 id="uv-stream-t"><a href="#uv-stream-t" class="headerlink" title="uv_stream_t"></a>uv_stream_t</h2><p><code>uv_stream_t</code> 并未直接提供初始化函数，如同 <code>uv_handle_t</code> 一样，<code>uv_stream_t</code> 是在派生类型初始化的时候间接初始化的。派生类型的初始化函数中都调用了 <code>uv__stream_init</code> 函数对 <code>uv_stream_t</code> 进行初始化。</p>
<p>先介绍一下 <code>uv_stream_t</code> 的各个字段的含义</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv.h#L470">https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv.h#L470</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * uv_stream_t is a subclass of uv_handle_t.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * uv_stream is an abstract class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> &#123;</span></span><br><span class="line">  UV_HANDLE_FIELDS</span><br><span class="line">  UV_STREAM_FIELDS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv.h#L462">https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv.h#L462</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_STREAM_FIELDS                        \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* number of bytes queued for writing */</span>      \ 共有字段：</span></span><br><span class="line">  <span class="keyword">size_t</span> write_queue_size;                      \   等待写的字节数</span><br><span class="line">  uv_alloc_cb alloc_cb;                         \   用于分配空间的函数指针</span><br><span class="line">  uv_read_cb read_cb;                           \   读取数据完成之后的回调函数</span><br><span class="line">  <span class="comment">/* private */</span>                                 \</span><br><span class="line">  UV_STREAM_PRIVATE_FIELDS</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv/unix.h#L283">https://github.com/libuv/libuv/blob/view-v1.28.0/include/uv/unix.h#L283</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_STREAM_PRIVATE_FIELDS                 \ 私有字段：</span></span><br><span class="line">  <span class="keyword">uv_connect_t</span> *connect_req;                     \   连接请求</span><br><span class="line">  <span class="keyword">uv_shutdown_t</span> *shutdown_req;                   \   关闭请求</span><br><span class="line">  <span class="keyword">uv__io_t</span> io_watcher;                           \   I/O观察者（has-a）</span><br><span class="line">  <span class="keyword">void</span>* write_queue[<span class="number">2</span>];                          \   写数据队列</span><br><span class="line">  <span class="keyword">void</span>* write_completed_queue[<span class="number">2</span>];                \   完成的写数据队列</span><br><span class="line">  uv_connection_cb connection_cb;                \   有新连接时的回调函数</span><br><span class="line">  <span class="keyword">int</span> delayed_error;                             \   延迟的错误</span><br><span class="line">  <span class="keyword">int</span> accepted_fd;                               \   对端的fd</span><br><span class="line">  <span class="keyword">void</span>* queued_fds;                              \   排队的文件描述符列表</span><br><span class="line">  UV_STREAM_PRIVATE_PLATFORM_FIELDS              \</span><br></pre></td></tr></table></figure>

<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/v1.x/src/unix/stream.c#L84">https://github.com/libuv/libuv/blob/v1.x/src/unix/stream.c#L84</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__stream_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                     uv_handle_type type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)stream, type);</span><br><span class="line">  stream-&gt;read_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;alloc_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;close_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connection_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connect_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;accepted_fd = <span class="number">-1</span>;</span><br><span class="line">  stream-&gt;queued_fds = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;delayed_error = <span class="number">0</span>;</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_queue);</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_completed_queue);</span><br><span class="line">  stream-&gt;write_queue_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;emfile_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    err = uv__open_cloexec(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* In the rare case that &quot;/dev/null&quot; isn&#x27;t mounted open &quot;/&quot;</span></span><br><span class="line"><span class="comment">         * instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        err = uv__open_cloexec(<span class="string">&quot;/&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">      loop-&gt;emfile_fd = err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  stream-&gt;select = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__APPLE_) */</span></span></span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;stream-&gt;io_watcher, uv__stream_io, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uv__stream_init</code> 的整体工作逻辑如下：</p>
<ol>
<li>首先调用基类（<code>uv_handle_t</code>）初始化函数 <code>uv__handle_init</code> 对基类进行初始化；</li>
<li>对 <code>stream</code> 结构进行初始化；<ol>
<li>初始化相关字段；</li>
<li>初始化 <code>stream-&gt;write_queue</code> 写队列；</li>
<li>初始化 <code>stream-&gt;write_completed_queue</code> 写完成队列；为什么有两个写相关的队列？写操作为了实现异步非阻塞，上层的写操作并不能直接写，而是丢到队列中，当下层I/O观察者触发可写事件时，在进行写入操作。</li>
</ol>
</li>
<li>最后调用I/O观察者初始化函数 <code>uv__io_init</code> 对 <code>stream-&gt;io_watcher</code> 进行初始化，初始化传递了异步回调函数 <code>uv__stream_io</code>。</li>
</ol>
<p><code>uv__stream_init</code> 在 <code>uv_stream_t</code> 的派生类型的初始化函数 <code>uv_tcp_init</code>、<code>uv_pipe_init</code>、<code>uv_tty_init</code> 中被调用。</p>
<p>接下来看看 <code>uv__stream_io</code> 都做了什么</p>
<h4 id="uv-stream-io"><a href="#uv-stream-io" class="headerlink" title="uv__stream_io"></a>uv__stream_io</h4><p><code>uv__stream_io</code> 是 <code>uv_stream_t</code> I/O事件的处理函数，实现如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/v1.28.0/src/unix/stream.c#L1281">https://github.com/libuv/libuv/blob/v1.28.0/src/unix/stream.c#L1281</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__stream_io</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv__io_t</span>* w, <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_stream_t</span>* stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得原 stream 实例</span></span><br><span class="line">  stream = container_of(w, <span class="keyword">uv_stream_t</span>, io_watcher);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言</span></span><br><span class="line">  assert(stream-&gt;type == UV_TCP ||</span><br><span class="line">         stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">         stream-&gt;type == UV_TTY);</span><br><span class="line">  assert(!(stream-&gt;flags &amp; UV_HANDLE_CLOSING));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 stream 上存在 连接请求，则首选需要建立连接</span></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;connect_req) &#123;</span><br><span class="line">    uv__stream_connect(stream);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断言存在文件描述符</span></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足读数据条件，进行数据读取，读取成功后继续向下执行，读取需要多久？</span></span><br><span class="line">  <span class="comment">/* Ignore POLLHUP here. Even if it&#x27;s set, there may still be data to read. */</span></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLIN | POLLERR | POLLHUP))</span><br><span class="line">    uv__read(stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read_cb 可能会关闭 stream</span></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit iff POLLHUP is set, the user is still interested in read</span></span><br><span class="line"><span class="comment">   * events and uv__read() reported a partial read but not EOF. If the EOF</span></span><br><span class="line"><span class="comment">   * flag is set, uv__read() called read_cb with err=UV_EOF and we don&#x27;t</span></span><br><span class="line"><span class="comment">   * have to do anything. If the partial read flag is not set, we can&#x27;t</span></span><br><span class="line"><span class="comment">   * report the EOF yet because there is still data to read.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((events &amp; POLLHUP) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_HANDLE_READING) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_HANDLE_READ_PARTIAL) &amp;&amp;</span><br><span class="line">      !(stream-&gt;flags &amp; UV_HANDLE_READ_EOF)) &#123;</span><br><span class="line">    <span class="keyword">uv_buf_t</span> buf = &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    uv__stream_eof(stream, &amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read_cb 可能会关闭 stream</span></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足写数据条件，进行数据写入，写入成功后继续向下执行，读取需要多久？</span></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLOUT | POLLERR | POLLHUP)) &#123;</span><br><span class="line">    uv__write(stream);</span><br><span class="line">    uv__write_callbacks(stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write queue drained. */</span></span><br><span class="line">    <span class="keyword">if</span> (QUEUE_EMPTY(&amp;stream-&gt;write_queue))</span><br><span class="line">      uv__drain(stream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>uv__stream_io</code> 时，传递了事件循环对象、I/O观察者对象、事件类型等信息。</p>
<p>执行逻辑如下：</p>
<ol>
<li>首先，通过 <code>container_of</code> 将I/O观察者对象地址换算成 <code>stream</code> 对象地址，再进行强制类型转换，进而还原出 <code>stream</code> 类型；</li>
<li>验证 <code>stream</code> 类型已经状态是否正常；</li>
<li>如果 <code>stream-&gt;connect_req</code> 存在，说明 该 <code>stream</code> 需要 进行 <code>connect</code>，于是调用 <code>uv__stream_connect</code>；</li>
<li>如果 满足 可读条件 调用 <code>uv__read</code> 进行数据读操作，读的数据来源于对应的文件描述符，内部调用 <code>stream-&gt;alloc_cb</code> 分配 <code>uv_buf_t</code> 进行数据存储空间分配，然后进行数据读取，读取完成后调用读完成回调 <code>stream-&gt;read_cb</code>；</li>
<li>如果 满足 流结束条件 调用 <code>uv__stream_eof</code> 进行相关处理；</li>
<li>如果 满足 可写条件 调用 <code>uv__write</code> 进行数据写操作，写数据需要事先准备好，这些数据被放到了 <code>stream-&gt;write_queue</code> 写队列上，当底层描述符可写时，将队列上的数据写入。</li>
</ol>
<p>后续，继续分析 <code>uv__read</code> <code>uv__write</code> <code>uv__stream_eof</code> 的相关实现逻辑，因为不影响大的逻辑，所以暂时可以先留空。</p>
<h4 id="uv-read"><a href="#uv-read" class="headerlink" title="uv__read"></a>uv__read</h4><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1110">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1110</a></p>
<p>当I/O观察者存在可读事件时，函数 <code>uv__read</code> 会被调用，当 <code>uv__read</code> 调用时，会通过 <code>read</code> 从底层文件描述符读取数据，读取的数据写到由 <code>stream-&gt;alloc_cb</code> 分配到内存中，并在完成读取后由 <code>stream-&gt;read_cb</code> 回调给用户层代码。因为可读数据已经由底层准备好，所以读取速度是非常快的，不需要等待。</p>
<p>默认情况下，当底层没有数据的情况时，<code>read</code> 系统调用会阻塞，但是此处因为文件描述符工作在非阻塞模式下，所有即使没有数据，<code>read</code> 也会立即返回。所以事件循环不好因为 <code>uv__read</code> 调用而耗时过长。</p>
<h4 id="uv-write"><a href="#uv-write" class="headerlink" title="uv__write"></a>uv__write</h4><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L801">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L801</a></p>
<p>当I/O观察者存在可写事件时，函数 <code>uv__write</code> 会被调用，当 <code>uv__write</code> 调用时，数据已经在 <code>stream-&gt;write_queue</code> 队列上排好了，这个队列是 <code>uv_write_t</code> 类型的数据，如果队列为空没有数据可以写。用户在进行 <code>uv_write()</code> API 调用时，因为是异步操作，所以数据并不会直接执行真正的写操作，而是丢到写请求队列中后直接返回了，待到 <code>stream</code> 处于可写状态，事件处理含数 <code>uv__stream_io</code> 被调用，开始调用系统API进行真正的数据写入。</p>
<p>默认情况下，当底层没有更多内存缓冲区可用时，<code>write</code> 系统调用会阻塞，但是此处因为文件描述符工作在非阻塞模式下，所有即使缓冲区用完，<code>write</code> 也会立即返回。所以事件循环不好因为 <code>uv__write</code> 调用而耗时过长。</p>
<h4 id="uv-write-callbacks"><a href="#uv-write-callbacks" class="headerlink" title="uv__write_callbacks"></a>uv__write_callbacks</h4><p>清理 <code>stream-&gt;write_completed_queue</code> 已完成写请求的队列，清理空间，并调用回调函数。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L926">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L926</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__write_callbacks</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_write_t</span>* req;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;stream-&gt;write_completed_queue))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;stream-&gt;write_completed_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    <span class="comment">/* Pop a req off write_completed_queue. */</span></span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    req = QUEUE_DATA(q, <span class="keyword">uv_write_t</span>, <span class="built_in">queue</span>);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    uv__req_unregister(stream-&gt;loop, req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;bufs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      stream-&gt;write_queue_size -= uv__write_req_size(req);</span><br><span class="line">      <span class="keyword">if</span> (req-&gt;bufs != req-&gt;bufsml)</span><br><span class="line">        uv__free(req-&gt;bufs);</span><br><span class="line">      req-&gt;bufs = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> call callback AFTER freeing the request data. */</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;cb)</span><br><span class="line">      req-&gt;cb(req, req-&gt;error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uv-drain"><a href="#uv-drain" class="headerlink" title="uv__drain"></a>uv__drain</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__drain</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_shutdown_t</span>* req;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  assert(QUEUE_EMPTY(&amp;stream-&gt;write_queue));</span><br><span class="line">  uv__io_stop(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLOUT);</span><br><span class="line">  uv__stream_osx_interrupt_select(stream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Shutdown? */</span></span><br><span class="line">  <span class="keyword">if</span> ((stream-&gt;flags &amp; UV_HANDLE_SHUTTING) &amp;&amp;</span><br><span class="line">      !(stream-&gt;flags &amp; UV_HANDLE_CLOSING) &amp;&amp;</span><br><span class="line">      !(stream-&gt;flags &amp; UV_HANDLE_SHUT)) &#123;</span><br><span class="line">    assert(stream-&gt;shutdown_req);</span><br><span class="line"></span><br><span class="line">    req = stream-&gt;shutdown_req;</span><br><span class="line">    stream-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">    stream-&gt;flags &amp;= ~UV_HANDLE_SHUTTING;</span><br><span class="line">    uv__req_unregister(stream-&gt;loop, req);</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (shutdown(uv__stream_fd(stream), SHUT_WR))</span><br><span class="line">      err = UV__ERR(errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">      stream-&gt;flags |= UV_HANDLE_SHUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;cb != <span class="literal">NULL</span>)</span><br><span class="line">      req-&gt;cb(req, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>不同于其他类型的 <code>handle</code>，提供了 <code>uv_timer_start</code> 等方法，Stream 的 Start 在命名上略有不同，对 Stream 来说，有 uv_read_start 和 uv_write 以及其他的 Start 方式。</p>
<h4 id="Start：uv-read-start"><a href="#Start：uv-read-start" class="headerlink" title="Start：uv_read_start"></a>Start：<code>uv_read_start</code></h4><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/win/stream.c#L67">https://github.com/libuv/libuv/blob/view-v1.28.0/src/win/stream.c#L67</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_start</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                  uv_alloc_cb alloc_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  uv_read_cb read_cb)</span> </span>&#123;</span><br><span class="line">  assert(stream-&gt;type == UV_TCP || stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">      stream-&gt;type == UV_TTY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;flags &amp; UV_HANDLE_CLOSING)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stream-&gt;flags &amp; UV_HANDLE_READABLE))</span><br><span class="line">    <span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The UV_HANDLE_READING flag is irrelevant of the state of the tcp - it just</span></span><br><span class="line"><span class="comment">   * expresses the desired state of the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  stream-&gt;flags |= UV_HANDLE_READING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> try to do the read inline? */</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> keep track of tcp state. If we&#x27;ve gotten a EOF then we should</span></span><br><span class="line"><span class="comment">   * not start the IO watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(alloc_cb);</span><br><span class="line"></span><br><span class="line">  stream-&gt;read_cb = read_cb;</span><br><span class="line">  stream-&gt;alloc_cb = alloc_cb;</span><br><span class="line"></span><br><span class="line">  uv__io_start(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLIN);</span><br><span class="line">  uv__handle_start(stream);</span><br><span class="line">  uv__stream_osx_interrupt_select(stream);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uv_read_start 有三个参数：</p>
<ol>
<li>stream，数据源；</li>
<li>alloc_cb，读取数据时调用该函数分配内存空间；</li>
<li>read_cb，读取成功后触发异步回调。</li>
</ol>
<p>可以看到，启动过程同样没做什么特别的事情，将I/O观察者加入到队列中后，以便在事件循环的特定阶段进行处理。</p>
<h4 id="Stop：uv-read-stop"><a href="#Stop：uv-read-stop" class="headerlink" title="Stop：uv_read_stop"></a>Stop：<code>uv_read_stop</code></h4><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1584">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1584</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_stop</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(stream-&gt;flags &amp; UV_HANDLE_READING))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stream-&gt;flags &amp;= ~UV_HANDLE_READING;</span><br><span class="line">  uv__io_stop(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLIN);</span><br><span class="line">  <span class="keyword">if</span> (!uv__io_active(&amp;stream-&gt;io_watcher, POLLOUT))</span><br><span class="line">    uv__handle_stop(stream);</span><br><span class="line">  uv__stream_osx_interrupt_select(stream);</span><br><span class="line"></span><br><span class="line">  stream-&gt;read_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;alloc_cb = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1483">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1483</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The buffers to be written must remain valid until the callback is called.</span></span><br><span class="line"><span class="comment"> * This is not required for the uv_buf_t array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_write</span><span class="params">(<span class="keyword">uv_write_t</span>* req,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uv_stream_t</span>* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[],</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs,</span></span></span><br><span class="line"><span class="params"><span class="function">             uv_write_cb cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv_write2(req, handle, bufs, nbufs, <span class="literal">NULL</span>, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1387">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1387</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_write2</span><span class="params">(<span class="keyword">uv_write_t</span>* req,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[],</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">uv_stream_t</span>* send_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">              uv_write_cb cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> empty_queue;</span><br><span class="line"></span><br><span class="line">  assert(nbufs &gt; <span class="number">0</span>);</span><br><span class="line">  assert((stream-&gt;type == UV_TCP ||</span><br><span class="line">          stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">          stream-&gt;type == UV_TTY) &amp;&amp;</span><br><span class="line">         <span class="string">&quot;uv_write (unix) does not yet support other types of streams&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EBADF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stream-&gt;flags &amp; UV_HANDLE_WRITABLE))</span><br><span class="line">    <span class="keyword">return</span> -EPIPE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (send_handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stream-&gt;type != UV_NAMED_PIPE || !((<span class="keyword">uv_pipe_t</span>*)stream)-&gt;ipc)</span><br><span class="line">      <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX We abuse uv_write2() to send over UDP handles to child processes.</span></span><br><span class="line"><span class="comment">     * Don&#x27;t call uv__stream_fd() on those handles, it&#x27;s a macro that on OS X</span></span><br><span class="line"><span class="comment">     * evaluates to a function that operates on a uv_stream_t with a couple of</span></span><br><span class="line"><span class="comment">     * OS X specific fields. On other Unices it does (handle)-&gt;io_watcher.fd,</span></span><br><span class="line"><span class="comment">     * which works but only by accident.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (uv__handle_fd((<span class="keyword">uv_handle_t</span>*) send_handle) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> UV_EBADF;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__CYGWIN__) || defined(__MSYS__)</span></span><br><span class="line">    <span class="comment">/* Cygwin recvmsg always sets msg_controllen to zero, so we cannot send it.</span></span><br><span class="line"><span class="comment">       See https://github.com/mirror/newlib-cygwin/blob/86fc4bf0/winsup/cygwin/fhandler_socket.cc#L1736-L1743 */</span></span><br><span class="line">    <span class="keyword">return</span> UV_ENOSYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* It&#x27;s legal for write_queue_size &gt; 0 even when the write_queue is empty;</span></span><br><span class="line"><span class="comment">   * it means there are error-state requests in the write_completed_queue that</span></span><br><span class="line"><span class="comment">   * will touch up write_queue_size later, see also uv__write_req_finish().</span></span><br><span class="line"><span class="comment">   * We could check that write_queue is empty instead but that implies making</span></span><br><span class="line"><span class="comment">   * a write() syscall when we know that the handle is in error mode.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  empty_queue = (stream-&gt;write_queue_size == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the req */</span></span><br><span class="line">  uv__req_init(stream-&gt;loop, req, UV_WRITE);</span><br><span class="line">  req-&gt;cb = cb;</span><br><span class="line">  req-&gt;handle = stream;</span><br><span class="line">  req-&gt;error = <span class="number">0</span>;</span><br><span class="line">  req-&gt;send_handle = send_handle;</span><br><span class="line">  QUEUE_INIT(&amp;req-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">  req-&gt;bufs = req-&gt;bufsml;</span><br><span class="line">  <span class="keyword">if</span> (nbufs &gt; ARRAY_SIZE(req-&gt;bufsml))</span><br><span class="line">    req-&gt;bufs = uv__malloc(nbufs * <span class="keyword">sizeof</span>(bufs[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;bufs == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_ENOMEM;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(req-&gt;bufs, bufs, nbufs * <span class="keyword">sizeof</span>(bufs[<span class="number">0</span>]));</span><br><span class="line">  req-&gt;nbufs = nbufs;</span><br><span class="line">  req-&gt;write_index = <span class="number">0</span>;</span><br><span class="line">  stream-&gt;write_queue_size += uv__count_bufs(bufs, nbufs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Append the request to write_queue. */</span></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;stream-&gt;write_queue, &amp;req-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the queue was empty when this function began, we should attempt to</span></span><br><span class="line"><span class="comment">   * do the write immediately. Otherwise start the write_watcher and wait</span></span><br><span class="line"><span class="comment">   * for the fd to become writable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;connect_req) &#123;</span><br><span class="line">    <span class="comment">/* Still connecting, do nothing. */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (empty_queue) &#123;</span><br><span class="line">    uv__write(stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * blocking streams should never have anything in the queue.</span></span><br><span class="line"><span class="comment">     * if this assert fires then somehow the blocking stream isn&#x27;t being</span></span><br><span class="line"><span class="comment">     * sufficiently flushed in uv__write.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(!(stream-&gt;flags &amp; UV_HANDLE_BLOCKING_WRITES));</span><br><span class="line">    uv__io_start(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLOUT);</span><br><span class="line">    uv__stream_osx_interrupt_select(stream);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1501">https://github.com/libuv/libuv/blob/view-v1.28.0/src/unix/stream.c#L1501</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_try_write</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[],</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> has_pollout;</span><br><span class="line">  <span class="keyword">size_t</span> written;</span><br><span class="line">  <span class="keyword">size_t</span> req_size;</span><br><span class="line">  <span class="keyword">uv_write_t</span> req;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Connecting or already writing some data */</span></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;connect_req != <span class="literal">NULL</span> || stream-&gt;write_queue_size != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EAGAIN;</span><br><span class="line"></span><br><span class="line">  has_pollout = uv__io_active(&amp;stream-&gt;io_watcher, POLLOUT);</span><br><span class="line"></span><br><span class="line">  r = uv_write(&amp;req, stream, bufs, nbufs, uv_try_write_cb);</span><br><span class="line">  <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remove not written bytes from write queue size */</span></span><br><span class="line">  written = uv__count_bufs(bufs, nbufs);</span><br><span class="line">  <span class="keyword">if</span> (req.bufs != <span class="literal">NULL</span>)</span><br><span class="line">    req_size = uv__write_req_size(&amp;req);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    req_size = <span class="number">0</span>;</span><br><span class="line">  written -= req_size;</span><br><span class="line">  stream-&gt;write_queue_size -= req_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unqueue request, regardless of immediateness */</span></span><br><span class="line">  QUEUE_REMOVE(&amp;req.<span class="built_in">queue</span>);</span><br><span class="line">  uv__req_unregister(stream-&gt;loop, &amp;req);</span><br><span class="line">  <span class="keyword">if</span> (req.bufs != req.bufsml)</span><br><span class="line">    uv__free(req.bufs);</span><br><span class="line">  req.bufs = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do not poll for writable, if we wasn&#x27;t before calling this */</span></span><br><span class="line">  <span class="keyword">if</span> (!has_pollout) &#123;</span><br><span class="line">    uv__io_stop(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLOUT);</span><br><span class="line">    uv__stream_osx_interrupt_select(stream);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (written == <span class="number">0</span> &amp;&amp; req_size != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EAGAIN;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/tree/master/node.js/libuv/6-libuv-stream.md" >查看源文件</a>&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://github.com/liuyanjie/knowledge/edit/master/node.js/libuv/6-libuv-stream.md">编辑源文件</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuyanjie</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">146k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.9.1/dist/algoliasearch-lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.21.0/dist/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>



  <script class="next-config" data-name="pdf" type="application/json">{&quot;object_url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;pdfobject@2.2.5&#x2F;pdfobject.min.js&quot;,&quot;url&quot;:&quot;&#x2F;lib&#x2F;pdf&#x2F;web&#x2F;viewer.html&quot;}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{&quot;enable&quot;:true,&quot;theme&quot;:&quot;forest&quot;,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mermaid@8.9.3&#x2F;dist&#x2F;mermaid.min.js&quot;}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;liuyanjie&quot;,&quot;count&quot;:true,&quot;lazyload&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
