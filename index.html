<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Liuyanjie&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Liuyanjie&#39;s Blog">
<meta property="og:url" content="https://liuyanjie.github.io/index.html">
<meta property="og:site_name" content="Liuyanjie&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liuyanjie&#39;s Blog">
  
    <link rel="alternative" href="/atom.xml" title="Liuyanjie&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://avatars0.githubusercontent.com/u/5998826?&v=4">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="https://avatars0.githubusercontent.com/u/5998826?&amp;v=4" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Liu Yanjie</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/liuyanjie" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Liu Yanjie</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="https://avatars0.githubusercontent.com/u/5998826?&amp;v=4" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Liu Yanjie</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/liuyanjie" title="github">github</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-js" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/04/11/js/" class="article-date">
      <time datetime="2018-04-11T14:05:14.000Z" itemprop="datePublished">2018-04-11</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2018/04/11/js/">js</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h1><p>Focus on concepts，not syntax.</p>
<p>关注概念的理解，而不是语法。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型-Primitive"><a href="#基本类型-Primitive" class="headerlink" title="基本类型 Primitive"></a>基本类型 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener">Primitive</a></h3><p><code>Undefined、Null、Boolean、Number、String、Symbol(ES2015)</code></p>
<p>原始类型 和 原始值</p>
<p>基本类型的值 是不可变的，我们无法给它们添加属性。</p>
<p>基本类型的值 不是一个对象，也没有方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'~~~~~'</span>;</span><br><span class="line">str.prop = <span class="string">'!!!!!'</span>;</span><br><span class="line">str.prop; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.prop = <span class="number">11</span>;</span><br><span class="line">num.prop; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line">bool.prop = <span class="string">''</span>;</span><br><span class="line">bool.prop <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="string">'---'</span>.charAt === <span class="built_in">String</span>.prototype.charAt</span><br><span class="line">(<span class="number">12345</span>).toString(); <span class="comment">// 使用数字调用方法时需要用用括号括起来</span></span><br></pre></td></tr></table></figure>
<h4 id="Boolean、Number、String、Symbol"><a href="#Boolean、Number、String、Symbol" class="headerlink" title="Boolean、Number、String、Symbol"></a><code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code></h4><ul>
<li>这三种基本类型分别存在 <code>Boolean()</code>、<code>Number()</code>、<code>String()</code> 内建函数</li>
<li>平时使用的时候大都使用的是字面量形式，字面量并不是对象</li>
<li><p>当需要的时候，它们也会被转换成对象，也就是会被转换成 <strong>基本类型的包装类型</strong></p>
<p><code>valueOf()</code> 方法返回 原始值</p>
</li>
</ul>
<h4 id="Undefined、Null"><a href="#Undefined、Null" class="headerlink" title="Undefined、Null"></a><code>Undefined</code>、<code>Null</code></h4><ul>
<li>并不存在 <code>Undefined()</code> 和 <code>Null()</code> 内建函数，只存在 <code>Undefined</code> 和 <code>Null</code> 类型的内建对象 <code>undefined</code> 和 <code>null</code></li>
<li>ECMAScript 认为 <code>undefined</code> 是从 <code>null</code> 派生出来的，所以把它们定义为 <strong>值</strong> 相等的，但是类型不等，相同的地方是都可以视为布尔值的 <code>false</code></li>
<li>这两个类型无 <strong>包装类型</strong></li>
</ul>
<p><code>undefined</code> 与 <code>null</code> 的区别：</p>
<ol>
<li><p><code>null</code> 表示 <strong>没有对象</strong>，即该处不应该有值</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ul>
</li>
<li><p><code>undefined</code> 表示 <strong>缺少值</strong>，即应该有一个值但是 <strong>未定义/未赋值</strong></p>
<ul>
<li>变量被声明了，但没有赋值时，该变量 <code>undefined</code></li>
<li>调用函数时，参数没有提供，该参数 <code>undefined</code></li>
<li>对象没有赋值的属性，该属性 <code>undefined</code></li>
<li>函数没有返回值时，返回 <code>undefined</code></li>
</ul>
</li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><code>Object、Function、String、Number、Error、Regexp、Map、Set</code> …</p>
<p>JavaScript 中一切都可以被当做对象！但是只有引用类型才是真正的对象，基本类型除了 <code>null</code> 和 <code>undefined</code> 之外，都可以像对象一样使用，因为他们有包装类型。</p>
<h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object{} - 对象"></a>Object{} - 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> boolObj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === boolObj);               <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);                    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj);                <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h4 id="Function-函数对象"><a href="#Function-函数对象" class="headerlink" title="Function - 函数对象"></a>Function - 函数对象</h4><p>Function 是一个构造函数，用于创建一个函数对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1[, arg2[, ...argN]],] functionBody)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Function</span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>function 是一个关键字可以声明一个函数对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个函数对象都继承 Function 构造函数的原型对象。</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.foo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">bar.foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-复合类型-（引用，指针）"><a href="#Array-复合类型-（引用，指针）" class="headerlink" title="Array[] - 复合类型 （引用，指针）"></a>Array[] - 复合类型 （引用，指针）</h4><p>数组是对象，能够添加属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.i = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, i: 4]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, arr[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 3</span></span><br><span class="line"><span class="comment">// i 4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">foo.length = <span class="number">3</span>;</span><br><span class="line">foo; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">foo.length = <span class="number">6</span>;</span><br><span class="line">foo.push(<span class="number">4</span>);</span><br><span class="line">foo; <span class="comment">// [1, 2, 3, undefined, undefined, undefined, 4]</span></span><br></pre></td></tr></table></figure>
<h4 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h4><p>一个JS数组是特殊的, 因为：</p>
<ol>
<li>它的 <code>length</code> 属性有些特殊行为：<ol>
<li>当新的元素添加到列表中，其值自动更新；</li>
<li>设置这一属性可以扩展或截断数组。</li>
</ol>
</li>
<li>数组是 <code>Array</code> 的实例，可以调用不同的 <code>Array</code> 方法。</li>
</ol>
<p>以上都是JS数组的独特特性，但它们不是一个数组的最基本的特性。</p>
<p>把任何具有一个 <code>length属性</code> 及相应的 <code>非负整数属性</code> 的 <code>对象</code> 作为一种数组, 称之为 <code>&quot;类数组&quot;</code>。</p>
<p>这种 <code>类数组</code> 的对象出现频率不高，而且也不能在它们之上 调用数组方法 或者通过 <code>length</code> 属性期待特殊的行为1)2), 但仍然可以用遍历一个真正数组的代码来遍历它们。</p>
<p>事实上很多数组算法对于类似数组的对象和真正的数组对象都是适用的, 只要不尝试对数组添加元素或者改变 <code>length属性</code>, 就可以把类似数组的对象当作真正的数组来对待。</p>
<p>特别地，函数中的 <code>Arguments</code> 对象就是一个 <code>类数组</code> 的对象; 而 <code>getElementsByTagName()</code> 返回的DOM结点列表也是类似数组的对象。</p>
<p>如下创建一个类似数组，然后遍历该类似数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 不小心就引进了一个小bug</span></span><br><span class="line"><span class="keyword">while</span>(i++ &lt; 10) &#123; a[i] = i * i; &#125;</span><br><span class="line">while(i &lt; 10) &#123; a[i] = i * i; i++; &#125;</span><br><span class="line"></span><br><span class="line">a.length = i;</span><br><span class="line"></span><br><span class="line">var total = 0;</span><br><span class="line">for(var j = 0, len = a.length; j &lt; len; j++) &#123;</span><br><span class="line">  total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型识别"><a href="#类型识别" class="headerlink" title="类型识别"></a>类型识别</h3><h4 id="识别方法"><a href="#识别方法" class="headerlink" title="识别方法"></a>识别方法</h4><ul>
<li><p><code>typeof</code> (typeof x)</p>
<ul>
<li>返回值：首字母小写的字符串形式</li>
<li>可以识别 <code>基本类型</code>，<code>null</code> 除外</li>
<li>不能识别 <code>内置对象类型</code> (<code>Function</code> 除外)</li>
<li>不能识别 <code>自定义类型</code></li>
<li>可以识别 <code>undefined</code></li>
<li>不能识别 <code>null</code>，因为 <code>null</code> 被识别为 <code>object</code></li>
</ul>
</li>
</ul>
<ul>
<li><p><code>instanceof</code> (x instanceof X)</p>
<ul>
<li>返回值：<code>true</code> 或 <code>false</code></li>
<li>不能识别 <code>基本类型</code>，会返回 <code>false</code>。 <code>(true instanceof Boolean) -&gt; false</code></li>
<li>可以识别 <code>内置对象类型</code></li>
<li>可以识别 <code>自定义类型</code> 及其 <code>父类型</code></li>
<li>不能识别 <code>undefined</code>、<code>null</code>，因为无 <code>Undefined</code>、<code>Null</code> 包装类型</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Object.prototype.toString</code></p>
<p>eq.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：<code>[object TypeX]</code> 的字符串形式</li>
<li>可以识别 <code>基本类型</code></li>
<li>可以识别 <code>内置对象类型</code></li>
<li>可以识别 <code>自定义类型</code>，但是需要重载 <code>toString</code> 方法</li>
<li>可以识别 <code>undefined</code>、<code>null</code></li>
</ul>
</li>
</ul>
<ul>
<li><p><code>.prototype.constructor</code></p>
<p>eq.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.constructor.name</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.constructor.toString().replace(<span class="regexp">/^function (\w+)\(\).+$/</span>, <span class="string">'$1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：<code>function TypeX(){[native code]}</code> 或者 <code>function TypeX(){}</code></li>
<li>可以识别 <code>基本类型</code></li>
<li>可以识别 <code>内置对象类型</code></li>
<li>可以识别 <code>自定义类型</code></li>
<li>不能识别 <code>undefined</code>、<code>null</code>，会报错，因为 不存在方法</li>
</ul>
</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><ul>
<li>Number</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);                    <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj);                 <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Object</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Number</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj <span class="keyword">instanceof</span> <span class="built_in">Number</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num === numObj);                <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>String</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);                    <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj);                 <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">Object</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj <span class="keyword">instanceof</span> <span class="built_in">String</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str === strObj);                <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Boolean</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> boolObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool);                   <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj);                <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(bool <span class="keyword">instanceof</span> <span class="built_in">Object</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bool === boolObj);              <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Undefined Null</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);              <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);                   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>);             <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'foo'</span>;                      <span class="comment">// 可以重新赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>, <span class="keyword">typeof</span> <span class="literal">undefined</span>);   <span class="comment">// foo 'string'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span>(<span class="number">0</span>) === <span class="literal">undefined</span>);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Function</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objPrototype = <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">console</span>.log(objPrototype);                          <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(objPrototype.__proto__);                <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(objPrototype.toString());               <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(objPrototype.valueOf());                <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objPrototype);                   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">// false !</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);                         <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>);                                <span class="comment">// [Function: Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);            <span class="comment">// true !</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);                       <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>);                              <span class="comment">// [Function: Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);          <span class="comment">// true ！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>JavaScript 提供了以下转型函数：</p>
<ul>
<li>转为数值类型：<code>Number(mix)、parseInt(string,radix)、parseFloat(string)</code></li>
<li>转为字符串类型：<code>toString(radix)、String(mix)</code></li>
<li>转为布尔类型：<code>Boolean(mix)</code></li>
</ul>
<ul>
<li><code>Number(mix)</code> 函数，可以将任意类型的参数mix转换为数值类型。其规则为：</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>Number(true)-&gt;1 Number(false)-&gt;0</td>
</tr>
<tr>
<td>Number</td>
<td>Number(num)-&gt;num</td>
</tr>
<tr>
<td>Null</td>
<td>Number(null)-&gt;0</td>
</tr>
<tr>
<td>Undefined</td>
<td>Number(undefined)-&gt;NaN</td>
</tr>
<tr>
<td>String</td>
<td>Number(‘012345’)-&gt;12345 Number(‘012345.6789’)-&gt;12345.6789 Number(‘’)-&gt;0 Number(‘A-Z’)-&gt;NaN</td>
</tr>
<tr>
<td>Object</td>
<td>调用对象的valueOf()方法，依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再依据前面的规则转换返回的值。</td>
</tr>
</tbody>
</table>
<p>下表列出了对象的 <code>valueOf()</code> 的返回值：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>valueOf()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Array</code></td>
<td>数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起，其操作与 Array.toString 和 Array.join 方法相同。</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>Boolean 值是</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Number</code></td>
<td>数字值</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>().valueOf());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>().toString());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).valueOf());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toString());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).toString());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Function</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>parseInt(string, radix)</code> 将字符串转换为整数类型。</p>
<p>它也有一定的规则：</p>
<ul>
<li>忽略字符串前面的空格，直至找到第一个非空字符。</li>
<li>如果第一个字符不是数字符号或者负号，返回 <code>NaN</code>。</li>
<li>如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止。</li>
<li>如果上步解析的结果以 <code>0</code> 开头，则将其当作八进制来解析；如果以 <code>0x</code> 开头，则将其当作十六进制来解析。</li>
<li>如果指定 <code>radix</code> 参数，则以 <code>radix</code> 为基数进行解析。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>parseFloat(string)</code> 将字符串转换为浮点数类型。</p>
<p>它的规则与 <code>parseInt</code> 基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外 <code>parseFloat</code> 会忽略所有前导 <code>0</code>，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。</p>
</li>
</ul>
<ul>
<li><p><code>toString(radix)</code> 方法。</p>
<p>除 <code>undefined</code> 和 <code>null</code> 之外的所有类型的值都具有 <code>toString()</code> 方法，转换成字符串表示。</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString())       <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.toString())            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toString(<span class="number">10</span>))    <span class="comment">// Wed Aug 17 2016 13:52:21 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.toString())              <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>String(mix)</code> 将任何类型的值转换为字符串：</p>
<ul>
<li><code>null</code> -&gt; “null”</li>
<li><code>undefined</code> -&gt; “undefined”</li>
<li>调用 <code>toString()</code> 方法，返回结果，如果没有 <code>toString()</code>，则报异常，无法转换。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Boolean(mix)</code> 函数，将任何类型的值转换为布尔值。</p>
<ul>
<li><code>false</code>：<code>false、&#39;&#39;、0、NaN、null、undefined</code></li>
<li><code>true</code> : 除了以上转换问 <code>false</code> 的</li>
</ul>
</li>
</ul>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>在某些情况下，即使我们不提供显示转换，JavaScript 也会进行自动类型转换，主要情况有：</p>
<ul>
<li><p>用于检测是否为非数值的函数：<code>isNaN(mix)</code></p>
<p><code>isNaN()</code> 函数，经测试发现，该函数会尝试将参数值用 <code>Number()</code> 进行转换，如果结果为 <code>“非数值”</code> 则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
</ul>
<ul>
<li><p>递增递减操作符（包括前置和后置）、一元正负符号操作符，其规则与 <code>Number()</code> 规则基本相同</p>
<ul>
<li>如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同 <code>Number()</code>），在执行加减1的操作，字符串变量变为数值变量。</li>
<li>如果是不包含有效数字字符的字符串，将变量的值设置为 <code>NaN</code>，字符串变量变成数值变量。</li>
<li>如果是布尔值 <code>false</code>，先将其转换为 <code>0</code> 再执行加减 <code>1</code> 的操作，布尔值变量编程数值变量。</li>
<li>如果是布尔值 <code>true</code>，先将其转换为 <code>1</code> 再执行加减 <code>1</code> 的操作，布尔值变量变成数值变量。</li>
<li>如果是浮点数值，执行加减 <code>1</code> 的操作。</li>
<li>如果是对象，先调用对象的 <code>valueOf()</code> 方法，然后对该返回值应用前面的规则。如果结果是 <code>NaN</code>，则调用 <code>toString()</code> 方法后再应用前面的规则。对象变量变成数值变量。</li>
</ul>
</li>
</ul>
<ul>
<li><p>加减乘除运算符、取模运算符</p>
<ul>
<li>如果一个操作数为 <code>NaN</code>，则结果为 <code>NaN</code></li>
<li><code>Infinity+Infinity -&gt; Infinity</code></li>
<li><code>-Infinity+(-Infinity) -&gt; -Infinity</code></li>
<li><code>Infinity+(-Infinity) -&gt; NaN</code></li>
<li><code>+0+(+0) -&gt; +0</code></li>
<li><code>(-0)+(-0) -&gt; -0</code></li>
<li><code>(+0)+(-0) -&gt; +0</code></li>
</ul>
<p>加号运算操作符在 JavaScript 也用于字符串连接符，所以加号操作符处理字符串是有所不同：</p>
<ul>
<li>如果两个操作值都是字符串，则将它们拼接起来</li>
<li>如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来</li>
<li>如果一个操作数是对象、数值或者布尔值，则调用 <code>toString()</code> 方法取得字符串值，然后再应用前面的字符串规则。对于 <code>undefined</code> 和 <code>null</code>，分别调用 <code>String()</code> 显式转换为字符串。</li>
<li>可以看出，加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。</li>
</ul>
</li>
</ul>
<ul>
<li><p>逻辑操作符（!、&amp;&amp;、||）</p>
<ul>
<li>逻辑非 <code>!</code> 操作符首先通过 <code>Boolean()</code> 函数将它的操作值转换为布尔值，然后求反。</li>
<li>逻辑与 <code>&amp;&amp;</code> 操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换：<ul>
<li>如果第一个操作数经 <code>Boolean()</code> 转换后为 <code>true</code>，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值）</li>
<li>如果有一个操作值为 <code>null</code>，返回 <code>null</code></li>
<li>如果有一个操作值为 <code>NaN</code>，返回 <code>NaN</code></li>
<li>如果有一个操作值为 <code>undefined</code>，返回 <code>undefined</code></li>
</ul>
</li>
<li>逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则：<ul>
<li>如果第一个操作值经 <code>Boolean()</code> 转换后为 <code>false</code>，则返回第二个操作值，否则返回第一个操作值（不是 <code>Boolean()</code> 转换后的值）</li>
<li>对于 <code>undefined</code>、<code>null</code> 和 <code>NaN</code> 的处理规则与逻辑与（&amp;&amp;）相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</p>
<ul>
<li>如果两个操作值都是数值，则进行数值比较</li>
<li>如果两个操作值都是字符串，则比较字符串对应的字符编码值</li>
<li>如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较</li>
<li>如果一个操作数是对象，则调用 <code>valueOf()</code> 方法（如果对象没有 <code>valueOf()</code> 方法则调用 <code>toString()</code> 方法），得到的结果按照前面的规则执行比较</li>
<li>如果一个操作值是布尔值，则将其转换为数值，再进行比较</li>
<li>注：<code>NaN</code> 是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<ul>
<li><p>相等操作符（==）</p>
<ul>
<li>如果一个操作值为布尔值，则在比较之前先将其转换为数值</li>
<li>如果一个操作值为字符串，另一个操作值为数值，则通过 <code>Number()</code> 函数将字符串转换为数值</li>
<li>如果一个操作值是对象，另一个不是，则调用对象的 <code>valueOf()</code> 方法，得到的结果按照前面的规则进行比较</li>
<li><code>null</code> 与 <code>undefined</code> 是相等的</li>
<li>如果一个操作值为 <code>NaN</code>，则相等比较返回 <code>false</code></li>
<li>如果两个操作值都是对象，则比较它们是不是指向同一个对象</li>
</ul>
</li>
</ul>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><ul>
<li><p><code>void UnaryExpression</code> 按如下流程解释:</p>
<ul>
<li>令 <code>expr</code> 为解释执行 <code>UnaryExpression</code> 的结果</li>
<li>调用 <code>GetValue(expr)</code></li>
<li>返回 <code>undefined</code></li>
</ul>
</li>
<li><p>注意：<code>GetValue</code> 一定会被调用，即使它的值不会被用到，但是这个表达式可能会有副作用(side-effects)。</p>
</li>
<li><p>为什么要用 <code>void</code>？<code>undefined</code> 不是保留字，可以重新赋值。采用 <code>void</code> 方式获取 <code>undefined</code> 便成了通用准则。</p>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000000474941" target="_blank" rel="noopener">谈谈JavaScript中的void操作符</a></p>
<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><p>运算符优先级</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>ECMAScript 做为一个高度抽象的面向对象语言，是通过对象来交互的。<br>一个对象就是属性集合，并拥有一个独立的 <code>原型对象</code>，这个 <code>原型对象</code> 可以是一个 <code>对象</code> 或者 <code>null</code>。<br>一个对象的 <code>原型对象</code> 是以对象内部的 <code>[[Prototype]]</code> 属性来引用的。</p>
<p>在示意图里边我们将会使用 <code>__&lt;internal-property&gt;__</code> 下划线标记来替代两个括号，对于 <code>prototype</code> 对象来说是：<code>__proto__</code>。</p>
<p>让我们看一个关于对象的基本例子。</p>
<p>对于以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  y: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们拥有一个这样的结构，两个显式的属性和一个隐藏的 <code>__proto__</code> 属性，这个属性是对 <code>Object.prototype</code> 的引用。</p>
<p><img src="images/basic-object.png" alt="basic-object"></p>
<p>这些 <code>prototype</code> 有什么用？</p>
<p>让我们以 <code>原型链</code> 的概念来回答这个问题。</p>
<h2 id="原型链（prototype-chain）"><a href="#原型链（prototype-chain）" class="headerlink" title="原型链（prototype-chain）"></a>原型链（prototype-chain）</h2><ul>
<li><code>原型对象</code> 也是简单的对象，所以他可以拥有自己的原型，如果一个原型对象的 <code>原型</code> 是一个非 <code>null</code> 的引用，延续下去，原型对象连成的链，就形成了 <code>原型链</code>。</li>
<li><code>原型链</code> 是一个用来实现 <code>继承</code> 和 <code>共享</code> 属性的有限长度的 <code>对象链</code>。</li>
<li><code>原型链</code> 是为了实现代码重用而设计的，在基于类的系统中，这个代码重用风格叫作 <code>继承</code>。</li>
</ul>
<p>ECMAScript 中没有类的概念，但是代码重用的风格并没有太多不同，ECMAScript 通过原型链来实现，即 <strong>原型继承(prototype based inheritance)</strong>，这种继承方式叫作 <strong>委托继承(delegation based inheritance)</strong>。</p>
<p>ES5标准化了一个实现原型继承的新的可选方法，使用 <code>Object.create</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">k</span>: <span class="string">'v'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a, &#123;<span class="attr">y</span>: &#123;<span class="attr">value</span>: <span class="number">20</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(a, &#123;<span class="attr">y</span>: &#123;<span class="attr">value</span>: <span class="number">30</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6标准化了 <code>__proto__</code> 属性，并且可以在对象初始化的时候使用它，如下面的用法。<br><code>b</code> 和 <code>c</code> 可以访问到 <code>a</code> 对象中定义的 <code>calculate()</code> 方法，是通过原型链 <code>lookup</code> 实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  calculate: <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + z</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">y</span>: <span class="number">20</span>, <span class="attr">__proto__</span>: a&#125;;</span><br><span class="line"><span class="comment">// 等价于 var b = Object.create(a, &#123;y: &#123;value: 20&#125;&#125;);</span></span><br><span class="line"><span class="keyword">var</span> c = &#123;<span class="attr">y</span>: <span class="number">30</span>, <span class="attr">__proto__</span>: a&#125;;</span><br><span class="line"><span class="comment">// 等价于 var c = Object.create(a, &#123;y: &#123;value: 30&#125;&#125;);</span></span><br><span class="line">b.calculate(<span class="number">30</span>); <span class="comment">// 60</span></span><br><span class="line">c.calculate(<span class="number">40</span>); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链-lookup-规则："><a href="#原型链-lookup-规则：" class="headerlink" title="原型链 lookup 规则："></a>原型链 <code>lookup</code> 规则：</h3><p>如果一个 <code>属性</code>/<code>方法</code> 在对象自身中无法找到，JS引擎会尝试遍历整个原型链，寻找这个 <code>属性</code>/<code>方法</code>，第一个被查找到的同名 <code>属性</code>/<code>方法</code> 会被使用。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回 <code>undefined</code> 值。</p>
<p>下一张图展示了对象 <code>a</code>，<code>b</code>，<code>c</code> 之间的继承关系：</p>
<p><img src="images/prototype-chain.png" alt="prototype-chain"></p>
<p>所以 <code>__proto__</code> 主要是给JS引擎用的，但是暴露给了我们，并且可以对其修改。</p>
<p>与此类似的还有 <code>作用域链</code> 及其 <code>lookup规则</code>，<code>原型链</code> 和 <code>作用域链</code> 的用途都是用来名字查找，给JS引擎用的。</p>
<p>区别是：原型链是属性上的名字查找，对象自身上查找，这条链可以运行时被修改，作用域链是上下文中的名字查找，这条链由代码决定。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><ul>
<li>如果没有明确为一个对象指定原型，那么它将会使用 <code>__proto__</code> 的默认值 <code>Object.prototype</code>。</li>
<li><code>Object.prototype</code> 对象自身也有一个 <code>__proto__</code> 属性，值为 <code>null</code>，这是原型链的终点。 即：<code>Object.prototype.__proto__ === null</code></li>
<li>The <code>__proto__</code> property of <code>Object.prototype</code> is an <code>accessor property</code> (a getter function and a setter function) that exposes the internal <code>[[Prototype]]</code> (either an object or null) of the object through which it is accessed.</li>
</ul>
<p>项目中建议不要直接使用 <code>__proto__</code> 读写原型，而是使用 <code>Object.getPrototypeOf()、Object.create()</code> 读写原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Shape.prototype = proto;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.getPrototype = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>) </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = <span class="keyword">new</span> Shape();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'circle:'</span>, circle.__proto__ === Shape.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'circle:'</span>, <span class="built_in">Object</span>.getPrototypeOf(circle) === Shape.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'circle:'</span>, <span class="keyword">typeof</span> circle);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'circle:'</span>, circle <span class="keyword">instanceof</span> Shape);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'circle:'</span>, circle <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rectangle = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ractangle:'</span>, rectangle.__proto__ === Shape.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ractangle:'</span>, <span class="built_in">Object</span>.getPrototypeOf(rectangle) === Shape.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ractangle:'</span>, <span class="keyword">typeof</span> rectangle);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ractangle:'</span>, rectangle <span class="keyword">instanceof</span> Shape);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ractangle:'</span>, rectangle <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objPrototype = <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">console</span>.log(objPrototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objPrototype);</span><br><span class="line"><span class="built_in">console</span>.log(objPrototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'__proto__:'</span>, <span class="string">'xxx'</span>.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>
<p><code>typeof</code> 和 <code>instanceof</code> 都是检测变量的类型，区别在于:</p>
<ul>
<li><code>typeof</code>: 可以用来区分原始值和对象。<code>typeof</code> 还可以让检查一个变量是否已声明，而不会抛出异常，没有任何一个函数可以实现此功能。</li>
<li><code>instanceof</code>: 可以用来区分对象，<code>instanceof</code> 对于所有的原始值都返回 false。</li>
</ul>
<p>typeof 在操作 <code>null</code> 时会返回 <code>&quot;object&quot;</code>，这是 JavaScript 语言本身的 bug。<br>不幸的是，这个 bug 永远不可能被修复了，因为太多已有的代码已经依赖了这样的表现。<br>这并不意味着，<code>null</code> 实际上是一个对象。</p>
<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[Configurable]]</code></td>
<td>表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否改变属性的特性，或者能否改变把属性改为访问器属性。<code>true</code></td>
<td></td>
</tr>
<tr>
<td><code>[[Enumerable]]</code></td>
<td>表示能否通过 <code>for-in</code> 循环返回属性。<code>true</code></td>
<td></td>
</tr>
<tr>
<td><code>[[Writable]]</code></td>
<td>表示能否修改属性值。<code>ture</code></td>
<td></td>
</tr>
<tr>
<td><code>[[Value]]</code></td>
<td>包含实际值。<code>undefined</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>严格模式下不合法的操作会抛出异常，非严格模式会忽略相关操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'liuyanjie'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'sax'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'M'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person);            <span class="comment">// &#123; name: 'liuyanjie' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sax);        <span class="comment">// M</span></span><br></pre></td></tr></table></figure>
<h4 id="访问器属性-getter-setter"><a href="#访问器属性-getter-setter" class="headerlink" title="访问器属性: getter setter"></a>访问器属性: <code>getter</code> <code>setter</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[Configurable]]</code></td>
<td>表示能否通过 <code>delete</code> 删除属性从而重新定义属性，能否改变属性的特性，或者能否改变把属性改为访问器属性。<code>true</code></td>
</tr>
<tr>
<td><code>[[Enumerable]]</code></td>
<td>表示能否通过 <code>for-in</code> 循环返回属性。<code>true</code></td>
</tr>
<tr>
<td><code>[[Getter]]</code></td>
<td>取值函数。<code>undefined</code></td>
</tr>
<tr>
<td><code>[[Setter]]</code></td>
<td>赋值函数。<code>undefined</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>getter</code> 和 <code>setter</code> 不一定要成对出现</li>
<li>只有 <code>getter</code> 函数证明该属性只读，尝试写入在非严格模式下会被忽略，严格模式会抛出错误</li>
<li>只有 <code>setter</code> 函数证明该属性只写，尝试读取在非严格模式下返回 <code>undefined</code>，严格模式则抛出错误</li>
<li>对象的 <code>数据属性</code>、<code>访问器属性</code> 都包含 <code>[[configurable]]</code> 和 <code>[[enumerable]]</code>，但不能同时有 <code>[[writeable]]</code>/<code>[[value]]</code> 和 <code>[[get]]</code>/<code>[[set]]</code>，数据属性也可以函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book1 = &#123; <span class="attr">_year</span>: <span class="number">2014</span>, <span class="attr">edition</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book1, <span class="string">'year'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year &gt; <span class="number">2014</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = year;</span><br><span class="line">      <span class="keyword">this</span>.edition += year - <span class="number">2014</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(book1);      <span class="comment">// &#123; _year: 2014, edition: 1, year: [Getter/Setter] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(book1.year);  <span class="comment">// 2014</span></span><br><span class="line">book.year = <span class="number">2016</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book1);      <span class="comment">// &#123; _year: 2016, edition: 3, year: [Getter/Setter] &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 对象 设置 多个 `数据属性` 和 `访问器属性`</span></span><br><span class="line"><span class="keyword">var</span> book2 = &#123; <span class="attr">_year</span>: <span class="number">2014</span>, <span class="attr">edition</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book2, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2014</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getContents: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'contents'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 属性 信息</span></span><br><span class="line"><span class="keyword">var</span> desc1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book2, <span class="string">'year'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(desc1);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   get: [Function],</span></span><br><span class="line"><span class="comment">//   set: [Function],</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">var</span> desc2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book2, <span class="string">'getContents'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(desc2);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: [Function],</span></span><br><span class="line"><span class="comment">//   writable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul>
<li>[观察者模式]例子<a href="http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="noopener">JavaScript实现MVVM监测一个普通对象的变化</a></li>
</ul>
<h3 id="ECMAScript5-对象保护功能"><a href="#ECMAScript5-对象保护功能" class="headerlink" title="ECMAScript5 对象保护功能"></a>ECMAScript5 对象保护功能</h3><p>在 JavaScript 里，默认情况下，你可修改任何你可以访问到的对象，你可以自由的删除对象的属性或覆盖对象的方法。<br>这在多人协作开发的项目中，会造成很大问题，因为你不知道你的修改会对别人造成什么样的影响。<br>如果你是一个模块或代码库的作者，你可能想锁定一些核心库的某些部分，保证任何人不能有意或无意的修改它们。<br>严格模式下抛出异常，普通模式下安静的失败；</p>
<ul>
<li>禁止添加属性：禁止扩展。即：禁止为对象添加属性和方法，但已存在的属性和方法是可以被修改和删除的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123; <span class="attr">name</span>: <span class="string">'liuht'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isFrozen:'</span>, <span class="built_in">Object</span>.isFrozen(person1));             <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isSealed:'</span>, <span class="built_in">Object</span>.isSealed(person1));             <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isExtensible:'</span>, <span class="built_in">Object</span>.isExtensible(person1));     <span class="comment">// -&gt; false</span></span><br><span class="line">person1.sex = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"><span class="built_in">console</span>.log(person1.sex);</span><br></pre></td></tr></table></figure>
<ul>
<li>禁止删除属性：密封。即：禁止删除对象已存在的属性和方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">'liuht'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(person2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isFrozen:'</span>, <span class="built_in">Object</span>.isFrozen(person2));             <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isSealed:'</span>, <span class="built_in">Object</span>.isSealed(person2));             <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isExtensible:'</span>, <span class="built_in">Object</span>.isExtensible(person2));     <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="keyword">delete</span> person2.name;</span><br><span class="line">person2.age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2);</span><br></pre></td></tr></table></figure>
<ul>
<li>禁止添加或删除属性：冻结。即：禁止修改对象已存在的属性和方法，所有字段都是只读的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> persion3 = &#123; <span class="attr">name</span>: <span class="string">'liuht'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(persion3);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isFrozen:'</span>, <span class="built_in">Object</span>.isFrozen(persion3));            <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isSealed:'</span>, <span class="built_in">Object</span>.isSealed(persion3));            <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'isExtensible:'</span>, <span class="built_in">Object</span>.isExtensible(persion3));    <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="keyword">delete</span> persion3.name;</span><br><span class="line">persion3.age = <span class="number">10</span>;</span><br><span class="line">persion3.name = <span class="string">'new name'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(persion3);</span><br></pre></td></tr></table></figure>
<p><strong>访问器属性</strong> 和 <strong>对象保护功能</strong> 都是针对 <strong>对象属性</strong> ，而不是 <strong>变量</strong></p>
<p>通常情况下对象拥有相同或者相似的状态结构（也就是相同的属性集合），赋以不同的状态值，在这个情况下我们可能需要使用 <code>构造函数</code>，其以指定的模式来创造对象。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>以指定的模式来创造对象</li>
<li>自动地为新创建的对象设置一个原型对象，这个原型对象存储在 <code>ConstructorFunction.prototype</code> 属性中。</li>
</ul>
<p>我们可以使用构造函数来重写上一个拥有对象 <code>b</code> 和对象 <code>c</code> 的例子。因此，对象 <code>a</code> 的角色由 <code>Foo.prototype</code> 来扮演：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>) </span>&#123; <span class="keyword">this</span>.y = y; &#125;</span><br><span class="line">Foo.prototype.x = <span class="number">10</span>;</span><br><span class="line">Foo.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Foo(<span class="number">30</span>);</span><br><span class="line">b.calculate(<span class="number">30</span>);</span><br><span class="line">c.calculate(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ === Foo.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__ === Foo.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(b.constructor === Foo);</span><br><span class="line"><span class="built_in">console</span>.log(c.constructor === Foo);</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo);</span><br><span class="line"><span class="built_in">console</span>.log(b.calculate === b.__proto__.calculate);</span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.calculate === Foo.prototype.calculate);</span><br></pre></td></tr></table></figure>
<p>这个代码可以表示为如下关系：</p>
<p>可以看到，构造函数 <code>Foo</code> 也有自己的 <code>__proto__</code>，即 <code>Function.prototype</code>，<code>Function.prototype</code> 通过其 <code>__proto__</code> 属性关联到 <code>Object.prototype</code>。</p>
<p><img src="images/constructor-proto-chain.png" alt="constructor-proto-chain"></p>
<p>想一下类的概念，构造函数和原型对象合在一起可以当作一个「类」了。</p>
<p>例如：Python的 <code>First-Class、Dynamic-Classes</code> 显然是以同样的 <code>属性/方法</code> 处理方案来实现的。从这个角度来说，Python 中的类可以看作 ECMAScript 使用的委托继承的一个语法糖。</p>
<p>在ES6中「类」的概念被标准化了，并且实际上以一种构建在构造函数上面的语法糖来实现，就像上面描述的一样。</p>
<p>用类的方式实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">' Doe'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar(<span class="string">'John'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName()); <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p><code>new</code> 操作符 都做了什么？</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数作用域赋给新对象，即 <code>this</code> 指向了新对象</li>
<li>执行构造函数中的代码，初始化新对象（即 <code>this</code>）</li>
<li>返回新对象的引用 <code>this</code>，没显示返回或返回 <code>this</code>，也可返回其他对象。</li>
</ol>
<p>只要用 <code>new</code> 操作符来调用函数就是构造函数，否则，就是普通函数。</p>
<p>Example：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> NewDate();</span><br><span class="line"><span class="built_in">console</span>.log(date <span class="keyword">instanceof</span> NewDate); <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(date <span class="keyword">instanceof</span> <span class="built_in">Date</span>);    <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>按指定模式创建对象的，但是对象类型无法标识，且每个方法在每个对象上都要重新创建一次。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.property1 = arg1;</span><br><span class="line">  o.property2 = arg2;</span><br><span class="line">  o.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.property1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.property2);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = createObject(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> o2 = createObject(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o1.property1);</span><br></pre></td></tr></table></figure>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ul>
<li>构造函数名字用来标志一个 <code>特定类型</code>，同样每个方法在每个对象上都要重新创建一次。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewObject</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property1 = arg1;</span><br><span class="line">  <span class="keyword">this</span>.property2 = arg2;</span><br><span class="line">  <span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.property1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> no1 = <span class="keyword">new</span> NewObject(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> no2 = <span class="keyword">new</span> NewObject(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构造函数属性 constructor 标志对象类型</span></span><br><span class="line"><span class="built_in">console</span>.log(no1.constructor == NewObject);</span><br><span class="line"><span class="built_in">console</span>.log(no1.constructor == <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(no2.constructor == NewObject);</span><br><span class="line"><span class="built_in">console</span>.log(no2.constructor == <span class="built_in">Object</span>);</span><br><span class="line"><span class="comment">// 检测对象　更可靠</span></span><br><span class="line"><span class="built_in">console</span>.log(no1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(no1 <span class="keyword">instanceof</span> NewObject);</span><br><span class="line"><span class="built_in">console</span>.log(no2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(no2 <span class="keyword">instanceof</span> NewObject);</span><br></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul>
<li>每个函数都有一个 <code>prototype</code> 属性，引用另一个对象，这个对象可以实现属性的共享。</li>
<li><code>prototype</code> 是构造函数的一个属性，<code>prototype</code> 指向的 <code>原型对象</code> 拥有一个<code>constructor</code> 属性指向构造函数。</li>
<li>通过构造函数创建的 <code>对象实例</code> 可以通过 <code>__proto__</code> 访问 <code>原型对象</code>，但是不能重写，重名的属性将屏蔽原型中的同名属性。</li>
<li>在原型中修改属性，会立刻在 <code>对象实例</code> 中反映出来。但是如果重写整个原型对象，那么实例对象将找不到原型中定义的属性。</li>
<li><code>prototype</code> 和 <code>constructor</code> 构成了双向链表。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrototypeObject</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">PrototypeObject.prototype.name = <span class="string">'PrototypeObject'</span>; <span class="comment">// name 是多实例共享的</span></span><br><span class="line">PrototypeObject.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> po1 = <span class="keyword">new</span> PrototypeObject();</span><br><span class="line">po1.sayName();</span><br><span class="line"><span class="keyword">var</span> po2 = <span class="keyword">new</span> PrototypeObject();</span><br><span class="line">po2.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(po1.sayName === po2.sayName);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(po1.sayName() === po2.sayName());   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(PrototypeObject.prototype.constructor === PrototypeObject); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个实例　拥有一个[[Prototype]]属性指向原型对象，但是JS代码无法访问此属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(PrototypeObject.prototype.isPrototypeOf(po1));              <span class="comment">// true  // 判断po1.[[Prototype]] ===</span></span><br><span class="line"><span class="built_in">console</span>.log(PrototypeObject.prototype.isPrototypeOf(po2));              <span class="comment">// true  // 判断po2.[[Prototype]] ===</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(po1) === PrototypeObject.prototype);  <span class="comment">// 返回原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(po1.hasOwnProperty(<span class="string">'sayName'</span>));                             <span class="comment">// 判断是否是对象属性  检测属性存在于对象中还是原型对象中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>) </span>&#123;               <span class="comment">// 判断是否是原型属性</span></span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys();                    // 返回所有可枚举的实例属性</span></span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames();     // 返回所有实例属性</span></span><br><span class="line"><span class="comment">// 原型同样可以这样定义：原型对象 = 字面量，prototype的constructor不再等于PrototypeObject，但是instanceof()仍能继续工作。</span></span><br><span class="line">PrototypeObject.prototype = &#123; <span class="comment">// 这样把整个原型改了</span></span><br><span class="line">    <span class="keyword">constructor</span>: Person // 默认的<span class="keyword">constructor</span>被覆盖掉了 [[Enumerable]]会变成true</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(PrototypeObject.prototype, '<span class="keyword">constructor</span>', &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Persion</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="组合构造函数和原型模式-默认模式"><a href="#组合构造函数和原型模式-默认模式" class="headerlink" title="组合构造函数和原型模式 - [默认模式]"></a>组合构造函数和原型模式 - [默认模式]</h3><ul>
<li>实例属性在构造函数中定义 共享属性在原型中定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructPrototypeObject</span>(<span class="params">name, desc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">ConstructPrototypeObject.prototype.display = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.desc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><ul>
<li>只在第一次调用构造函数时 实例化原型，好像没这个问题。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructPrototypeObject</span>(<span class="params">name, desc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.desc = desc;</span><br><span class="line">  <span class="keyword">if</span> (!ConstructPrototypeObject.prototypeInstantiated) &#123;</span><br><span class="line">      <span class="comment">//只在第一次调用构造函数时 实例化原型</span></span><br><span class="line">    ConstructPrototypeObject.prototype.prototypeInstantiated = <span class="literal">true</span>;</span><br><span class="line">    ConstructPrototypeObject.prototype.display = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.desc);</span><br><span class="line">    &#125;;</span><br><span class="line">    ConstructPrototypeObject.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    ConstructPrototypeObject.prototypeInstantiated = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展模式-（寄生模式）"><a href="#扩展模式-（寄生模式）" class="headerlink" title="扩展模式 （寄生模式）"></a>扩展模式 （寄生模式）</h3><ul>
<li>这种方式，可以用来扩展原生对象，在不修改原生对象的前提下，扩展方法，并不影响类型识别。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString());</span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> SpecialArray);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><ul>
<li>数据成员位于 <code>作用域链</code> 中，不存在 <code>原型链</code> 或 <code>对象的属性</code>，可实现 <code>私有属性</code>，防止数据被其他程序改动时使用，适合用于一些安全环境，这些环境禁止使用 <code>this</code> 和 <code>new</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">var</span> name = name;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">'liuyanjie'</span>, <span class="number">22</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line">friend.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(friend.name); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = name;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'liuyanjie'</span>, <span class="number">22</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line">friend.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(friend.name); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里可以定义闭包变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'liuyanjie'</span>, <span class="number">22</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line">friend.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(friend.name); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>原型属性会被所有实例共享</li>
<li>无法向超类传递参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.supProperty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.supProperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());</span><br><span class="line"><span class="comment">// 借用构造函数    在子类型的内部调用父类型的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 指 SubType 普通函数调用 把函数当作一个模板 同时可以传递参数</span></span><br><span class="line">  SupType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instance.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance);</span><br></pre></td></tr></table></figure>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ul>
<li>原型链继承原型</li>
<li>借用构造函数继承实例属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);           <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();    <span class="comment">// 构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">'liuyanjie'</span>, <span class="number">22</span>);</span><br><span class="line">instance.colors.push(<span class="string">'black'</span>);</span><br><span class="line">instance.sayName();</span><br><span class="line">instance.sayAge();</span><br></pre></td></tr></table></figure>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul>
<li>此方式必须有一个对象作为基础，作为原型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 临时性构造函数</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.create();    <span class="comment">//此方法即为原型式继承</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;          <span class="comment">// 工厂</span></span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original);      <span class="comment">// 封装了原型式继承</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><ul>
<li>借用构造函数继承属性</li>
<li>原型链的混成形式继承方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, supType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(supType.prototype);</span><br><span class="line">  prototype.constructor = subType;</span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node.js原生实现的继承函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exports.inherits = <span class="function"><span class="keyword">function</span>(<span class="params">ctor, superCtor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctor === <span class="literal">undefined</span> || ctor === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The constructor to `inherits` must not be '</span> +</span><br><span class="line">                        <span class="string">'null or undefined.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (superCtor === <span class="literal">undefined</span> || superCtor === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The super constructor to `inherits` must not '</span> +</span><br><span class="line">                        <span class="string">'be null or undefined.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (superCtor.prototype === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The super constructor to `inherits` must '</span> +</span><br><span class="line">                        <span class="string">'have a prototype.'</span>);</span><br><span class="line">  ctor.super_ = superCtor;</span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;value: ctor, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对象构造和原型链总结"><a href="#对象构造和原型链总结" class="headerlink" title="对象构造和原型链总结"></a>对象构造和原型链总结</h2><p>上面不论是有多少对象构造模式和原型继承模式，只要理解其本质，就容易根据自己的需要实现想要的效果，上面的各种方式都是别人用惯的套路。</p>
<p>构造函数为了构造对象，实现不同功能，第一要先有一个对象（不论怎么来的），然后控制 <code>原型链</code> 和 <code>作用域链</code>。</p>
<p>下图是一个JavaScript Prototype Chain关系图：<a href="images/javascript-prototype.png">查看原图</a></p>
<p><img src="images/javascript-prototype.png" alt="JavaScript Prototype Chain"></p>
<p>上面的内容都是静态的内容，主要是想把 原型链 讲清楚。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明： <code>function 函数名称 (参数){ 函数体 }</code>。</p>
<p>函数表达式： <code>[var f = ] function [函数名称](参数){ 函数体 }</code>，如果有函数名，就是命名函数表达式。</p>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？</p>
<p>ECMAScript 是通过上下文来区分的，如果 <code>function foo(){}</code> 是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果 <code>function foo(){}</code> 被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;              <span class="comment">// 声明，因为它是程序的一部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;;   <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;;         <span class="comment">// 表达式，因为它是new表达式</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;            <span class="comment">// 声明，因为它是函数体的一部分</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>还有一种函数表达式不太常见，就是被括号括住的 <code>(function foo(){})</code>，他是表达式的原因是因为括号， <code>()</code> 是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;      <span class="comment">// 函数声明</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;);   <span class="comment">// 函数表达式：包含在分组操作符内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  (<span class="keyword">var</span> x = <span class="number">5</span>);        <span class="comment">// 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 <code>eval</code> 对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里： <code>eval(&#39;(&#39; + json + &#39;)&#39;)</code>，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  &#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;; <span class="comment">// "&#123;" 和 "&#125;" 做解析成代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(&#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;); <span class="comment">// 分组操作符强制将"&#123;" 和 "&#125;"作为对象字面量来解析</span></span><br></pre></td></tr></table></figure>
<p>匿名函数的好几种写法，一般情况下写匿名函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</span><br></pre></td></tr></table></figure>
<p>但下面几种写法也是可以的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure>
<p>现在，在我们知道了对象的基础之后，让我们看看运行时程序的执行 <code>runtime program execution</code> 在ECMAScript中是如何实现的。</p>
<h2 id="执行上下文堆栈"><a href="#执行上下文堆栈" class="headerlink" title="执行上下文堆栈"></a>执行上下文堆栈</h2><ul>
<li>EC(执行环境或者执行上下文，Execution Context)</li>
<li>ECS(执行环境堆栈或者执行上下文堆栈，Execution Context Stack)</li>
<li>VO(变量对象，Variable Object)</li>
<li>AO(活动对象，Active Object)</li>
<li>ScopeChain(作用域链)和 <code>[[scope]]</code> 属性</li>
</ul>
<p>有三种类型的ECMAScript代码：</p>
<p><code>全局代码</code>、<code>函数代码</code>、<code>eval代码</code></p>
<ul>
<li>每个代码是在其执行上下文（EC）中被求值的。</li>
<li>全局上下文只有一个，可能有多个函数执行上下文以及 <code>eval</code> 执行上下文。</li>
<li>对一个函数的每次调用，会进入到函数执行上下文中，并对函数代码类型进行求值。</li>
<li>每次对 <code>eval</code> 函数进行调用，会进入 <code>eval</code> 执行上下文并对其代码进行求值。</li>
</ul>
<blockquote>
<p>注意，一个函数可能会创建无数的上下文，因为对函数的每次调用（即使这个函数递归的调用自己）都会生成一个具有新状态的上下文：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// call the same function,</span></span><br><span class="line"><span class="comment">// generate three different contexts in each call,</span></span><br><span class="line"><span class="comment">// with different context state (e.g. value of the "bar" argument)</span></span><br><span class="line">foo(<span class="number">10</span>);</span><br><span class="line">foo(<span class="number">20</span>);</span><br><span class="line">foo(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>一个 <code>执行上下文(EC)</code> 可能会触发另一个 <code>执行上下文(EC)</code>，如，一个函数调用另一个函数。从逻辑上来说，这是以栈的形式实现的，它叫作 <code>执行上下文栈(ECS)</code>。</p>
<p>一个触发其他上下文的上下文叫作 <code>caller</code>，被触发的上下文叫作 <code>callee</code>，<code>callee</code> 在同一时间可能是一些其他 <code>callee</code> 的 <code>caller</code>。</p>
<p>当一个 <code>caller</code> 触发（调用）了一个 <code>callee</code> ，这个 <code>caller</code> 会暂缓自身的执行，然后把控制权传递给 <code>callee</code>，控制权转移。</p>
<p>这个 <code>callee</code> 被push到 <code>执行上下文栈(ECS)</code> 中，并成为一个 <code>活动的</code> <code>执行上下文</code>，在 <code>callee</code> 的上下文结束后（<code>callee</code> 可能简单的返回或者由于异常而退出，一个抛出的但没有被捕获的异常可能退出一个或者多个上下文），它会把控制权返回给 <code>caller</code>，然后 <code>caller</code> 的上下文继续执行直到它结束，以此类推。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller" target="_blank" rel="noopener">Caller</a></p>
<blockquote>
<p>function.caller[Non-standard]<br>The function.caller property returns the function that invoked the specified function.<br>If the function f was invoked by the top level code, the value of f.caller is null, otherwise it’s the function that called f.<br>This property replaces the obsolete arguments.caller property of the arguments object.<br>The special property <code>__caller__</code>, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123; g(n - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">n</span>) </span>&#123; <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123; f(n); &#125; <span class="keyword">else</span> &#123; stop(); &#125; &#125;</span><br><span class="line">f(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(2) -&gt; g(1) -&gt; f(1) -&gt; g(0) -&gt; stop()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stop.caller === g &amp;&amp; f.caller === g &amp;&amp; g.caller === f</span></span><br></pre></td></tr></table></figure>
<p>Example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = trace, stack = <span class="string">'Stack trace:'</span>;</span><br><span class="line">  <span class="keyword">while</span> (f) &#123;</span><br><span class="line">    stack += <span class="string">'\n'</span> + f.name;</span><br><span class="line">    f = f.caller;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> trace(); &#125;</span><br><span class="line"><span class="keyword">var</span> stacks = myFunc();</span><br><span class="line"><span class="built_in">console</span>.log(stacks);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> myFunc(); &#125;</span><br><span class="line"><span class="keyword">var</span> stacks = f();</span><br><span class="line"><span class="built_in">console</span>.log(stacks);</span><br></pre></td></tr></table></figure>
<p>下图是上面代码的函数调用链，对应于 <code>执行上下文(EC)</code>，在引擎层面，函数只是 <code>执行上下文</code> 的一个属性。</p>
<p><img src="images/caller-chain.png" alt="caller-chain"></p>
<p>所有ECMAScript程序的运行时可以用 <code>执行上下文栈（ECS）</code> 来表示，栈顶是当前 <code>活动的执行上下文</code>：</p>
<p><img src="images/ec-stack.png" alt="ec-stack"></p>
<p>当程序开始的时候它会进入 <code>全局执行上下文</code>，此上下文位于栈顶并且是栈中的第一个元素。然后全局代码进行一些 <code>初始化</code>。</p>
<p>当初始化完成之后，运行时系统就会等待一些事件，这些事件将会触发一些函数，从而进入新的执行上下文中。</p>
<p>在下个图中，拥有一个 <code>函数上下文 EC1</code> 和 <code>全局上下文 GlobalEC</code>，当 <code>EC1</code> 进入和退出全局上下文的时候下面的栈将会发生变化：</p>
<p><img src="images/ec-stack-changes.png" alt="ec-stack-changes"></p>
<p>这就是 ECMAScript 的运行时系统如何真正地管理代码执行的。</p>
<p>栈中的每个 <code>执行上下文</code> 都可以用一个对象来表示。</p>
<p>让我们来看看它的结构以及一个上下文到底需要什么状态（属性）来执行它的代码。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>一个执行上下文可以抽象的表示为一个简单的对象。每一个执行上下文拥有一些属性（可以叫作上下文状态）用来跟踪或表示和它相关的代码的执行过程。</p>
<p>在下图中展示了一个上下文的结构：</p>
<p><img src="images/execution-context.png" alt="execution-context"></p>
<p>除了这三个必需的属性 <code>变量/活动对象</code>、<code>作用域链</code>、<code>this</code> 之外，<code>执行上下文</code> 可以拥有其他状态，这取决于实现。</p>
<p>让我们详细看看上下文中的这些重要的属性。</p>
<h3 id="变量对象（variable-object）"><a href="#变量对象（variable-object）" class="headerlink" title="变量对象（variable object）"></a>变量对象（variable object）</h3><p><code>变量对象</code> 是与 <code>执行上下文</code> 相关的 <code>数据作用域</code>，所以也可以叫做 <code>作用域对象</code>。</p>
<p>它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的 <code>变量</code> 和 <code>函数</code>。</p>
<blockquote>
<p>函数表达式（与函数声明相对）不包含在变量对象之中。</p>
</blockquote>
<p>变量对象是一个抽象概念。对于不同的上下文类型，在物理上，是使用不同的对象。</p>
<p>在全局上下文中变量对象就是全局对象本身，这就是为什么我们可以通过 <code>全局对象的属性名</code> 来关联 <code>“全局变量”</code>。</p>
<p>全局变量：</p>
<p>JavaScript中并不存在 <code>全局变量</code>，所谓的全局变量，不过是 <code>Global对象的一个属性</code>，叫 <code>全局属性</code> 还差不多，或者叫 <code>全局变量对象</code>，变量和属性虽然都是数据的引用方式，但是却有很大差别。</p>
<p>Example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = global || <span class="built_in">window</span>;</span><br><span class="line">global.env = <span class="string">'production'</span>;</span><br><span class="line">NODE_ENV = <span class="string">'production'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(env);</span><br><span class="line"><span class="built_in">console</span>.log(global.NODE_ENV);</span><br><span class="line"><span class="comment">// 访问 全局属性 直接通过属性名就可以了。</span></span><br><span class="line"><span class="comment">// 这也是为什么被误称为 全局对象 的原因之一。</span></span><br></pre></td></tr></table></figure>
<p>让我们在全局执行上下文中考虑下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;       <span class="comment">// function declaration, FD</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;);    <span class="comment">// function expression, FE</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.foo == foo, <span class="built_in">window</span>.bar == bar);  <span class="comment">// true // true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);       <span class="comment">// ReferenceError, "baz" is not defined</span></span><br></pre></td></tr></table></figure>
<p>之后，全局上下文的 <code>变量对象</code> 将会拥有如下属性：</p>
<p><img src="images/variable-object.png" alt="variable-object"></p>
<p>函数 <code>baz</code> 是一个函数表达式，没有被包含在变量对象之中。这就是为什么当我们想要在函数自身之外访问它的时候会出现 <code>ReferenceError</code>。</p>
<p>注意，与其他语言（比如C/C++）相比，在ECMAScript中只有函数可以创建一个新的作用域。在函数作用域中所定义的变量和内部函数在函数外边是不能直接访问到的，而且并不会污染全局变量对象。</p>
<p>使用 <code>eval</code> 我们也会进入一个新的执行上下文。无论如何，<code>eval</code> 使用全局的变量对象或者使用 <code>caller</code>（比如eval被调用时所在的函数）的变量对象。</p>
<p>那么函数和它的变量对象是怎么样的？</p>
<p>在函数上下文中，<code>变量对象</code> 是以 <code>活动对象</code> 来表示的。</p>
<p>为什么全局上下文中不需要 <code>活动对象</code>，而 <code>变量对象</code> 就是 <code>全局对象本身</code>？</p>
<p>因为 <code>全局上下文</code> 只有一个，用 <code>全局对象</code> 即可作为 <code>变量对象</code> 提供名字查找，而同一函数可能 会同时存在多个 <code>函数上下文</code>，每个上下文各不相同，且 <code>函数上下文</code> 与 <code>全局上下文</code> 又有不同，所以引入了 <code>活动对象</code> 来表示 <code>变量对象</code>。</p>
<h3 id="活动对象（activation-object）"><a href="#活动对象（activation-object）" class="headerlink" title="活动对象（activation object）"></a>活动对象（activation object）</h3><p>当一个函数被 <code>caller</code> 调用，一个特殊的对象，叫作 <code>活动对象</code>（activation object）将会被创建。</p>
<p>这个对象中包含 <code>形参</code> 和 <code>arguments</code> 对象（是对形参的一个映射，但是值是通过索引来获取）。</p>
<p><code>活动对象</code> 之后会做为函数上下文的 <code>变量对象</code> 来使用。</p>
<p>换句话说，函数的 <code>活动对象</code> 就是一个同样简单的 <code>变量对象</code>，但是除了 <code>变量</code> 和 <code>函数声明</code> 之外，它还存储了 <code>形参</code> 和 <code>arguments</code> 对象，并叫作 <code>活动对象</code>。</p>
<p>即：<code>活动对象</code> &lt;=&gt; <code>变量对象</code> + <code>形参</code> + <code>arguments</code> + <code>变量声明</code> + <code>函数声明</code></p>
<p>全局上下文中并没有 <code>形参</code>，更没有 <code>arguments</code>，所以和函数上下文不同，这是全局上下文和函数上下文的不同之一。</p>
<p>考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// FD</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;);  <span class="comment">// FE</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>我们看下函数foo的上下文中的活动对象：</p>
<p><img src="images/activation-object.png" alt="activation-object"></p>
<p>函数表达式baz还是没有被包含在 <code>变量/活动对象</code> 中。</p>
<p>在ES5中 <code>变量对象</code> 和 <code>活动对象</code> 被并入了 <code>词法环境模型</code>（lexical environments model）。</p>
<p>众所周知，在 ECMAScript 中我们可以使用内部函数，然后在这些内部函数中可以引用父函数的变量或者全局上下文中的变量。</p>
<p>当我们把 <code>变量对象</code> 命名为 执行上下文的 <code>作用域对象</code>，与上面讨论的原型链相似，作用域对象 可以 形成一条链，叫作 <code>作用域链</code>。</p>
<h3 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="headerlink" title="作用域链(scope chain)"></a>作用域链(scope chain)</h3><p><code>作用域链</code> 是一个 <code>作用域对象</code>（即：<code>变量/活动对象</code>） 列表，代码中出现的标识符在这个列表中进行查找。</p>
<p>这个规则还是与原型链同样简单：</p>
<p>如果一个变量在函数自身的 <code>作用域对象</code>中没有找到，那么将会查找它父函数（外层函数）的 <code>作用域对象</code>，以此类推。</p>
<p>就上下文而言，标识符指的是：<code>变量名称、函数声明、形参</code> 等。</p>
<p>自由变量(free variables)：</p>
<p>当一个函数在其代码中引用一个不是 <code>局部变量</code>（或者局部函数或者一个形参）的标识符，那么这个标识符就叫作 <code>自由变量</code>，搜索这些 <code>自由变量</code> 正好就要用到 <code>作用域链</code>。</p>
<p>在通常情况下，<code>作用域链</code> 是一个包含所有 <code>caller的变量/活动对象</code> 加上（在作用域链头部的）<code>callee（自身）变量/活动对象</code> 的一个列表。</p>
<p>这个 <code>作用域链</code> 也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像 <code>with对象</code> 或者特殊的 <code>catch从句（catch-clauses）对象</code>。</p>
<p>当解析一个标识符的时候，会从作用域链中的 <code>变量对象</code> 开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找－重复这个过程，就和原型链查找一样。</p>
<p>综上：<code>作用域链</code> 可以看作是 <code>变量对象链</code>。</p>
<p>我们可以假设通过隐式的 <code>__parent__</code> 属性 来和 <code>作用域链对象</code> 进行交互，这个属性指向作用域链中的下一个对象。</p>
<p>这个方案可能在真实的 Rhino 代码中经过了测试，并且这个技术很明确得被用于ES5的词法环境中（在那里被叫作outer连接）。</p>
<p>作用域链的另一个表现方式可以是一个简单的数组。利用 <code>__parent__</code> 概念，我们可以用下面的图来表现上面的例子（并且父变量对象存储在函数的 <code>[[Scope]]</code> 属性中）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><img src="images/scope-chain.png" alt="scope-chain"></p>
<p>在代码执行过程中，作用域链可以通过使用 <code>with语句</code> 和 <code>catch从句对象</code> 来增强。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。</p>
<p>这个事实导致作用域链查找变为两个维度：</p>
<ol>
<li>首先是作用域链连接，然后</li>
<li>在每个作用域链连接上－深入作用域链连接的原型链（如果此连接拥有原型）。</li>
</ol>
<p>对于这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// in SpiderMonkey global object i.e. variable object of the global context inherits from "Object.prototype",</span></span><br><span class="line"><span class="comment">// 全局对象(global|window) 依然是 Object 对象的实例，所以会从 Object.prototype 继承 属性和方法</span></span><br><span class="line"><span class="comment">// so we may refer "not defined global variable x", which is found in the prototype chain</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// "foo" local variables</span></span><br><span class="line">  <span class="keyword">var</span> w = <span class="number">40</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// "x" is found in the "Object.prototype", because &#123;z: 50&#125; inherits from it</span></span><br><span class="line">  <span class="keyword">with</span> (&#123;<span class="attr">z</span>: <span class="number">50</span>&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(w, x, y, z); <span class="comment">// 40, 10, 30, 50 // 关键在这里</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// after "with" object is removed from the scope chain,</span></span><br><span class="line">  <span class="comment">// "x" is again found in the AO of "foo" context;</span></span><br><span class="line">  <span class="comment">// variable "w" is also local</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, w); <span class="comment">// 100, 40</span></span><br><span class="line">  <span class="comment">// and that's how we may refer shadowed global "w" variable in the browser host environment</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.w); <span class="comment">// 20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我们可以给出如下的结构：</p>
<p><img src="images/scope-chain-with.png" alt="scope-chain-with"></p>
<blockquote>
<p>在 <code>GlobalVO</code> 向上查找时，会同时存在 <code>__parent__</code> 和 <code>__proto__</code>，即 <code>作用域链</code> 和 <code>原型链</code> 在引擎内部的表示对象上有了交点，在查找 <code>__parent__</code> 之前，首先查找 <code>__proto__</code> 链，此时，<code>作用域链</code> 已到达终点，也不需要继续查找。只在 <code>GlobalVO</code> <code>作用域链</code> 和 <code>原型链</code> 才会有交点。</p>
</blockquote>
<blockquote>
<p>注意，不是在所有的实现中 <code>全局对象</code> 都是继承自 <code>Object.prototype</code>，但是通常 是这样的。</p>
</blockquote>
<p>由于所有 <code>父变量对象</code> 都存在，所以在内部函数中获取父函数中的数据没有什么特别－就是遍历作用域链去搜寻需要的变量。</p>
<p>就像上边提及的，在一个上下文结束之后，它所有的状态和它自身都会被销毁，这个上下文（函数）可能会返回另一个函数，这个返回的函数之后可能在另一个上下文中被调用。<br>如果 <code>自由变量</code> 的上下文已经「消失」了，将会出现问题，有一个方式可以帮助我们解决这个问题，叫作 <code>闭包</code>，其在ECMAScript 中就是和 <code>作用域链</code> 的概念紧密相关的。</p>
<p>父函数上下文被销毁之后，为了满足子函数查找 <code>自由变量</code> 的需求，子函数在创建的时候，需要保存父函数的 <code>执行上下文</code>，保存的字段 叫 <code>[[Scope]]</code>，这一方式被称为 <code>闭包</code>。</p>
<h4 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h4><p>在 ECMAScript 中，函数是一级（<code>first-class</code>）对象。这意味着函数可以做为参数传递给其他函数 <code>「函数类型参数」（funargs）</code>。</p>
<p>接收 <code>「函数类型参数」</code> 的函数叫作 <code>高阶函数</code>。或者，贴近数学一些，叫作 <code>高阶操作符</code>。同样函数也可以返回一个函数，<code>「函数类型值」（funvals）</code>。</p>
<p>这有两个在概念上与 <code>「函数类型参数」</code> 和 <code>「函数类型值」</code> 相关的问题。</p>
<p>并且这两个子问题在 <code>Funarg problem</code> 中很普遍。为了解决整个 <code>Funarg problem</code>，<code>闭包</code> 的概念被创造了出来。</p>
<p><code>Funarg problem</code> 的第一个子问题是 <code>「向上funarg问题」</code>。它会在当一个函数从另一个函数中返回并且使用上面所提到的 <code>自由变量</code> 的时候出现。</p>
<p>为了在即使 <code>父函数上下文销毁</code> 的情况下也能访问其中的变量，内部函数在被创建的时候会在它的 <code>[[Scope]]</code> 属性中保存 <code>父函数的作用域链</code>。</p>
<p>所以当函数被调用的时候，它上下文的作用域链会被格式化成 <code>活动对象</code> 与 <code>[[Scope]]</code> 属性的和：</p>
<p><code>Scope chain = AO + [[Scope]]</code>。</p>
<p>函数在创建时会保存父函数的 <code>作用域链</code>，这个保存下来的 <code>作用域链</code> 将会在未来的函数调用时用来 <code>查找变量</code>。</p>
<p>如果从对象引用层面来理解，<code>[[Scope]]</code> 被另外一个对象（函数）引用，引擎不会回收这些资源，所以闭包容易带来内存泄漏的隐患。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "foo" returns a function and this returned function uses free variable "x"</span></span><br><span class="line"><span class="keyword">var</span> returnedFunction = foo();</span><br><span class="line"><span class="comment">// global variable "x"</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// execution of the returned function</span></span><br><span class="line">returnedFunction(); <span class="comment">// 10, but not 20</span></span><br></pre></td></tr></table></figure>
<p>这个类型的作用域叫作 <code>静态（或者词法）作用域</code>。我们看到 <code>变量x</code> 在返回的bar函数的 <code>[[Scope]]</code> 属性中被找到。</p>
<p>通常来说，也存在动态作用域，那么上面例子中的 <code>变量x</code> 将会被解析成 <code>20</code>，而不是 <code>10</code>。但是，动态作用域在 ECMAScript 中没有被使用。</p>
<p><code>Funarg problem</code> 的第二个子问题是 <code>「向下funarg问题」</code>。它会在当一个函数作为另一个函数的参数并且使用上面所提到的 <code>自由变量</code> 的时候出现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global "x"</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// global function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">funArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// local "x"</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// there is no ambiguity, because we use global "x", </span></span><br><span class="line">  <span class="comment">// which was statically saved in [[Scope]] of the "foo" function,</span></span><br><span class="line">  <span class="comment">// but not the "x" of the caller's scope, which activates the "funArg"</span></span><br><span class="line">  funArg(); <span class="comment">// 10, but not 20</span></span><br><span class="line">&#125;)(foo); <span class="comment">// pass "down" foo as a "funarg"</span></span><br></pre></td></tr></table></figure>
<p><code>词法作用域/静态作用域</code>：变量的作用域是在 <code>定义时</code> 决定而不是 <code>运行时</code> 决定，也就是说 <code>词法作用域</code> 取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。<code>with</code> 和 <code>eval</code> 除外，所以只能说JS的作用域机制非常接近 <code>词法作用域（Lexical scope）</code>。</p>
<p>我们可以断定 <code>静态作用域</code> 是一门语言拥有 <code>闭包</code> 的必需条件。但是，一些语言可能会同时提供动态和静态作用域，允许程序员做选择－什么应该 <code>包含</code> 在内和什么不应包含在内。</p>
<p>由于在 ECMAScript 中只使用了 <code>静态作用域</code>，所以：ECMAScript 完全支持闭包，技术上是通过函数的 <code>[[Scope]]</code> 属性实现的。</p>
<p>现在我们可以给闭包下一个准确的定义：<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学" target="_blank" rel="noopener">闭包</a> )</p>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。<br>这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。<br>所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。<br>闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
<p>闭包是一个代码块（在ECMAScript是一个函数）和以 <code>静态方式</code>/<code>词法方式</code> 进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到 <code>自由变量</code>。</p>
<p>闭包使得一个函数能够通过作用域链查找到另一个函数作用域中的变量。</p>
<p>闭包影响了作用域链，尤其是那些被销毁的上下文。</p>
<p>注意，由于每个（标准的）函数都在创建的时候保存了 <code>[[Scope]]</code>，所以理论上来讲，ECMAScript 中的所有函数都是闭包。</p>
<p>另一个需要注意的重要事情是，多个函数可能拥有相同的父作用域，比如当我们拥有两个内部/全局函数的时候。</p>
<p>在这种情况下，<code>[[Scope]]</code> 属性中存储的变量是在拥有相同父作用域链的所有函数之间共享的。</p>
<p>一个闭包对变量进行的修改会体现在另一个闭包对这些变量的读取上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> ++x; &#125;,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> --x; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> closures = baz();</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  closures.foo(), <span class="comment">// 2</span></span><br><span class="line">  closures.bar()  <span class="comment">// 1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="images/shared-scope.png" alt="shared-scope"></p>
<p>确切来说这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是同样的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3, but not 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3, but not 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3, but not 2</span></span><br><span class="line"><span class="comment">// 这里有几种技术可以解决这个问题。</span></span><br><span class="line"><span class="comment">// 其中一种是在作用域链中提供一个额外的对象－比如，使用额外函数：</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(k); <span class="comment">// pass "k" value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// now it is correct</span></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>因为所有这些函数拥有同一个 <code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。</p>
<p>建议了解一下其他语言闭包的支持情况。</p>
<p>然后我们移动到下个部分，考虑一下执行上下文的最后一个属性，关于 this 值的概念。</p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p><code>this</code> 是一个与执行上下文相关的特殊对象。因此，它可以叫作 <code>上下文对象</code>，也就是用来指明执行上下文是在对象上触发的。</p>
<p>任何对象都可以做为上下文中的 <code>this</code> 的值。在一些对 ECMAScript 执行上下文和部分 <code>this</code> 的描述中的所产生误解，<code>this</code> 经常被错误的描述成是变量对象的一个属性。</p>
<p>正确的是：<code>this是执行上下文的一个属性，而不是变量对象的一个属性</code>。这个特性非常重要，因为如果 <code>this</code> 是变量对象的属性，<code>this</code> 会参与标识符解析过程，然而，<code>this</code> 从不会参与到标识符解析过程。</p>
<p>换句话说，在代码中当访问 <code>this</code> 的时候，它的值是直接从 <code>执行上下文</code> 中获取的，并不需要任何作用域链查找。<code>this</code> 的值只在进入上下文的时候进行一次确定。</p>
<p>顺便说一下，与 ECMAScript 相反，Python 的方法都会拥有一个被当作简单变量的 <code>self</code> 参数，这个变量的值在各个方法中是相同的的并且在执行过程中可以被更改成其他值。<br>在 ECMAScript 中，给 <code>this</code> 赋一个新值是不可能的，因为，它不是一个变量并且不存在于变量对象中。</p>
<p>在全局上下文中，<code>this</code> 就等于 <code>全局对象</code> 本身，这也意味着 <code>this</code> 就是 <code>全局变量对象</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x, <span class="keyword">this</span>.x, <span class="built_in">window</span>.x);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">f(); <span class="comment">// 输出了全局对象</span></span><br></pre></td></tr></table></figure>
<p>在函数上下文的情况下，对函数的每次调用，其中的 <code>this</code> 值可能是不同的。这个 <code>this</code> 值是通过函数调用表达式（也就是函数被调用的方式）的形式由 <code>caller</code> 所提供的。</p>
<p>让我们通过例子看一下，对于一个代码相同的函数，<code>this</code> 值是如何在不同的调用中（函数触发的不同方式），由 <code>caller</code> 给出不同的结果的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// global object</span></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123; <span class="attr">baz</span>: foo &#125;;</span><br><span class="line">bar.baz(); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line">(bar.baz)();            <span class="comment">// also bar</span></span><br><span class="line">(bar.baz = bar.baz)();  <span class="comment">// but here is global object</span></span><br><span class="line">(bar.baz, bar.baz)();   <span class="comment">// also global object</span></span><br><span class="line">(<span class="literal">false</span> || bar.baz)();   <span class="comment">// also global object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherFoo = bar.baz;</span><br><span class="line">otherFoo();             <span class="comment">// again global object</span></span><br></pre></td></tr></table></figure>
<h4 id="bind、call、apply"><a href="#bind、call、apply" class="headerlink" title="bind、call、apply"></a><code>bind</code>、<code>call</code>、<code>apply</code></h4><p><code>call apply</code> 给了代码在控制 <code>this</code> 的能力。</p>
<p><code>bind</code> 是基于 <code>call apply</code> 实现的高阶函数。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind Polyfill</a>：fun.bind(thisArg[, arg1[, arg2[, …]]])<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(Function.prototype.apply.bind.call === Function.prototype.call);</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : oThis, aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数拥有 prototype</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// native functions don't have a prototype</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 this 是构造函数，fBound 继承相关属性</span></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>this</code> 绑定</p>
<p>在 JavaScript 中，<code>this</code> 和 <code>函数</code> 之间的绑定时松散的，体现在我们可以轻易的通过 <code>call</code>、<code>apply</code> <code>指定</code> 或 <code>修改</code> <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#id'</span>).foreach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  $(<span class="keyword">this</span>).click();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="执行上下文总结"><a href="#执行上下文总结" class="headerlink" title="执行上下文总结"></a>执行上下文总结</h3><ul>
<li><code>变量/活动对象</code>：记录运行时所需要的数据，变量、函数、形参、实参等。</li>
<li><code>作用域链</code>：即 <code>变量/活动对象链</code>，为引擎进行变量查找提供基础。</li>
<li><code>this</code>：指明了当前执行的函数作用在哪个对象身上，方法的作用对象是谁。</li>
</ul>
<p>全局上下文 和 函数上下文比较：</p>
<p>在全局上下文中，<code>this=全局对象本身=变量对象</code>。</p>
<p>在函数上下文中，<code>this</code> 是 <code>执行上下文</code> 的一个属性。</p>
<p>所以这也解释了一些现象，<code>全局作用域</code> 下的 <code>变量或函数</code> 成为了 <code>全局对象的属性</code>了，如上面示例的代码。</p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><a href="https://www.nosuchfield.com/2017/07/16/Talk-about-compilation-principles-1/" target="_blank" rel="noopener">聊聊编译原理（一） - 词法分析</a><br><a href="https://www.nosuchfield.com/2017/07/30/Talk-about-compilation-principles-2/" target="_blank" rel="noopener">聊聊编译原理（二） - 语法分析</a></p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul>
<li>编译型语言，编译步骤分为：<code>词法分析</code>、<code>语法分析</code>、<code>语义检查</code>、<code>代码优化</code> 和 <code>字节生成</code>。</li>
<li>解释型语言，通过 <code>词法分析</code> 和 <code>语法分析</code> 得到 <code>语法分析树</code> 后，就可以开始 <code>解释执行</code> 了。</li>
</ul>
<p>这里是一个简单原始的关于解析过程的原理，仅作为参考，详细的解析过程还需要更深一步的研究。</p>
<p>JavaScript 执行过程，如果一个 <code>文档流</code> 中包含多个 <code>script代码段</code>（用script标签分隔的js代码或引入的js文件），它们的运行顺序是：</p>
<ul>
<li>阶段一：解析<ul>
<li>步骤1. 载入第一个代码段（js执行引擎并非一行一行地执行程序，而是一段一段地分析执行的）。</li>
<li>步骤2. 做 <code>词法分析</code> -&gt; <code>[词法作用域]</code> 和 <code>语法分析</code> -&gt; <code>[语法分析树]</code>，如果有错则报语法错误(<code>Syntax Error</code>)（<code>解析时错误</code>，比如括号不匹配等），并跳转到步骤5。</li>
<li>步骤3. 对 <code>var</code> 变量 和 <code>function</code> 定义 做 <code>预解析</code>（永远不会报错的，因为只解析正确的声明）。</li>
</ul>
</li>
<li>阶段二：执行<ul>
<li>步骤4. 执行代码段，有错则报错（<code>运行时错误</code>，比如变量未定义）。</li>
<li>步骤5. 如果还有下一个代码段，则读入下一个代码段，重复步骤2。</li>
<li>步骤6. 结束</li>
</ul>
</li>
</ul>
<h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><ul>
<li>解析(2,3)：通过 <code>词法分析</code>、<code>语法分析</code> 和 <code>预解析</code> 构造的 <code>语法分析树</code>。</li>
<li>执行( 4 )：执行具体的某个函数，JS引擎在执行每个函数实例时，会创建一个 <code>执行上下文</code>。</li>
</ul>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ul>
<li>词法分析 -&gt; 词法作用域<ul>
<li>变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。</li>
<li><code>with</code> 和 <code>eval</code> 除外，所以只能说JS的作用域机制非常接近 <code>词法作用域</code>（Lexical scope）。</li>
<li><code>词法分析</code>（英语：lexical analysis）是计算机科学中将 <code>字符序列</code> 转换为 <code>标记（token）序列</code> 的过程。</li>
<li><code>词法分析器（扫描器）</code> 的功能输入源程序，按照构词规则分解成一系列单词符号。如：<code>关键字</code>、<code>标识符</code>、<code>常数</code>、<code>运算符</code>、<code>分界符</code> 等。</li>
</ul>
</li>
</ul>
<p>实际上，<code>运行时的作用域链</code> 并不是 <code>词法分析</code> 阶段 得到的，而是运行时得到的，但是在 <code>词法分析阶段</code> 能够确定作用域是一定，要不然写代码的人无法确定作用域，代码无法编写和理解。<br>在相同规则下，人和解释器对代码的理解是一致的。<br>某些情况下，静态分析也无法分析出完整的作用域链，比如递归的情况，这个阶段根本无法预知递归深度，无法得出实际的作用域链。</p>
<ul>
<li>语法分析树（SyntaxTree）<ul>
<li>可以直观地表示出这段代码的相关信息，具体的实现就是JS引擎创建了一些表。</li>
<li>用来记录每个方法的 <em>内部变量集（variables）</em>、<em>内嵌函数集（functions）</em> 和 <em>作用域（scope）</em> 等。</li>
</ul>
</li>
</ul>
<ul>
<li>执行环境/执行上下文（ExecutionContext）<ul>
<li>可理解为记录当前执行的方法 <em>外部描述信息</em> 的对象。</li>
<li>记录所执行函数的 <em>活动对象（activeObject）</em>、<em>作用域链（scope-chain）</em>、<em>this</em>。</li>
</ul>
</li>
</ul>
<ul>
<li>活动对象（activeObject）<ul>
<li>可理解为记录当前执行的方法 <em>内部执行信息</em> 的对象。</li>
<li>记录 <em>内部变量集（variables）</em>、<em>内嵌函数集（functions）</em>、<em>实参（arguments）</em>、<em>作用域链（scopeChain）</em> 等执行所需信息。</li>
<li>直接 <em>内部变量集（variables）</em>、<em>内嵌函数集（functions）</em> 是直接 <em>语法分析树</em> 复制过来的。</li>
<li>执行时，活动对象里的内部变量集全部被设置为 <code>undefined</code>, 创建<em>形参（parameters</em>）和<em>实参（arguments）</em>对象, 执行方法内的赋值语句，这才会对变量集中的变量进行赋值。</li>
<li>作用域链 闭包。</li>
</ul>
</li>
</ul>
<ul>
<li>作用域链<ul>
<li>简单的理解为 <em>变量对象链</em>，解释器可见的。</li>
<li>词法作用域 的实现机制就是 作用域链（scopeChain），作用域链 是一套按名称查找（Name Lookup）的机制。</li>
</ul>
</li>
</ul>
<ul>
<li>闭包<ul>
<li>闭包 是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</li>
<li>保护函数内的变量安全，实现 <em>私有属性</em> 和 <em>私有方法</em>（不能被外部访问）。</li>
<li>闭包就是将 <em>函数内部和函数外部</em> 连接起来的一座桥梁，让外部环境有途径访问内部变量。</li>
<li>闭包函数可以访问所保持的作用域链上的外部环境。</li>
</ul>
</li>
</ul>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>lexical-analyzer Lexer Tokenizer</p>
<p>词法分析主要分为3步：</p>
<ul>
<li>第1步：分析 <code>形参</code></li>
<li>第2步：分析 <code>变量声明</code></li>
<li>第3步：分析 <code>函数声明</code></li>
</ul>
<p>在词法分析阶段，<code>变量声明</code> 和 <code>函数声明</code> 被提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str);   <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(str);   <span class="comment">// local</span></span><br><span class="line">  <span class="keyword">var</span> str;</span><br><span class="line">  <span class="built_in">console</span>.log(str);   <span class="comment">// local</span></span><br><span class="line">  str = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><code>var str = &#39;local&#39;; &lt;==&gt; var str; str = &#39;local&#39;;</code></p>
<p>函数表达式中，变量声明部分被提升，但是知道执行到这一句时，变量才被赋值为一个函数，所以函数表达式需要在使用之前赋值，而函数声明这不需要。</p>
<h3 id="模拟解析"><a href="#模拟解析" class="headerlink" title="模拟解析"></a>模拟解析</h3><p>模拟代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> escope = <span class="built_in">require</span>(<span class="string">'escope'</span>);</span><br><span class="line"><span class="keyword">var</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"><span class="keyword">var</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var i = 1, j = 2, k = 3;</span></span><br><span class="line"><span class="string">function a(o, p, x, q) &#123;</span></span><br><span class="line"><span class="string">  var x = 4;</span></span><br><span class="line"><span class="string">  console.log(i);</span></span><br><span class="line"><span class="string">  function b(r, s) &#123;</span></span><br><span class="line"><span class="string">    var i = 11, y = 5;</span></span><br><span class="line"><span class="string">    console.log(i);</span></span><br><span class="line"><span class="string">    function c(t) &#123;</span></span><br><span class="line"><span class="string">      var z = 6;</span></span><br><span class="line"><span class="string">      console.log(i);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    //函数表达式</span></span><br><span class="line"><span class="string">    var d = function () &#123;</span></span><br><span class="line"><span class="string">      console.log(y);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    c(60);</span></span><br><span class="line"><span class="string">    d();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  b(40, 50);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">a(10, 20, 30);</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ast = esprima.parse(code);</span><br><span class="line"><span class="keyword">var</span> scopeManager = escope.analyze(ast);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentScope = scopeManager.acquire(ast);   <span class="comment">// global scope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.dir(ast, &#123;depth: null&#125;);</span></span><br><span class="line"><span class="built_in">console</span>.dir(scopeManager, &#123;<span class="attr">depth</span>: <span class="literal">null</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="images/estree.png" alt="ESTree"></p>
<p>上面的模拟代码生成了JS解析过程所产生的用于在执行阶段使用的信息，但是并不代表解释器和这个一样的。</p>
<p>这些分析工具有很多，他们大都用于 <code>代码压缩</code>、<code>代码混淆</code>、<code>代码转换（ES6-&gt;ES5，babel，ts-&gt;js）</code>、<code>代码优化</code>、<code>学习研究</code> 等。</p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>javascript-the-core <a href="http://weizhifeng.net/javascript-the-core.html" target="_blank" rel="noopener">翻译</a> <a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="noopener">原文</a></li>
<li><a href="http://www.raychase.net/1968?replytocom=51795" target="_blank" rel="noopener">http://www.raychase.net/1968?replytocom=51795</a></li>
<li><a href="http://www.codeceo.com/article/javascript-threaded.html" target="_blank" rel="noopener">http://www.codeceo.com/article/javascript-threaded.html</a></li>
<li><a href="http://www.cnblogs.com/yakun/p/3802725.html" target="_blank" rel="noopener">http://www.cnblogs.com/yakun/p/3802725.html</a></li>
<li><a href="http://www.cnblogs.com/rainman/archive/2008/12/26/1363321.html" target="_blank" rel="noopener">http://www.cnblogs.com/rainman/archive/2008/12/26/1363321.html</a></li>
<li><a href="http://ejohn.org/blog/how-javascript-timers-work/" target="_blank" rel="noopener">http://ejohn.org/blog/how-javascript-timers-work/</a></li>
<li><a href="http://www.zhihu.com/question/20866267" target="_blank" rel="noopener">http://www.zhihu.com/question/20866267</a></li>
<li><a href="http://www.zhihu.com/question/31982417" target="_blank" rel="noopener">http://www.zhihu.com/question/31982417</a></li>
<li><a href="http://blog.thomasbelin.fr/p/javascript-single-threaded-et-asynchrone/" target="_blank" rel="noopener">http://blog.thomasbelin.fr/p/javascript-single-threaded-et-asynchrone/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>
<li><a href="http://blog.csdn.net/z742182637/article/details/51536140" target="_blank" rel="noopener">http://blog.csdn.net/z742182637/article/details/51536140</a></li>
<li><a href="http://www.cnblogs.com/wilber2013/p/4909430.html#_nav_0" target="_blank" rel="noopener">http://www.cnblogs.com/wilber2013/p/4909430.html#_nav_0</a></li>
<li><a href="https://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/" target="_blank" rel="noopener">https://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/p/3524977.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphinX/p/3524977.html</a></li>
<li><a href="http://www.kancloud.cn/kancloud/deep-understand-javascript/43686" target="_blank" rel="noopener">http://www.kancloud.cn/kancloud/deep-understand-javascript/43686</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Liu Yanjie
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>